function pL(r,e){for(var t=0;t<e.length;t++){const n=e[t];if(typeof n!="string"&&!Array.isArray(n)){for(const i in n)if(i!=="default"&&!(i in r)){const s=Object.getOwnPropertyDescriptor(n,i);s&&Object.defineProperty(r,i,s.get?s:{enumerable:!0,get:()=>n[i]})}}}return Object.freeze(Object.defineProperty(r,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))n(i);new MutationObserver(i=>{for(const s of i)if(s.type==="childList")for(const a of s.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&n(a)}).observe(document,{childList:!0,subtree:!0});function t(i){const s={};return i.integrity&&(s.integrity=i.integrity),i.referrerPolicy&&(s.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?s.credentials="include":i.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function n(i){if(i.ep)return;i.ep=!0;const s=t(i);fetch(i.href,s)}})();function v0(r){return r&&r.__esModule&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r}function SS(r){if(Object.prototype.hasOwnProperty.call(r,"__esModule"))return r;var e=r.default;if(typeof e=="function"){var t=function n(){return this instanceof n?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(r).forEach(function(n){var i=Object.getOwnPropertyDescriptor(r,n);Object.defineProperty(t,n,i.get?i:{enumerable:!0,get:function(){return r[n]}})}),t}var $v={exports:{}},up={},Gv={exports:{}},cn={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var tE;function mL(){if(tE)return cn;tE=1;var r=Symbol.for("react.element"),e=Symbol.for("react.portal"),t=Symbol.for("react.fragment"),n=Symbol.for("react.strict_mode"),i=Symbol.for("react.profiler"),s=Symbol.for("react.provider"),a=Symbol.for("react.context"),o=Symbol.for("react.forward_ref"),u=Symbol.for("react.suspense"),h=Symbol.for("react.memo"),p=Symbol.for("react.lazy"),m=Symbol.iterator;function y(z){return z===null||typeof z!="object"?null:(z=m&&z[m]||z["@@iterator"],typeof z=="function"?z:null)}var v={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},S=Object.assign,T={};function E(z,q,ve){this.props=z,this.context=q,this.refs=T,this.updater=ve||v}E.prototype.isReactComponent={},E.prototype.setState=function(z,q){if(typeof z!="object"&&typeof z!="function"&&z!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,z,q,"setState")},E.prototype.forceUpdate=function(z){this.updater.enqueueForceUpdate(this,z,"forceUpdate")};function w(){}w.prototype=E.prototype;function C(z,q,ve){this.props=z,this.context=q,this.refs=T,this.updater=ve||v}var A=C.prototype=new w;A.constructor=C,S(A,E.prototype),A.isPureReactComponent=!0;var I=Array.isArray,F=Object.prototype.hasOwnProperty,U={current:null},V={key:!0,ref:!0,__self:!0,__source:!0};function G(z,q,ve){var Ce,ke={},We=null,tt=null;if(q!=null)for(Ce in q.ref!==void 0&&(tt=q.ref),q.key!==void 0&&(We=""+q.key),q)F.call(q,Ce)&&!V.hasOwnProperty(Ce)&&(ke[Ce]=q[Ce]);var nt=arguments.length-2;if(nt===1)ke.children=ve;else if(1<nt){for(var ut=Array(nt),kt=0;kt<nt;kt++)ut[kt]=arguments[kt+2];ke.children=ut}if(z&&z.defaultProps)for(Ce in nt=z.defaultProps,nt)ke[Ce]===void 0&&(ke[Ce]=nt[Ce]);return{$$typeof:r,type:z,key:We,ref:tt,props:ke,_owner:U.current}}function L(z,q){return{$$typeof:r,type:z.type,key:q,ref:z.ref,props:z.props,_owner:z._owner}}function k(z){return typeof z=="object"&&z!==null&&z.$$typeof===r}function O(z){var q={"=":"=0",":":"=2"};return"$"+z.replace(/[=:]/g,function(ve){return q[ve]})}var Q=/\/+/g;function le(z,q){return typeof z=="object"&&z!==null&&z.key!=null?O(""+z.key):q.toString(36)}function K(z,q,ve,Ce,ke){var We=typeof z;(We==="undefined"||We==="boolean")&&(z=null);var tt=!1;if(z===null)tt=!0;else switch(We){case"string":case"number":tt=!0;break;case"object":switch(z.$$typeof){case r:case e:tt=!0}}if(tt)return tt=z,ke=ke(tt),z=Ce===""?"."+le(tt,0):Ce,I(ke)?(ve="",z!=null&&(ve=z.replace(Q,"$&/")+"/"),K(ke,q,ve,"",function(kt){return kt})):ke!=null&&(k(ke)&&(ke=L(ke,ve+(!ke.key||tt&&tt.key===ke.key?"":(""+ke.key).replace(Q,"$&/")+"/")+z)),q.push(ke)),1;if(tt=0,Ce=Ce===""?".":Ce+":",I(z))for(var nt=0;nt<z.length;nt++){We=z[nt];var ut=Ce+le(We,nt);tt+=K(We,q,ve,ut,ke)}else if(ut=y(z),typeof ut=="function")for(z=ut.call(z),nt=0;!(We=z.next()).done;)We=We.value,ut=Ce+le(We,nt++),tt+=K(We,q,ve,ut,ke);else if(We==="object")throw q=String(z),Error("Objects are not valid as a React child (found: "+(q==="[object Object]"?"object with keys {"+Object.keys(z).join(", ")+"}":q)+"). If you meant to render a collection of children, use an array instead.");return tt}function ce(z,q,ve){if(z==null)return z;var Ce=[],ke=0;return K(z,Ce,"","",function(We){return q.call(ve,We,ke++)}),Ce}function de(z){if(z._status===-1){var q=z._result;q=q(),q.then(function(ve){(z._status===0||z._status===-1)&&(z._status=1,z._result=ve)},function(ve){(z._status===0||z._status===-1)&&(z._status=2,z._result=ve)}),z._status===-1&&(z._status=0,z._result=q)}if(z._status===1)return z._result.default;throw z._result}var me={current:null},Z={transition:null},re={ReactCurrentDispatcher:me,ReactCurrentBatchConfig:Z,ReactCurrentOwner:U};function ee(){throw Error("act(...) is not supported in production builds of React.")}return cn.Children={map:ce,forEach:function(z,q,ve){ce(z,function(){q.apply(this,arguments)},ve)},count:function(z){var q=0;return ce(z,function(){q++}),q},toArray:function(z){return ce(z,function(q){return q})||[]},only:function(z){if(!k(z))throw Error("React.Children.only expected to receive a single React element child.");return z}},cn.Component=E,cn.Fragment=t,cn.Profiler=i,cn.PureComponent=C,cn.StrictMode=n,cn.Suspense=u,cn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=re,cn.act=ee,cn.cloneElement=function(z,q,ve){if(z==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+z+".");var Ce=S({},z.props),ke=z.key,We=z.ref,tt=z._owner;if(q!=null){if(q.ref!==void 0&&(We=q.ref,tt=U.current),q.key!==void 0&&(ke=""+q.key),z.type&&z.type.defaultProps)var nt=z.type.defaultProps;for(ut in q)F.call(q,ut)&&!V.hasOwnProperty(ut)&&(Ce[ut]=q[ut]===void 0&&nt!==void 0?nt[ut]:q[ut])}var ut=arguments.length-2;if(ut===1)Ce.children=ve;else if(1<ut){nt=Array(ut);for(var kt=0;kt<ut;kt++)nt[kt]=arguments[kt+2];Ce.children=nt}return{$$typeof:r,type:z.type,key:ke,ref:We,props:Ce,_owner:tt}},cn.createContext=function(z){return z={$$typeof:a,_currentValue:z,_currentValue2:z,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},z.Provider={$$typeof:s,_context:z},z.Consumer=z},cn.createElement=G,cn.createFactory=function(z){var q=G.bind(null,z);return q.type=z,q},cn.createRef=function(){return{current:null}},cn.forwardRef=function(z){return{$$typeof:o,render:z}},cn.isValidElement=k,cn.lazy=function(z){return{$$typeof:p,_payload:{_status:-1,_result:z},_init:de}},cn.memo=function(z,q){return{$$typeof:h,type:z,compare:q===void 0?null:q}},cn.startTransition=function(z){var q=Z.transition;Z.transition={};try{z()}finally{Z.transition=q}},cn.unstable_act=ee,cn.useCallback=function(z,q){return me.current.useCallback(z,q)},cn.useContext=function(z){return me.current.useContext(z)},cn.useDebugValue=function(){},cn.useDeferredValue=function(z){return me.current.useDeferredValue(z)},cn.useEffect=function(z,q){return me.current.useEffect(z,q)},cn.useId=function(){return me.current.useId()},cn.useImperativeHandle=function(z,q,ve){return me.current.useImperativeHandle(z,q,ve)},cn.useInsertionEffect=function(z,q){return me.current.useInsertionEffect(z,q)},cn.useLayoutEffect=function(z,q){return me.current.useLayoutEffect(z,q)},cn.useMemo=function(z,q){return me.current.useMemo(z,q)},cn.useReducer=function(z,q,ve){return me.current.useReducer(z,q,ve)},cn.useRef=function(z){return me.current.useRef(z)},cn.useState=function(z){return me.current.useState(z)},cn.useSyncExternalStore=function(z,q,ve){return me.current.useSyncExternalStore(z,q,ve)},cn.useTransition=function(){return me.current.useTransition()},cn.version="18.3.1",cn}var nE;function _0(){return nE||(nE=1,Gv.exports=mL()),Gv.exports}/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var rE;function gL(){if(rE)return up;rE=1;var r=_0(),e=Symbol.for("react.element"),t=Symbol.for("react.fragment"),n=Object.prototype.hasOwnProperty,i=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,s={key:!0,ref:!0,__self:!0,__source:!0};function a(o,u,h){var p,m={},y=null,v=null;h!==void 0&&(y=""+h),u.key!==void 0&&(y=""+u.key),u.ref!==void 0&&(v=u.ref);for(p in u)n.call(u,p)&&!s.hasOwnProperty(p)&&(m[p]=u[p]);if(o&&o.defaultProps)for(p in u=o.defaultProps,u)m[p]===void 0&&(m[p]=u[p]);return{$$typeof:e,type:o,key:y,ref:v,props:m,_owner:i.current}}return up.Fragment=t,up.jsx=a,up.jsxs=a,up}var iE;function yL(){return iE||(iE=1,$v.exports=gL()),$v.exports}var lt=yL(),gt=_0();const vL=v0(gt);var Dg={},Wv={exports:{}},ss={},jv={exports:{}},qv={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var sE;function _L(){return sE||(sE=1,function(r){function e(Z,re){var ee=Z.length;Z.push(re);e:for(;0<ee;){var z=ee-1>>>1,q=Z[z];if(0<i(q,re))Z[z]=re,Z[ee]=q,ee=z;else break e}}function t(Z){return Z.length===0?null:Z[0]}function n(Z){if(Z.length===0)return null;var re=Z[0],ee=Z.pop();if(ee!==re){Z[0]=ee;e:for(var z=0,q=Z.length,ve=q>>>1;z<ve;){var Ce=2*(z+1)-1,ke=Z[Ce],We=Ce+1,tt=Z[We];if(0>i(ke,ee))We<q&&0>i(tt,ke)?(Z[z]=tt,Z[We]=ee,z=We):(Z[z]=ke,Z[Ce]=ee,z=Ce);else if(We<q&&0>i(tt,ee))Z[z]=tt,Z[We]=ee,z=We;else break e}}return re}function i(Z,re){var ee=Z.sortIndex-re.sortIndex;return ee!==0?ee:Z.id-re.id}if(typeof performance=="object"&&typeof performance.now=="function"){var s=performance;r.unstable_now=function(){return s.now()}}else{var a=Date,o=a.now();r.unstable_now=function(){return a.now()-o}}var u=[],h=[],p=1,m=null,y=3,v=!1,S=!1,T=!1,E=typeof setTimeout=="function"?setTimeout:null,w=typeof clearTimeout=="function"?clearTimeout:null,C=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function A(Z){for(var re=t(h);re!==null;){if(re.callback===null)n(h);else if(re.startTime<=Z)n(h),re.sortIndex=re.expirationTime,e(u,re);else break;re=t(h)}}function I(Z){if(T=!1,A(Z),!S)if(t(u)!==null)S=!0,de(F);else{var re=t(h);re!==null&&me(I,re.startTime-Z)}}function F(Z,re){S=!1,T&&(T=!1,w(G),G=-1),v=!0;var ee=y;try{for(A(re),m=t(u);m!==null&&(!(m.expirationTime>re)||Z&&!O());){var z=m.callback;if(typeof z=="function"){m.callback=null,y=m.priorityLevel;var q=z(m.expirationTime<=re);re=r.unstable_now(),typeof q=="function"?m.callback=q:m===t(u)&&n(u),A(re)}else n(u);m=t(u)}if(m!==null)var ve=!0;else{var Ce=t(h);Ce!==null&&me(I,Ce.startTime-re),ve=!1}return ve}finally{m=null,y=ee,v=!1}}var U=!1,V=null,G=-1,L=5,k=-1;function O(){return!(r.unstable_now()-k<L)}function Q(){if(V!==null){var Z=r.unstable_now();k=Z;var re=!0;try{re=V(!0,Z)}finally{re?le():(U=!1,V=null)}}else U=!1}var le;if(typeof C=="function")le=function(){C(Q)};else if(typeof MessageChannel<"u"){var K=new MessageChannel,ce=K.port2;K.port1.onmessage=Q,le=function(){ce.postMessage(null)}}else le=function(){E(Q,0)};function de(Z){V=Z,U||(U=!0,le())}function me(Z,re){G=E(function(){Z(r.unstable_now())},re)}r.unstable_IdlePriority=5,r.unstable_ImmediatePriority=1,r.unstable_LowPriority=4,r.unstable_NormalPriority=3,r.unstable_Profiling=null,r.unstable_UserBlockingPriority=2,r.unstable_cancelCallback=function(Z){Z.callback=null},r.unstable_continueExecution=function(){S||v||(S=!0,de(F))},r.unstable_forceFrameRate=function(Z){0>Z||125<Z?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):L=0<Z?Math.floor(1e3/Z):5},r.unstable_getCurrentPriorityLevel=function(){return y},r.unstable_getFirstCallbackNode=function(){return t(u)},r.unstable_next=function(Z){switch(y){case 1:case 2:case 3:var re=3;break;default:re=y}var ee=y;y=re;try{return Z()}finally{y=ee}},r.unstable_pauseExecution=function(){},r.unstable_requestPaint=function(){},r.unstable_runWithPriority=function(Z,re){switch(Z){case 1:case 2:case 3:case 4:case 5:break;default:Z=3}var ee=y;y=Z;try{return re()}finally{y=ee}},r.unstable_scheduleCallback=function(Z,re,ee){var z=r.unstable_now();switch(typeof ee=="object"&&ee!==null?(ee=ee.delay,ee=typeof ee=="number"&&0<ee?z+ee:z):ee=z,Z){case 1:var q=-1;break;case 2:q=250;break;case 5:q=1073741823;break;case 4:q=1e4;break;default:q=5e3}return q=ee+q,Z={id:p++,callback:re,priorityLevel:Z,startTime:ee,expirationTime:q,sortIndex:-1},ee>z?(Z.sortIndex=ee,e(h,Z),t(u)===null&&Z===t(h)&&(T?(w(G),G=-1):T=!0,me(I,ee-z))):(Z.sortIndex=q,e(u,Z),S||v||(S=!0,de(F))),Z},r.unstable_shouldYield=O,r.unstable_wrapCallback=function(Z){var re=y;return function(){var ee=y;y=re;try{return Z.apply(this,arguments)}finally{y=ee}}}}(qv)),qv}var aE;function xL(){return aE||(aE=1,jv.exports=_L()),jv.exports}/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var oE;function SL(){if(oE)return ss;oE=1;var r=_0(),e=xL();function t(l){for(var c="https://reactjs.org/docs/error-decoder.html?invariant="+l,g=1;g<arguments.length;g++)c+="&args[]="+encodeURIComponent(arguments[g]);return"Minified React error #"+l+"; visit "+c+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var n=new Set,i={};function s(l,c){a(l,c),a(l+"Capture",c)}function a(l,c){for(i[l]=c,l=0;l<c.length;l++)n.add(c[l])}var o=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),u=Object.prototype.hasOwnProperty,h=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,p={},m={};function y(l){return u.call(m,l)?!0:u.call(p,l)?!1:h.test(l)?m[l]=!0:(p[l]=!0,!1)}function v(l,c,g,x){if(g!==null&&g.type===0)return!1;switch(typeof c){case"function":case"symbol":return!0;case"boolean":return x?!1:g!==null?!g.acceptsBooleans:(l=l.toLowerCase().slice(0,5),l!=="data-"&&l!=="aria-");default:return!1}}function S(l,c,g,x){if(c===null||typeof c>"u"||v(l,c,g,x))return!0;if(x)return!1;if(g!==null)switch(g.type){case 3:return!c;case 4:return c===!1;case 5:return isNaN(c);case 6:return isNaN(c)||1>c}return!1}function T(l,c,g,x,M,R,B){this.acceptsBooleans=c===2||c===3||c===4,this.attributeName=x,this.attributeNamespace=M,this.mustUseProperty=g,this.propertyName=l,this.type=c,this.sanitizeURL=R,this.removeEmptyString=B}var E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(l){E[l]=new T(l,0,!1,l,null,!1,!1)}),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(l){var c=l[0];E[c]=new T(c,1,!1,l[1],null,!1,!1)}),["contentEditable","draggable","spellCheck","value"].forEach(function(l){E[l]=new T(l,2,!1,l.toLowerCase(),null,!1,!1)}),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(l){E[l]=new T(l,2,!1,l,null,!1,!1)}),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(l){E[l]=new T(l,3,!1,l.toLowerCase(),null,!1,!1)}),["checked","multiple","muted","selected"].forEach(function(l){E[l]=new T(l,3,!0,l,null,!1,!1)}),["capture","download"].forEach(function(l){E[l]=new T(l,4,!1,l,null,!1,!1)}),["cols","rows","size","span"].forEach(function(l){E[l]=new T(l,6,!1,l,null,!1,!1)}),["rowSpan","start"].forEach(function(l){E[l]=new T(l,5,!1,l.toLowerCase(),null,!1,!1)});var w=/[\-:]([a-z])/g;function C(l){return l[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(l){var c=l.replace(w,C);E[c]=new T(c,1,!1,l,null,!1,!1)}),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(l){var c=l.replace(w,C);E[c]=new T(c,1,!1,l,"http://www.w3.org/1999/xlink",!1,!1)}),["xml:base","xml:lang","xml:space"].forEach(function(l){var c=l.replace(w,C);E[c]=new T(c,1,!1,l,"http://www.w3.org/XML/1998/namespace",!1,!1)}),["tabIndex","crossOrigin"].forEach(function(l){E[l]=new T(l,1,!1,l.toLowerCase(),null,!1,!1)}),E.xlinkHref=new T("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach(function(l){E[l]=new T(l,1,!1,l.toLowerCase(),null,!0,!0)});function A(l,c,g,x){var M=E.hasOwnProperty(c)?E[c]:null;(M!==null?M.type!==0:x||!(2<c.length)||c[0]!=="o"&&c[0]!=="O"||c[1]!=="n"&&c[1]!=="N")&&(S(c,g,M,x)&&(g=null),x||M===null?y(c)&&(g===null?l.removeAttribute(c):l.setAttribute(c,""+g)):M.mustUseProperty?l[M.propertyName]=g===null?M.type===3?!1:"":g:(c=M.attributeName,x=M.attributeNamespace,g===null?l.removeAttribute(c):(M=M.type,g=M===3||M===4&&g===!0?"":""+g,x?l.setAttributeNS(x,c,g):l.setAttribute(c,g))))}var I=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,F=Symbol.for("react.element"),U=Symbol.for("react.portal"),V=Symbol.for("react.fragment"),G=Symbol.for("react.strict_mode"),L=Symbol.for("react.profiler"),k=Symbol.for("react.provider"),O=Symbol.for("react.context"),Q=Symbol.for("react.forward_ref"),le=Symbol.for("react.suspense"),K=Symbol.for("react.suspense_list"),ce=Symbol.for("react.memo"),de=Symbol.for("react.lazy"),me=Symbol.for("react.offscreen"),Z=Symbol.iterator;function re(l){return l===null||typeof l!="object"?null:(l=Z&&l[Z]||l["@@iterator"],typeof l=="function"?l:null)}var ee=Object.assign,z;function q(l){if(z===void 0)try{throw Error()}catch(g){var c=g.stack.trim().match(/\n( *(at )?)/);z=c&&c[1]||""}return`
`+z+l}var ve=!1;function Ce(l,c){if(!l||ve)return"";ve=!0;var g=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(c)if(c=function(){throw Error()},Object.defineProperty(c.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(c,[])}catch(we){var x=we}Reflect.construct(l,[],c)}else{try{c.call()}catch(we){x=we}l.call(c.prototype)}else{try{throw Error()}catch(we){x=we}l()}}catch(we){if(we&&x&&typeof we.stack=="string"){for(var M=we.stack.split(`
`),R=x.stack.split(`
`),B=M.length-1,te=R.length-1;1<=B&&0<=te&&M[B]!==R[te];)te--;for(;1<=B&&0<=te;B--,te--)if(M[B]!==R[te]){if(B!==1||te!==1)do if(B--,te--,0>te||M[B]!==R[te]){var oe=`
`+M[B].replace(" at new "," at ");return l.displayName&&oe.includes("<anonymous>")&&(oe=oe.replace("<anonymous>",l.displayName)),oe}while(1<=B&&0<=te);break}}}finally{ve=!1,Error.prepareStackTrace=g}return(l=l?l.displayName||l.name:"")?q(l):""}function ke(l){switch(l.tag){case 5:return q(l.type);case 16:return q("Lazy");case 13:return q("Suspense");case 19:return q("SuspenseList");case 0:case 2:case 15:return l=Ce(l.type,!1),l;case 11:return l=Ce(l.type.render,!1),l;case 1:return l=Ce(l.type,!0),l;default:return""}}function We(l){if(l==null)return null;if(typeof l=="function")return l.displayName||l.name||null;if(typeof l=="string")return l;switch(l){case V:return"Fragment";case U:return"Portal";case L:return"Profiler";case G:return"StrictMode";case le:return"Suspense";case K:return"SuspenseList"}if(typeof l=="object")switch(l.$$typeof){case O:return(l.displayName||"Context")+".Consumer";case k:return(l._context.displayName||"Context")+".Provider";case Q:var c=l.render;return l=l.displayName,l||(l=c.displayName||c.name||"",l=l!==""?"ForwardRef("+l+")":"ForwardRef"),l;case ce:return c=l.displayName||null,c!==null?c:We(l.type)||"Memo";case de:c=l._payload,l=l._init;try{return We(l(c))}catch{}}return null}function tt(l){var c=l.type;switch(l.tag){case 24:return"Cache";case 9:return(c.displayName||"Context")+".Consumer";case 10:return(c._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return l=c.render,l=l.displayName||l.name||"",c.displayName||(l!==""?"ForwardRef("+l+")":"ForwardRef");case 7:return"Fragment";case 5:return c;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return We(c);case 8:return c===G?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof c=="function")return c.displayName||c.name||null;if(typeof c=="string")return c}return null}function nt(l){switch(typeof l){case"boolean":case"number":case"string":case"undefined":return l;case"object":return l;default:return""}}function ut(l){var c=l.type;return(l=l.nodeName)&&l.toLowerCase()==="input"&&(c==="checkbox"||c==="radio")}function kt(l){var c=ut(l)?"checked":"value",g=Object.getOwnPropertyDescriptor(l.constructor.prototype,c),x=""+l[c];if(!l.hasOwnProperty(c)&&typeof g<"u"&&typeof g.get=="function"&&typeof g.set=="function"){var M=g.get,R=g.set;return Object.defineProperty(l,c,{configurable:!0,get:function(){return M.call(this)},set:function(B){x=""+B,R.call(this,B)}}),Object.defineProperty(l,c,{enumerable:g.enumerable}),{getValue:function(){return x},setValue:function(B){x=""+B},stopTracking:function(){l._valueTracker=null,delete l[c]}}}}function vt(l){l._valueTracker||(l._valueTracker=kt(l))}function se(l){if(!l)return!1;var c=l._valueTracker;if(!c)return!0;var g=c.getValue(),x="";return l&&(x=ut(l)?l.checked?"true":"false":l.value),l=x,l!==g?(c.setValue(l),!0):!1}function Ve(l){if(l=l||(typeof document<"u"?document:void 0),typeof l>"u")return null;try{return l.activeElement||l.body}catch{return l.body}}function Ie(l,c){var g=c.checked;return ee({},c,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:g??l._wrapperState.initialChecked})}function je(l,c){var g=c.defaultValue==null?"":c.defaultValue,x=c.checked!=null?c.checked:c.defaultChecked;g=nt(c.value!=null?c.value:g),l._wrapperState={initialChecked:x,initialValue:g,controlled:c.type==="checkbox"||c.type==="radio"?c.checked!=null:c.value!=null}}function De(l,c){c=c.checked,c!=null&&A(l,"checked",c,!1)}function bt(l,c){De(l,c);var g=nt(c.value),x=c.type;if(g!=null)x==="number"?(g===0&&l.value===""||l.value!=g)&&(l.value=""+g):l.value!==""+g&&(l.value=""+g);else if(x==="submit"||x==="reset"){l.removeAttribute("value");return}c.hasOwnProperty("value")?dt(l,c.type,g):c.hasOwnProperty("defaultValue")&&dt(l,c.type,nt(c.defaultValue)),c.checked==null&&c.defaultChecked!=null&&(l.defaultChecked=!!c.defaultChecked)}function at(l,c,g){if(c.hasOwnProperty("value")||c.hasOwnProperty("defaultValue")){var x=c.type;if(!(x!=="submit"&&x!=="reset"||c.value!==void 0&&c.value!==null))return;c=""+l._wrapperState.initialValue,g||c===l.value||(l.value=c),l.defaultValue=c}g=l.name,g!==""&&(l.name=""),l.defaultChecked=!!l._wrapperState.initialChecked,g!==""&&(l.name=g)}function dt(l,c,g){(c!=="number"||Ve(l.ownerDocument)!==l)&&(g==null?l.defaultValue=""+l._wrapperState.initialValue:l.defaultValue!==""+g&&(l.defaultValue=""+g))}var Pt=Array.isArray;function Gt(l,c,g,x){if(l=l.options,c){c={};for(var M=0;M<g.length;M++)c["$"+g[M]]=!0;for(g=0;g<l.length;g++)M=c.hasOwnProperty("$"+l[g].value),l[g].selected!==M&&(l[g].selected=M),M&&x&&(l[g].defaultSelected=!0)}else{for(g=""+nt(g),c=null,M=0;M<l.length;M++){if(l[M].value===g){l[M].selected=!0,x&&(l[M].defaultSelected=!0);return}c!==null||l[M].disabled||(c=l[M])}c!==null&&(c.selected=!0)}}function wn(l,c){if(c.dangerouslySetInnerHTML!=null)throw Error(t(91));return ee({},c,{value:void 0,defaultValue:void 0,children:""+l._wrapperState.initialValue})}function J(l,c){var g=c.value;if(g==null){if(g=c.children,c=c.defaultValue,g!=null){if(c!=null)throw Error(t(92));if(Pt(g)){if(1<g.length)throw Error(t(93));g=g[0]}c=g}c==null&&(c=""),g=c}l._wrapperState={initialValue:nt(g)}}function $(l,c){var g=nt(c.value),x=nt(c.defaultValue);g!=null&&(g=""+g,g!==l.value&&(l.value=g),c.defaultValue==null&&l.defaultValue!==g&&(l.defaultValue=g)),x!=null&&(l.defaultValue=""+x)}function Se(l){var c=l.textContent;c===l._wrapperState.initialValue&&c!==""&&c!==null&&(l.value=c)}function qe(l){switch(l){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Oe(l,c){return l==null||l==="http://www.w3.org/1999/xhtml"?qe(c):l==="http://www.w3.org/2000/svg"&&c==="foreignObject"?"http://www.w3.org/1999/xhtml":l}var He,St=function(l){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(c,g,x,M){MSApp.execUnsafeLocalFunction(function(){return l(c,g,x,M)})}:l}(function(l,c){if(l.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in l)l.innerHTML=c;else{for(He=He||document.createElement("div"),He.innerHTML="<svg>"+c.valueOf().toString()+"</svg>",c=He.firstChild;l.firstChild;)l.removeChild(l.firstChild);for(;c.firstChild;)l.appendChild(c.firstChild)}});function Ke(l,c){if(c){var g=l.firstChild;if(g&&g===l.lastChild&&g.nodeType===3){g.nodeValue=c;return}}l.textContent=c}var rt={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},zt=["Webkit","ms","Moz","O"];Object.keys(rt).forEach(function(l){zt.forEach(function(c){c=c+l.charAt(0).toUpperCase()+l.substring(1),rt[c]=rt[l]})});function un(l,c,g){return c==null||typeof c=="boolean"||c===""?"":g||typeof c!="number"||c===0||rt.hasOwnProperty(l)&&rt[l]?(""+c).trim():c+"px"}function Xe(l,c){l=l.style;for(var g in c)if(c.hasOwnProperty(g)){var x=g.indexOf("--")===0,M=un(g,c[g],x);g==="float"&&(g="cssFloat"),x?l.setProperty(g,M):l[g]=M}}var fn=ee({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function ae(l,c){if(c){if(fn[l]&&(c.children!=null||c.dangerouslySetInnerHTML!=null))throw Error(t(137,l));if(c.dangerouslySetInnerHTML!=null){if(c.children!=null)throw Error(t(60));if(typeof c.dangerouslySetInnerHTML!="object"||!("__html"in c.dangerouslySetInnerHTML))throw Error(t(61))}if(c.style!=null&&typeof c.style!="object")throw Error(t(62))}}function Ne(l,c){if(l.indexOf("-")===-1)return typeof c.is=="string";switch(l){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var ze=null;function Fe(l){return l=l.target||l.srcElement||window,l.correspondingUseElement&&(l=l.correspondingUseElement),l.nodeType===3?l.parentNode:l}var Ct=null,ue=null,Qe=null;function Ze(l){if(l=sa(l)){if(typeof Ct!="function")throw Error(t(280));var c=l.stateNode;c&&(c=Wf(c),Ct(l.stateNode,l.type,c))}}function Re(l){ue?Qe?Qe.push(l):Qe=[l]:ue=l}function $e(){if(ue){var l=ue,c=Qe;if(Qe=ue=null,Ze(l),c)for(l=0;l<c.length;l++)Ze(c[l])}}function Et(l,c){return l(c)}function Yt(){}var yn=!1;function Zn(l,c,g){if(yn)return l(c,g);yn=!0;try{return Et(l,c,g)}finally{yn=!1,(ue!==null||Qe!==null)&&(Yt(),$e())}}function an(l,c){var g=l.stateNode;if(g===null)return null;var x=Wf(g);if(x===null)return null;g=x[c];e:switch(c){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(x=!x.disabled)||(l=l.type,x=!(l==="button"||l==="input"||l==="select"||l==="textarea")),l=!x;break e;default:l=!1}if(l)return null;if(g&&typeof g!="function")throw Error(t(231,c,typeof g));return g}var gr=!1;if(o)try{var qr={};Object.defineProperty(qr,"passive",{get:function(){gr=!0}}),window.addEventListener("test",qr,qr),window.removeEventListener("test",qr,qr)}catch{gr=!1}function Cu(l,c,g,x,M,R,B,te,oe){var we=Array.prototype.slice.call(arguments,3);try{c.apply(g,we)}catch(Be){this.onError(Be)}}var Xs=!1,Ks=null,ys=!1,Da=null,cf={onError:function(l){Xs=!0,Ks=l}};function ff(l,c,g,x,M,R,B,te,oe){Xs=!1,Ks=null,Cu.apply(cf,arguments)}function pd(l,c,g,x,M,R,B,te,oe){if(ff.apply(this,arguments),Xs){if(Xs){var we=Ks;Xs=!1,Ks=null}else throw Error(t(198));ys||(ys=!0,Da=we)}}function Ys(l){var c=l,g=l;if(l.alternate)for(;c.return;)c=c.return;else{l=c;do c=l,(c.flags&4098)!==0&&(g=c.return),l=c.return;while(l)}return c.tag===3?g:null}function hf(l){if(l.tag===13){var c=l.memoizedState;if(c===null&&(l=l.alternate,l!==null&&(c=l.memoizedState)),c!==null)return c.dehydrated}return null}function W(l){if(Ys(l)!==l)throw Error(t(188))}function ge(l){var c=l.alternate;if(!c){if(c=Ys(l),c===null)throw Error(t(188));return c!==l?null:l}for(var g=l,x=c;;){var M=g.return;if(M===null)break;var R=M.alternate;if(R===null){if(x=M.return,x!==null){g=x;continue}break}if(M.child===R.child){for(R=M.child;R;){if(R===g)return W(M),l;if(R===x)return W(M),c;R=R.sibling}throw Error(t(188))}if(g.return!==x.return)g=M,x=R;else{for(var B=!1,te=M.child;te;){if(te===g){B=!0,g=M,x=R;break}if(te===x){B=!0,x=M,g=R;break}te=te.sibling}if(!B){for(te=R.child;te;){if(te===g){B=!0,g=R,x=M;break}if(te===x){B=!0,x=R,g=M;break}te=te.sibling}if(!B)throw Error(t(189))}}if(g.alternate!==x)throw Error(t(190))}if(g.tag!==3)throw Error(t(188));return g.stateNode.current===g?l:c}function Ee(l){return l=ge(l),l!==null?Te(l):null}function Te(l){if(l.tag===5||l.tag===6)return l;for(l=l.child;l!==null;){var c=Te(l);if(c!==null)return c;l=l.sibling}return null}var Me=e.unstable_scheduleCallback,ft=e.unstable_cancelCallback,Rt=e.unstable_shouldYield,Dt=e.unstable_requestPaint,ht=e.unstable_now,Wt=e.unstable_getCurrentPriorityLevel,Bt=e.unstable_ImmediatePriority,$t=e.unstable_UserBlockingPriority,In=e.unstable_NormalPriority,kr=e.unstable_LowPriority,Pn=e.unstable_IdlePriority,sr=null,It=null;function xt(l){if(It&&typeof It.onCommitFiberRoot=="function")try{It.onCommitFiberRoot(sr,l,void 0,(l.current.flags&128)===128)}catch{}}var Jn=Math.clz32?Math.clz32:Ls,on=Math.log,Qn=Math.LN2;function Ls(l){return l>>>=0,l===0?32:31-(on(l)/Qn|0)|0}var ni=64,ar=4194304;function Gn(l){switch(l&-l){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return l&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return l&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return l}}function Pi(l,c){var g=l.pendingLanes;if(g===0)return 0;var x=0,M=l.suspendedLanes,R=l.pingedLanes,B=g&268435455;if(B!==0){var te=B&~M;te!==0?x=Gn(te):(R&=B,R!==0&&(x=Gn(R)))}else B=g&~M,B!==0?x=Gn(B):R!==0&&(x=Gn(R));if(x===0)return 0;if(c!==0&&c!==x&&(c&M)===0&&(M=x&-x,R=c&-c,M>=R||M===16&&(R&4194240)!==0))return c;if((x&4)!==0&&(x|=g&16),c=l.entangledLanes,c!==0)for(l=l.entanglements,c&=x;0<c;)g=31-Jn(c),M=1<<g,x|=l[g],c&=~M;return x}function ml(l,c){switch(l){case 1:case 2:case 4:return c+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return c+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function Mr(l,c){for(var g=l.suspendedLanes,x=l.pingedLanes,M=l.expirationTimes,R=l.pendingLanes;0<R;){var B=31-Jn(R),te=1<<B,oe=M[B];oe===-1?((te&g)===0||(te&x)!==0)&&(M[B]=ml(te,c)):oe<=c&&(l.expiredLanes|=te),R&=~te}}function Oa(l){return l=l.pendingLanes&-1073741825,l!==0?l:l&1073741824?1073741824:0}function pi(){var l=ni;return ni<<=1,(ni&4194240)===0&&(ni=64),l}function gl(l){for(var c=[],g=0;31>g;g++)c.push(l);return c}function Ru(l,c,g){l.pendingLanes|=c,c!==536870912&&(l.suspendedLanes=0,l.pingedLanes=0),l=l.eventTimes,c=31-Jn(c),l[c]=g}function dv(l,c){var g=l.pendingLanes&~c;l.pendingLanes=c,l.suspendedLanes=0,l.pingedLanes=0,l.expiredLanes&=c,l.mutableReadLanes&=c,l.entangledLanes&=c,c=l.entanglements;var x=l.eventTimes;for(l=l.expirationTimes;0<g;){var M=31-Jn(g),R=1<<M;c[M]=0,x[M]=-1,l[M]=-1,g&=~R}}function yl(l,c){var g=l.entangledLanes|=c;for(l=l.entanglements;g;){var x=31-Jn(g),M=1<<x;M&c|l[x]&c&&(l[x]|=c),g&=~M}}var mn=0;function vl(l){return l&=-l,1<l?4<l?(l&268435455)!==0?16:536870912:4:1}var Iu,md,$m,df,pf,ho=!1,mf=[],ks=null,en=null,Zs=null,po=new Map,_l=new Map,Fa=[],pv="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function yr(l,c){switch(l){case"focusin":case"focusout":ks=null;break;case"dragenter":case"dragleave":en=null;break;case"mouseover":case"mouseout":Zs=null;break;case"pointerover":case"pointerout":po.delete(c.pointerId);break;case"gotpointercapture":case"lostpointercapture":_l.delete(c.pointerId)}}function mo(l,c,g,x,M,R){return l===null||l.nativeEvent!==R?(l={blockedOn:c,domEventName:g,eventSystemFlags:x,nativeEvent:R,targetContainers:[M]},c!==null&&(c=sa(c),c!==null&&md(c)),l):(l.eventSystemFlags|=x,c=l.targetContainers,M!==null&&c.indexOf(M)===-1&&c.push(M),l)}function mv(l,c,g,x,M){switch(c){case"focusin":return ks=mo(ks,l,c,g,x,M),!0;case"dragenter":return en=mo(en,l,c,g,x,M),!0;case"mouseover":return Zs=mo(Zs,l,c,g,x,M),!0;case"pointerover":var R=M.pointerId;return po.set(R,mo(po.get(R)||null,l,c,g,x,M)),!0;case"gotpointercapture":return R=M.pointerId,_l.set(R,mo(_l.get(R)||null,l,c,g,x,M)),!0}return!1}function gf(l){var c=Ga(l.target);if(c!==null){var g=Ys(c);if(g!==null){if(c=g.tag,c===13){if(c=hf(g),c!==null){l.blockedOn=c,pf(l.priority,function(){$m(g)});return}}else if(c===3&&g.stateNode.current.memoizedState.isDehydrated){l.blockedOn=g.tag===3?g.stateNode.containerInfo:null;return}}}l.blockedOn=null}function yf(l){if(l.blockedOn!==null)return!1;for(var c=l.targetContainers;0<c.length;){var g=Ki(l.domEventName,l.eventSystemFlags,c[0],l.nativeEvent);if(g===null){g=l.nativeEvent;var x=new g.constructor(g.type,g);ze=x,g.target.dispatchEvent(x),ze=null}else return c=sa(g),c!==null&&md(c),l.blockedOn=g,!1;c.shift()}return!0}function Pu(l,c,g){yf(l)&&g.delete(c)}function Ds(){ho=!1,ks!==null&&yf(ks)&&(ks=null),en!==null&&yf(en)&&(en=null),Zs!==null&&yf(Zs)&&(Zs=null),po.forEach(Pu),_l.forEach(Pu)}function Lu(l,c){l.blockedOn===c&&(l.blockedOn=null,ho||(ho=!0,e.unstable_scheduleCallback(e.unstable_NormalPriority,Ds)))}function ku(l){function c(M){return Lu(M,l)}if(0<mf.length){Lu(mf[0],l);for(var g=1;g<mf.length;g++){var x=mf[g];x.blockedOn===l&&(x.blockedOn=null)}}for(ks!==null&&Lu(ks,l),en!==null&&Lu(en,l),Zs!==null&&Lu(Zs,l),po.forEach(c),_l.forEach(c),g=0;g<Fa.length;g++)x=Fa[g],x.blockedOn===l&&(x.blockedOn=null);for(;0<Fa.length&&(g=Fa[0],g.blockedOn===null);)gf(g),g.blockedOn===null&&Fa.shift()}var ri=I.ReactCurrentBatchConfig,Xi=!0;function vf(l,c,g,x){var M=mn,R=ri.transition;ri.transition=null;try{mn=1,_f(l,c,g,x)}finally{mn=M,ri.transition=R}}function gd(l,c,g,x){var M=mn,R=ri.transition;ri.transition=null;try{mn=4,_f(l,c,g,x)}finally{mn=M,ri.transition=R}}function _f(l,c,g,x){if(Xi){var M=Ki(l,c,g,x);if(M===null)zf(l,c,x,xf,g),yr(l,x);else if(mv(M,l,c,g,x))x.stopPropagation();else if(yr(l,x),c&4&&-1<pv.indexOf(l)){for(;M!==null;){var R=sa(M);if(R!==null&&Iu(R),R=Ki(l,c,g,x),R===null&&zf(l,c,x,xf,g),R===M)break;M=R}M!==null&&x.stopPropagation()}else zf(l,c,x,null,g)}}var xf=null;function Ki(l,c,g,x){if(xf=null,l=Fe(x),l=Ga(l),l!==null)if(c=Ys(l),c===null)l=null;else if(g=c.tag,g===13){if(l=hf(c),l!==null)return l;l=null}else if(g===3){if(c.stateNode.current.memoizedState.isDehydrated)return c.tag===3?c.stateNode.containerInfo:null;l=null}else c!==l&&(l=null);return xf=l,null}function Gm(l){switch(l){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Wt()){case Bt:return 1;case $t:return 4;case In:case kr:return 16;case Pn:return 536870912;default:return 16}default:return 16}}var vs=null,yd=null,mi=null;function Du(){if(mi)return mi;var l,c=yd,g=c.length,x,M="value"in vs?vs.value:vs.textContent,R=M.length;for(l=0;l<g&&c[l]===M[l];l++);var B=g-l;for(x=1;x<=B&&c[g-x]===M[R-x];x++);return mi=M.slice(l,1<x?1-x:void 0)}function go(l){var c=l.keyCode;return"charCode"in l?(l=l.charCode,l===0&&c===13&&(l=13)):l=c,l===10&&(l=13),32<=l||l===13?l:0}function Js(){return!0}function Sf(){return!1}function ii(l){function c(g,x,M,R,B){this._reactName=g,this._targetInst=M,this.type=x,this.nativeEvent=R,this.target=B,this.currentTarget=null;for(var te in l)l.hasOwnProperty(te)&&(g=l[te],this[te]=g?g(R):R[te]);return this.isDefaultPrevented=(R.defaultPrevented!=null?R.defaultPrevented:R.returnValue===!1)?Js:Sf,this.isPropagationStopped=Sf,this}return ee(c.prototype,{preventDefault:function(){this.defaultPrevented=!0;var g=this.nativeEvent;g&&(g.preventDefault?g.preventDefault():typeof g.returnValue!="unknown"&&(g.returnValue=!1),this.isDefaultPrevented=Js)},stopPropagation:function(){var g=this.nativeEvent;g&&(g.stopPropagation?g.stopPropagation():typeof g.cancelBubble!="unknown"&&(g.cancelBubble=!0),this.isPropagationStopped=Js)},persist:function(){},isPersistent:Js}),c}var yo={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(l){return l.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Ou=ii(yo),vo=ee({},yo,{view:0,detail:0}),xl=ii(vo),gi,Yi,Zi,Sl=ee({},vo,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:za,button:0,buttons:0,relatedTarget:function(l){return l.relatedTarget===void 0?l.fromElement===l.srcElement?l.toElement:l.fromElement:l.relatedTarget},movementX:function(l){return"movementX"in l?l.movementX:(l!==Zi&&(Zi&&l.type==="mousemove"?(gi=l.screenX-Zi.screenX,Yi=l.screenY-Zi.screenY):Yi=gi=0,Zi=l),gi)},movementY:function(l){return"movementY"in l?l.movementY:Yi}}),vd=ii(Sl),Qs=ee({},Sl,{dataTransfer:0}),Ua=ii(Qs),wf=ee({},vo,{relatedTarget:0}),Ef=ii(wf),bf=ee({},yo,{animationName:0,elapsedTime:0,pseudoElement:0}),Wm=ii(bf),jm=ee({},yo,{clipboardData:function(l){return"clipboardData"in l?l.clipboardData:window.clipboardData}}),_d=ii(jm),Tf=ee({},yo,{data:0}),xd=ii(Tf),qm={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Xm={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Sd={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function wl(l){var c=this.nativeEvent;return c.getModifierState?c.getModifierState(l):(l=Sd[l])?!!c[l]:!1}function za(){return wl}var Mf=ee({},vo,{key:function(l){if(l.key){var c=qm[l.key]||l.key;if(c!=="Unidentified")return c}return l.type==="keypress"?(l=go(l),l===13?"Enter":String.fromCharCode(l)):l.type==="keydown"||l.type==="keyup"?Xm[l.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:za,charCode:function(l){return l.type==="keypress"?go(l):0},keyCode:function(l){return l.type==="keydown"||l.type==="keyup"?l.keyCode:0},which:function(l){return l.type==="keypress"?go(l):l.type==="keydown"||l.type==="keyup"?l.keyCode:0}}),Af=ii(Mf),Ji=ee({},Sl,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Li=ii(Ji),_o=ee({},vo,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:za}),ea=ii(_o),ta=ee({},yo,{propertyName:0,elapsedTime:0,pseudoElement:0}),xo=ii(ta),Km=ee({},Sl,{deltaX:function(l){return"deltaX"in l?l.deltaX:"wheelDeltaX"in l?-l.wheelDeltaX:0},deltaY:function(l){return"deltaY"in l?l.deltaY:"wheelDeltaY"in l?-l.wheelDeltaY:"wheelDelta"in l?-l.wheelDelta:0},deltaZ:0,deltaMode:0}),wd=ii(Km),Ed=[9,13,27,32],si=o&&"CompositionEvent"in window,Dr=null;o&&"documentMode"in document&&(Dr=document.documentMode);var Wn=o&&"TextEvent"in window&&!Dr,El=o&&(!si||Dr&&8<Dr&&11>=Dr),Qi=" ",bd=!1;function Td(l,c){switch(l){case"keyup":return Ed.indexOf(c.keyCode)!==-1;case"keydown":return c.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Nf(l){return l=l.detail,typeof l=="object"&&"data"in l?l.data:null}var Ba=!1;function Ym(l,c){switch(l){case"compositionend":return Nf(c);case"keypress":return c.which!==32?null:(bd=!0,Qi);case"textInput":return l=c.data,l===Qi&&bd?null:l;default:return null}}function Fu(l,c){if(Ba)return l==="compositionend"||!si&&Td(l,c)?(l=Du(),mi=yd=vs=null,Ba=!1,l):null;switch(l){case"paste":return null;case"keypress":if(!(c.ctrlKey||c.altKey||c.metaKey)||c.ctrlKey&&c.altKey){if(c.char&&1<c.char.length)return c.char;if(c.which)return String.fromCharCode(c.which)}return null;case"compositionend":return El&&c.locale!=="ko"?null:c.data;default:return null}}var bl={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Cf(l){var c=l&&l.nodeName&&l.nodeName.toLowerCase();return c==="input"?!!bl[l.type]:c==="textarea"}function Tl(l,c,g,x){Re(x),c=Bf(c,"onChange"),0<c.length&&(g=new Ou("onChange","change",null,g,x),l.push({event:g,listeners:c}))}var Va=null,Ml=null;function Zm(l){Rl(l,0)}function na(l){var c=or(l);if(se(c))return l}function Jm(l,c){if(l==="change")return c}var Al=!1;if(o){var yi;if(o){var So="oninput"in document;if(!So){var wo=document.createElement("div");wo.setAttribute("oninput","return;"),So=typeof wo.oninput=="function"}yi=So}else yi=!1;Al=yi&&(!document.documentMode||9<document.documentMode)}function _s(){Va&&(Va.detachEvent("onpropertychange",Rf),Ml=Va=null)}function Rf(l){if(l.propertyName==="value"&&na(Ml)){var c=[];Tl(c,Ml,l,Fe(l)),Zn(Zm,c)}}function Nl(l,c,g){l==="focusin"?(_s(),Va=c,Ml=g,Va.attachEvent("onpropertychange",Rf)):l==="focusout"&&_s()}function Qm(l){if(l==="selectionchange"||l==="keyup"||l==="keydown")return na(Ml)}function Md(l,c){if(l==="click")return na(c)}function Xn(l,c){if(l==="input"||l==="change")return na(c)}function If(l,c){return l===c&&(l!==0||1/l===1/c)||l!==l&&c!==c}var ki=typeof Object.is=="function"?Object.is:If;function Eo(l,c){if(ki(l,c))return!0;if(typeof l!="object"||l===null||typeof c!="object"||c===null)return!1;var g=Object.keys(l),x=Object.keys(c);if(g.length!==x.length)return!1;for(x=0;x<g.length;x++){var M=g[x];if(!u.call(c,M)||!ki(l[M],c[M]))return!1}return!0}function Uu(l){for(;l&&l.firstChild;)l=l.firstChild;return l}function Di(l,c){var g=Uu(l);l=0;for(var x;g;){if(g.nodeType===3){if(x=l+g.textContent.length,l<=c&&x>=c)return{node:g,offset:c-l};l=x}e:{for(;g;){if(g.nextSibling){g=g.nextSibling;break e}g=g.parentNode}g=void 0}g=Uu(g)}}function bo(l,c){return l&&c?l===c?!0:l&&l.nodeType===3?!1:c&&c.nodeType===3?bo(l,c.parentNode):"contains"in l?l.contains(c):l.compareDocumentPosition?!!(l.compareDocumentPosition(c)&16):!1:!1}function Kn(){for(var l=window,c=Ve();c instanceof l.HTMLIFrameElement;){try{var g=typeof c.contentWindow.location.href=="string"}catch{g=!1}if(g)l=c.contentWindow;else break;c=Ve(l.document)}return c}function Ar(l){var c=l&&l.nodeName&&l.nodeName.toLowerCase();return c&&(c==="input"&&(l.type==="text"||l.type==="search"||l.type==="tel"||l.type==="url"||l.type==="password")||c==="textarea"||l.contentEditable==="true")}function Nr(l){var c=Kn(),g=l.focusedElem,x=l.selectionRange;if(c!==g&&g&&g.ownerDocument&&bo(g.ownerDocument.documentElement,g)){if(x!==null&&Ar(g)){if(c=x.start,l=x.end,l===void 0&&(l=c),"selectionStart"in g)g.selectionStart=c,g.selectionEnd=Math.min(l,g.value.length);else if(l=(c=g.ownerDocument||document)&&c.defaultView||window,l.getSelection){l=l.getSelection();var M=g.textContent.length,R=Math.min(x.start,M);x=x.end===void 0?R:Math.min(x.end,M),!l.extend&&R>x&&(M=x,x=R,R=M),M=Di(g,R);var B=Di(g,x);M&&B&&(l.rangeCount!==1||l.anchorNode!==M.node||l.anchorOffset!==M.offset||l.focusNode!==B.node||l.focusOffset!==B.offset)&&(c=c.createRange(),c.setStart(M.node,M.offset),l.removeAllRanges(),R>x?(l.addRange(c),l.extend(B.node,B.offset)):(c.setEnd(B.node,B.offset),l.addRange(c)))}}for(c=[],l=g;l=l.parentNode;)l.nodeType===1&&c.push({element:l,left:l.scrollLeft,top:l.scrollTop});for(typeof g.focus=="function"&&g.focus(),g=0;g<c.length;g++)l=c[g],l.element.scrollLeft=l.left,l.element.scrollTop=l.top}}var Pf=o&&"documentMode"in document&&11>=document.documentMode,Os=null,To=null,zu=null,Cr=!1;function Lf(l,c,g){var x=g.window===g?g.document:g.nodeType===9?g:g.ownerDocument;Cr||Os==null||Os!==Ve(x)||(x=Os,"selectionStart"in x&&Ar(x)?x={start:x.selectionStart,end:x.selectionEnd}:(x=(x.ownerDocument&&x.ownerDocument.defaultView||window).getSelection(),x={anchorNode:x.anchorNode,anchorOffset:x.anchorOffset,focusNode:x.focusNode,focusOffset:x.focusOffset}),zu&&Eo(zu,x)||(zu=x,x=Bf(To,"onSelect"),0<x.length&&(c=new Ou("onSelect","select",null,c,g),l.push({event:c,listeners:x}),c.target=Os)))}function Cl(l,c){var g={};return g[l.toLowerCase()]=c.toLowerCase(),g["Webkit"+l]="webkit"+c,g["Moz"+l]="moz"+c,g}var Ha={animationend:Cl("Animation","AnimationEnd"),animationiteration:Cl("Animation","AnimationIteration"),animationstart:Cl("Animation","AnimationStart"),transitionend:Cl("Transition","TransitionEnd")},xs={},Ss={};o&&(Ss=document.createElement("div").style,"AnimationEvent"in window||(delete Ha.animationend.animation,delete Ha.animationiteration.animation,delete Ha.animationstart.animation),"TransitionEvent"in window||delete Ha.transitionend.transition);function Fs(l){if(xs[l])return xs[l];if(!Ha[l])return l;var c=Ha[l],g;for(g in c)if(c.hasOwnProperty(g)&&g in Ss)return xs[l]=c[g];return l}var Bu=Fs("animationend"),Vu=Fs("animationiteration"),Ad=Fs("animationstart"),Nd=Fs("transitionend"),Cd=new Map,Rd="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function ra(l,c){Cd.set(l,c),s(c,[l])}for(var kf=0;kf<Rd.length;kf++){var Hu=Rd[kf],$u=Hu.toLowerCase(),eg=Hu[0].toUpperCase()+Hu.slice(1);ra($u,"on"+eg)}ra(Bu,"onAnimationEnd"),ra(Vu,"onAnimationIteration"),ra(Ad,"onAnimationStart"),ra("dblclick","onDoubleClick"),ra("focusin","onFocus"),ra("focusout","onBlur"),ra(Nd,"onTransitionEnd"),a("onMouseEnter",["mouseout","mouseover"]),a("onMouseLeave",["mouseout","mouseover"]),a("onPointerEnter",["pointerout","pointerover"]),a("onPointerLeave",["pointerout","pointerover"]),s("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),s("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),s("onBeforeInput",["compositionend","keypress","textInput","paste"]),s("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),s("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),s("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var $a="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Df=new Set("cancel close invalid load scroll toggle".split(" ").concat($a));function Of(l,c,g){var x=l.type||"unknown-event";l.currentTarget=g,pd(x,c,void 0,l),l.currentTarget=null}function Rl(l,c){c=(c&4)!==0;for(var g=0;g<l.length;g++){var x=l[g],M=x.event;x=x.listeners;e:{var R=void 0;if(c)for(var B=x.length-1;0<=B;B--){var te=x[B],oe=te.instance,we=te.currentTarget;if(te=te.listener,oe!==R&&M.isPropagationStopped())break e;Of(M,te,we),R=oe}else for(B=0;B<x.length;B++){if(te=x[B],oe=te.instance,we=te.currentTarget,te=te.listener,oe!==R&&M.isPropagationStopped())break e;Of(M,te,we),R=oe}}}if(ys)throw l=Da,ys=!1,Da=null,l}function Ln(l,c){var g=c[No];g===void 0&&(g=c[No]=new Set);var x=l+"__bubble";g.has(x)||(Uf(c,l,2,!1),g.add(x))}function Ff(l,c,g){var x=0;c&&(x|=4),Uf(g,l,x,c)}var Gu="_reactListening"+Math.random().toString(36).slice(2);function Il(l){if(!l[Gu]){l[Gu]=!0,n.forEach(function(g){g!=="selectionchange"&&(Df.has(g)||Ff(g,!1,l),Ff(g,!0,l))});var c=l.nodeType===9?l:l.ownerDocument;c===null||c[Gu]||(c[Gu]=!0,Ff("selectionchange",!1,c))}}function Uf(l,c,g,x){switch(Gm(c)){case 1:var M=vf;break;case 4:M=gd;break;default:M=_f}g=M.bind(null,c,g,l),M=void 0,!gr||c!=="touchstart"&&c!=="touchmove"&&c!=="wheel"||(M=!0),x?M!==void 0?l.addEventListener(c,g,{capture:!0,passive:M}):l.addEventListener(c,g,!0):M!==void 0?l.addEventListener(c,g,{passive:M}):l.addEventListener(c,g,!1)}function zf(l,c,g,x,M){var R=x;if((c&1)===0&&(c&2)===0&&x!==null)e:for(;;){if(x===null)return;var B=x.tag;if(B===3||B===4){var te=x.stateNode.containerInfo;if(te===M||te.nodeType===8&&te.parentNode===M)break;if(B===4)for(B=x.return;B!==null;){var oe=B.tag;if((oe===3||oe===4)&&(oe=B.stateNode.containerInfo,oe===M||oe.nodeType===8&&oe.parentNode===M))return;B=B.return}for(;te!==null;){if(B=Ga(te),B===null)return;if(oe=B.tag,oe===5||oe===6){x=R=B;continue e}te=te.parentNode}}x=x.return}Zn(function(){var we=R,Be=Fe(g),Ge=[];e:{var Ue=Cd.get(l);if(Ue!==void 0){var pt=Ou,wt=l;switch(l){case"keypress":if(go(g)===0)break e;case"keydown":case"keyup":pt=Af;break;case"focusin":wt="focus",pt=Ef;break;case"focusout":wt="blur",pt=Ef;break;case"beforeblur":case"afterblur":pt=Ef;break;case"click":if(g.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":pt=vd;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":pt=Ua;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":pt=ea;break;case Bu:case Vu:case Ad:pt=Wm;break;case Nd:pt=xo;break;case"scroll":pt=xl;break;case"wheel":pt=wd;break;case"copy":case"cut":case"paste":pt=_d;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":pt=Li}var Tt=(c&4)!==0,_r=!Tt&&l==="scroll",ye=Tt?Ue!==null?Ue+"Capture":null:Ue;Tt=[];for(var fe=we,_e;fe!==null;){_e=fe;var Je=_e.stateNode;if(_e.tag===5&&Je!==null&&(_e=Je,ye!==null&&(Je=an(fe,ye),Je!=null&&Tt.push(Pl(fe,Je,_e)))),_r)break;fe=fe.return}0<Tt.length&&(Ue=new pt(Ue,wt,null,g,Be),Ge.push({event:Ue,listeners:Tt}))}}if((c&7)===0){e:{if(Ue=l==="mouseover"||l==="pointerover",pt=l==="mouseout"||l==="pointerout",Ue&&g!==ze&&(wt=g.relatedTarget||g.fromElement)&&(Ga(wt)||wt[Oi]))break e;if((pt||Ue)&&(Ue=Be.window===Be?Be:(Ue=Be.ownerDocument)?Ue.defaultView||Ue.parentWindow:window,pt?(wt=g.relatedTarget||g.toElement,pt=we,wt=wt?Ga(wt):null,wt!==null&&(_r=Ys(wt),wt!==_r||wt.tag!==5&&wt.tag!==6)&&(wt=null)):(pt=null,wt=we),pt!==wt)){if(Tt=vd,Je="onMouseLeave",ye="onMouseEnter",fe="mouse",(l==="pointerout"||l==="pointerover")&&(Tt=Li,Je="onPointerLeave",ye="onPointerEnter",fe="pointer"),_r=pt==null?Ue:or(pt),_e=wt==null?Ue:or(wt),Ue=new Tt(Je,fe+"leave",pt,g,Be),Ue.target=_r,Ue.relatedTarget=_e,Je=null,Ga(Be)===we&&(Tt=new Tt(ye,fe+"enter",wt,g,Be),Tt.target=_e,Tt.relatedTarget=_r,Je=Tt),_r=Je,pt&&wt)t:{for(Tt=pt,ye=wt,fe=0,_e=Tt;_e;_e=Mo(_e))fe++;for(_e=0,Je=ye;Je;Je=Mo(Je))_e++;for(;0<fe-_e;)Tt=Mo(Tt),fe--;for(;0<_e-fe;)ye=Mo(ye),_e--;for(;fe--;){if(Tt===ye||ye!==null&&Tt===ye.alternate)break t;Tt=Mo(Tt),ye=Mo(ye)}Tt=null}else Tt=null;pt!==null&&tg(Ge,Ue,pt,Tt,!1),wt!==null&&_r!==null&&tg(Ge,_r,wt,Tt,!0)}}e:{if(Ue=we?or(we):window,pt=Ue.nodeName&&Ue.nodeName.toLowerCase(),pt==="select"||pt==="input"&&Ue.type==="file")var Nt=Jm;else if(Cf(Ue))if(Al)Nt=Xn;else{Nt=Qm;var Ot=Nl}else(pt=Ue.nodeName)&&pt.toLowerCase()==="input"&&(Ue.type==="checkbox"||Ue.type==="radio")&&(Nt=Md);if(Nt&&(Nt=Nt(l,we))){Tl(Ge,Nt,g,Be);break e}Ot&&Ot(l,Ue,we),l==="focusout"&&(Ot=Ue._wrapperState)&&Ot.controlled&&Ue.type==="number"&&dt(Ue,"number",Ue.value)}switch(Ot=we?or(we):window,l){case"focusin":(Cf(Ot)||Ot.contentEditable==="true")&&(Os=Ot,To=we,zu=null);break;case"focusout":zu=To=Os=null;break;case"mousedown":Cr=!0;break;case"contextmenu":case"mouseup":case"dragend":Cr=!1,Lf(Ge,g,Be);break;case"selectionchange":if(Pf)break;case"keydown":case"keyup":Lf(Ge,g,Be)}var Ft;if(si)e:{switch(l){case"compositionstart":var jt="onCompositionStart";break e;case"compositionend":jt="onCompositionEnd";break e;case"compositionupdate":jt="onCompositionUpdate";break e}jt=void 0}else Ba?Td(l,g)&&(jt="onCompositionEnd"):l==="keydown"&&g.keyCode===229&&(jt="onCompositionStart");jt&&(El&&g.locale!=="ko"&&(Ba||jt!=="onCompositionStart"?jt==="onCompositionEnd"&&Ba&&(Ft=Du()):(vs=Be,yd="value"in vs?vs.value:vs.textContent,Ba=!0)),Ot=Bf(we,jt),0<Ot.length&&(jt=new xd(jt,l,null,g,Be),Ge.push({event:jt,listeners:Ot}),Ft?jt.data=Ft:(Ft=Nf(g),Ft!==null&&(jt.data=Ft)))),(Ft=Wn?Ym(l,g):Fu(l,g))&&(we=Bf(we,"onBeforeInput"),0<we.length&&(Be=new xd("onBeforeInput","beforeinput",null,g,Be),Ge.push({event:Be,listeners:we}),Be.data=Ft))}Rl(Ge,c)})}function Pl(l,c,g){return{instance:l,listener:c,currentTarget:g}}function Bf(l,c){for(var g=c+"Capture",x=[];l!==null;){var M=l,R=M.stateNode;M.tag===5&&R!==null&&(M=R,R=an(l,g),R!=null&&x.unshift(Pl(l,R,M)),R=an(l,c),R!=null&&x.push(Pl(l,R,M))),l=l.return}return x}function Mo(l){if(l===null)return null;do l=l.return;while(l&&l.tag!==5);return l||null}function tg(l,c,g,x,M){for(var R=c._reactName,B=[];g!==null&&g!==x;){var te=g,oe=te.alternate,we=te.stateNode;if(oe!==null&&oe===x)break;te.tag===5&&we!==null&&(te=we,M?(oe=an(g,R),oe!=null&&B.unshift(Pl(g,oe,te))):M||(oe=an(g,R),oe!=null&&B.push(Pl(g,oe,te)))),g=g.return}B.length!==0&&l.push({event:c,listeners:B})}var gv=/\r\n?/g,ng=/\u0000|\uFFFD/g;function Id(l){return(typeof l=="string"?l:""+l).replace(gv,`
`).replace(ng,"")}function Wu(l,c,g){if(c=Id(c),Id(l)!==c&&g)throw Error(t(425))}function ju(){}var Ll=null,Pd=null;function Ld(l,c){return l==="textarea"||l==="noscript"||typeof c.children=="string"||typeof c.children=="number"||typeof c.dangerouslySetInnerHTML=="object"&&c.dangerouslySetInnerHTML!==null&&c.dangerouslySetInnerHTML.__html!=null}var kd=typeof setTimeout=="function"?setTimeout:void 0,Dd=typeof clearTimeout=="function"?clearTimeout:void 0,Vf=typeof Promise=="function"?Promise:void 0,yv=typeof queueMicrotask=="function"?queueMicrotask:typeof Vf<"u"?function(l){return Vf.resolve(null).then(l).catch(rg)}:kd;function rg(l){setTimeout(function(){throw l})}function Hf(l,c){var g=c,x=0;do{var M=g.nextSibling;if(l.removeChild(g),M&&M.nodeType===8)if(g=M.data,g==="/$"){if(x===0){l.removeChild(M),ku(c);return}x--}else g!=="$"&&g!=="$?"&&g!=="$!"||x++;g=M}while(g);ku(c)}function ia(l){for(;l!=null;l=l.nextSibling){var c=l.nodeType;if(c===1||c===3)break;if(c===8){if(c=l.data,c==="$"||c==="$!"||c==="$?")break;if(c==="/$")return null}}return l}function Od(l){l=l.previousSibling;for(var c=0;l;){if(l.nodeType===8){var g=l.data;if(g==="$"||g==="$!"||g==="$?"){if(c===0)return l;c--}else g==="/$"&&c++}l=l.previousSibling}return null}var Ao=Math.random().toString(36).slice(2),vr="__reactFiber$"+Ao,kl="__reactProps$"+Ao,Oi="__reactContainer$"+Ao,No="__reactEvents$"+Ao,$f="__reactListeners$"+Ao,Gf="__reactHandles$"+Ao;function Ga(l){var c=l[vr];if(c)return c;for(var g=l.parentNode;g;){if(c=g[Oi]||g[vr]){if(g=c.alternate,c.child!==null||g!==null&&g.child!==null)for(l=Od(l);l!==null;){if(g=l[vr])return g;l=Od(l)}return c}l=g,g=l.parentNode}return null}function sa(l){return l=l[vr]||l[Oi],!l||l.tag!==5&&l.tag!==6&&l.tag!==13&&l.tag!==3?null:l}function or(l){if(l.tag===5||l.tag===6)return l.stateNode;throw Error(t(33))}function Wf(l){return l[kl]||null}var Fd=[],Rr=-1;function er(l){return{current:l}}function kn(l){0>Rr||(l.current=Fd[Rr],Fd[Rr]=null,Rr--)}function An(l,c){Rr++,Fd[Rr]=l.current,l.current=c}var aa={},Or=er(aa),ai=er(!1),oa=aa;function Co(l,c){var g=l.type.contextTypes;if(!g)return aa;var x=l.stateNode;if(x&&x.__reactInternalMemoizedUnmaskedChildContext===c)return x.__reactInternalMemoizedMaskedChildContext;var M={},R;for(R in g)M[R]=c[R];return x&&(l=l.stateNode,l.__reactInternalMemoizedUnmaskedChildContext=c,l.__reactInternalMemoizedMaskedChildContext=M),M}function Xr(l){return l=l.childContextTypes,l!=null}function qu(){kn(ai),kn(Or)}function Ud(l,c,g){if(Or.current!==aa)throw Error(t(168));An(Or,c),An(ai,g)}function Xu(l,c,g){var x=l.stateNode;if(c=c.childContextTypes,typeof x.getChildContext!="function")return g;x=x.getChildContext();for(var M in x)if(!(M in c))throw Error(t(108,tt(l)||"Unknown",M));return ee({},g,x)}function Ro(l){return l=(l=l.stateNode)&&l.__reactInternalMemoizedMergedChildContext||aa,oa=Or.current,An(Or,l),An(ai,ai.current),!0}function zd(l,c,g){var x=l.stateNode;if(!x)throw Error(t(169));g?(l=Xu(l,c,oa),x.__reactInternalMemoizedMergedChildContext=l,kn(ai),kn(Or),An(Or,l)):kn(ai),An(ai,g)}var ws=null,Ku=!1,jf=!1;function Yu(l){ws===null?ws=[l]:ws.push(l)}function ig(l){Ku=!0,Yu(l)}function Us(){if(!jf&&ws!==null){jf=!0;var l=0,c=mn;try{var g=ws;for(mn=1;l<g.length;l++){var x=g[l];do x=x(!0);while(x!==null)}ws=null,Ku=!1}catch(M){throw ws!==null&&(ws=ws.slice(l+1)),Me(Bt,Us),M}finally{mn=c,jf=!1}}return null}var Io=[],vi=0,qf=null,Xf=0,oi=[],Ir=0,Po=null,et=1,es="";function la(l,c){Io[vi++]=Xf,Io[vi++]=qf,qf=l,Xf=c}function Bd(l,c,g){oi[Ir++]=et,oi[Ir++]=es,oi[Ir++]=Po,Po=l;var x=et;l=es;var M=32-Jn(x)-1;x&=~(1<<M),g+=1;var R=32-Jn(c)+M;if(30<R){var B=M-M%5;R=(x&(1<<B)-1).toString(32),x>>=B,M-=B,et=1<<32-Jn(c)+M|g<<M|x,es=R+l}else et=1<<R|g<<M|x,es=l}function Vd(l){l.return!==null&&(la(l,1),Bd(l,1,0))}function ua(l){for(;l===qf;)qf=Io[--vi],Io[vi]=null,Xf=Io[--vi],Io[vi]=null;for(;l===Po;)Po=oi[--Ir],oi[Ir]=null,es=oi[--Ir],oi[Ir]=null,et=oi[--Ir],oi[Ir]=null}var Fr=null,li=null,Fn=!1,ts=null;function Hd(l,c){var g=$s(5,null,null,0);g.elementType="DELETED",g.stateNode=c,g.return=l,c=l.deletions,c===null?(l.deletions=[g],l.flags|=16):c.push(g)}function $d(l,c){switch(l.tag){case 5:var g=l.type;return c=c.nodeType!==1||g.toLowerCase()!==c.nodeName.toLowerCase()?null:c,c!==null?(l.stateNode=c,Fr=l,li=ia(c.firstChild),!0):!1;case 6:return c=l.pendingProps===""||c.nodeType!==3?null:c,c!==null?(l.stateNode=c,Fr=l,li=null,!0):!1;case 13:return c=c.nodeType!==8?null:c,c!==null?(g=Po!==null?{id:et,overflow:es}:null,l.memoizedState={dehydrated:c,treeContext:g,retryLane:1073741824},g=$s(18,null,null,0),g.stateNode=c,g.return=l,l.child=g,Fr=l,li=null,!0):!1;default:return!1}}function Kf(l){return(l.mode&1)!==0&&(l.flags&128)===0}function Yf(l){if(Fn){var c=li;if(c){var g=c;if(!$d(l,c)){if(Kf(l))throw Error(t(418));c=ia(g.nextSibling);var x=Fr;c&&$d(l,c)?Hd(x,g):(l.flags=l.flags&-4097|2,Fn=!1,Fr=l)}}else{if(Kf(l))throw Error(t(418));l.flags=l.flags&-4097|2,Fn=!1,Fr=l}}}function Zf(l){for(l=l.return;l!==null&&l.tag!==5&&l.tag!==3&&l.tag!==13;)l=l.return;Fr=l}function Dl(l){if(l!==Fr)return!1;if(!Fn)return Zf(l),Fn=!0,!1;var c;if((c=l.tag!==3)&&!(c=l.tag!==5)&&(c=l.type,c=c!=="head"&&c!=="body"&&!Ld(l.type,l.memoizedProps)),c&&(c=li)){if(Kf(l))throw Gd(),Error(t(418));for(;c;)Hd(l,c),c=ia(c.nextSibling)}if(Zf(l),l.tag===13){if(l=l.memoizedState,l=l!==null?l.dehydrated:null,!l)throw Error(t(317));e:{for(l=l.nextSibling,c=0;l;){if(l.nodeType===8){var g=l.data;if(g==="/$"){if(c===0){li=ia(l.nextSibling);break e}c--}else g!=="$"&&g!=="$!"&&g!=="$?"||c++}l=l.nextSibling}li=null}}else li=Fr?ia(l.stateNode.nextSibling):null;return!0}function Gd(){for(var l=li;l;)l=ia(l.nextSibling)}function Wa(){li=Fr=null,Fn=!1}function Ol(l){ts===null?ts=[l]:ts.push(l)}var vv=I.ReactCurrentBatchConfig;function Zu(l,c,g){if(l=g.ref,l!==null&&typeof l!="function"&&typeof l!="object"){if(g._owner){if(g=g._owner,g){if(g.tag!==1)throw Error(t(309));var x=g.stateNode}if(!x)throw Error(t(147,l));var M=x,R=""+l;return c!==null&&c.ref!==null&&typeof c.ref=="function"&&c.ref._stringRef===R?c.ref:(c=function(B){var te=M.refs;B===null?delete te[R]:te[R]=B},c._stringRef=R,c)}if(typeof l!="string")throw Error(t(284));if(!g._owner)throw Error(t(290,l))}return l}function Ju(l,c){throw l=Object.prototype.toString.call(c),Error(t(31,l==="[object Object]"?"object with keys {"+Object.keys(c).join(", ")+"}":l))}function Wd(l){var c=l._init;return c(l._payload)}function jd(l){function c(ye,fe){if(l){var _e=ye.deletions;_e===null?(ye.deletions=[fe],ye.flags|=16):_e.push(fe)}}function g(ye,fe){if(!l)return null;for(;fe!==null;)c(ye,fe),fe=fe.sibling;return null}function x(ye,fe){for(ye=new Map;fe!==null;)fe.key!==null?ye.set(fe.key,fe):ye.set(fe.index,fe),fe=fe.sibling;return ye}function M(ye,fe){return ye=ql(ye,fe),ye.index=0,ye.sibling=null,ye}function R(ye,fe,_e){return ye.index=_e,l?(_e=ye.alternate,_e!==null?(_e=_e.index,_e<fe?(ye.flags|=2,fe):_e):(ye.flags|=2,fe)):(ye.flags|=1048576,fe)}function B(ye){return l&&ye.alternate===null&&(ye.flags|=2),ye}function te(ye,fe,_e,Je){return fe===null||fe.tag!==6?(fe=Fv(_e,ye.mode,Je),fe.return=ye,fe):(fe=M(fe,_e),fe.return=ye,fe)}function oe(ye,fe,_e,Je){var Nt=_e.type;return Nt===V?Be(ye,fe,_e.props.children,Je,_e.key):fe!==null&&(fe.elementType===Nt||typeof Nt=="object"&&Nt!==null&&Nt.$$typeof===de&&Wd(Nt)===fe.type)?(Je=M(fe,_e.props),Je.ref=Zu(ye,fe,_e),Je.return=ye,Je):(Je=Ag(_e.type,_e.key,_e.props,null,ye.mode,Je),Je.ref=Zu(ye,fe,_e),Je.return=ye,Je)}function we(ye,fe,_e,Je){return fe===null||fe.tag!==4||fe.stateNode.containerInfo!==_e.containerInfo||fe.stateNode.implementation!==_e.implementation?(fe=Uv(_e,ye.mode,Je),fe.return=ye,fe):(fe=M(fe,_e.children||[]),fe.return=ye,fe)}function Be(ye,fe,_e,Je,Nt){return fe===null||fe.tag!==7?(fe=mc(_e,ye.mode,Je,Nt),fe.return=ye,fe):(fe=M(fe,_e),fe.return=ye,fe)}function Ge(ye,fe,_e){if(typeof fe=="string"&&fe!==""||typeof fe=="number")return fe=Fv(""+fe,ye.mode,_e),fe.return=ye,fe;if(typeof fe=="object"&&fe!==null){switch(fe.$$typeof){case F:return _e=Ag(fe.type,fe.key,fe.props,null,ye.mode,_e),_e.ref=Zu(ye,null,fe),_e.return=ye,_e;case U:return fe=Uv(fe,ye.mode,_e),fe.return=ye,fe;case de:var Je=fe._init;return Ge(ye,Je(fe._payload),_e)}if(Pt(fe)||re(fe))return fe=mc(fe,ye.mode,_e,null),fe.return=ye,fe;Ju(ye,fe)}return null}function Ue(ye,fe,_e,Je){var Nt=fe!==null?fe.key:null;if(typeof _e=="string"&&_e!==""||typeof _e=="number")return Nt!==null?null:te(ye,fe,""+_e,Je);if(typeof _e=="object"&&_e!==null){switch(_e.$$typeof){case F:return _e.key===Nt?oe(ye,fe,_e,Je):null;case U:return _e.key===Nt?we(ye,fe,_e,Je):null;case de:return Nt=_e._init,Ue(ye,fe,Nt(_e._payload),Je)}if(Pt(_e)||re(_e))return Nt!==null?null:Be(ye,fe,_e,Je,null);Ju(ye,_e)}return null}function pt(ye,fe,_e,Je,Nt){if(typeof Je=="string"&&Je!==""||typeof Je=="number")return ye=ye.get(_e)||null,te(fe,ye,""+Je,Nt);if(typeof Je=="object"&&Je!==null){switch(Je.$$typeof){case F:return ye=ye.get(Je.key===null?_e:Je.key)||null,oe(fe,ye,Je,Nt);case U:return ye=ye.get(Je.key===null?_e:Je.key)||null,we(fe,ye,Je,Nt);case de:var Ot=Je._init;return pt(ye,fe,_e,Ot(Je._payload),Nt)}if(Pt(Je)||re(Je))return ye=ye.get(_e)||null,Be(fe,ye,Je,Nt,null);Ju(fe,Je)}return null}function wt(ye,fe,_e,Je){for(var Nt=null,Ot=null,Ft=fe,jt=fe=0,Jr=null;Ft!==null&&jt<_e.length;jt++){Ft.index>jt?(Jr=Ft,Ft=null):Jr=Ft.sibling;var xn=Ue(ye,Ft,_e[jt],Je);if(xn===null){Ft===null&&(Ft=Jr);break}l&&Ft&&xn.alternate===null&&c(ye,Ft),fe=R(xn,fe,jt),Ot===null?Nt=xn:Ot.sibling=xn,Ot=xn,Ft=Jr}if(jt===_e.length)return g(ye,Ft),Fn&&la(ye,jt),Nt;if(Ft===null){for(;jt<_e.length;jt++)Ft=Ge(ye,_e[jt],Je),Ft!==null&&(fe=R(Ft,fe,jt),Ot===null?Nt=Ft:Ot.sibling=Ft,Ot=Ft);return Fn&&la(ye,jt),Nt}for(Ft=x(ye,Ft);jt<_e.length;jt++)Jr=pt(Ft,ye,jt,_e[jt],Je),Jr!==null&&(l&&Jr.alternate!==null&&Ft.delete(Jr.key===null?jt:Jr.key),fe=R(Jr,fe,jt),Ot===null?Nt=Jr:Ot.sibling=Jr,Ot=Jr);return l&&Ft.forEach(function(Xl){return c(ye,Xl)}),Fn&&la(ye,jt),Nt}function Tt(ye,fe,_e,Je){var Nt=re(_e);if(typeof Nt!="function")throw Error(t(150));if(_e=Nt.call(_e),_e==null)throw Error(t(151));for(var Ot=Nt=null,Ft=fe,jt=fe=0,Jr=null,xn=_e.next();Ft!==null&&!xn.done;jt++,xn=_e.next()){Ft.index>jt?(Jr=Ft,Ft=null):Jr=Ft.sibling;var Xl=Ue(ye,Ft,xn.value,Je);if(Xl===null){Ft===null&&(Ft=Jr);break}l&&Ft&&Xl.alternate===null&&c(ye,Ft),fe=R(Xl,fe,jt),Ot===null?Nt=Xl:Ot.sibling=Xl,Ot=Xl,Ft=Jr}if(xn.done)return g(ye,Ft),Fn&&la(ye,jt),Nt;if(Ft===null){for(;!xn.done;jt++,xn=_e.next())xn=Ge(ye,xn.value,Je),xn!==null&&(fe=R(xn,fe,jt),Ot===null?Nt=xn:Ot.sibling=xn,Ot=xn);return Fn&&la(ye,jt),Nt}for(Ft=x(ye,Ft);!xn.done;jt++,xn=_e.next())xn=pt(Ft,ye,jt,xn.value,Je),xn!==null&&(l&&xn.alternate!==null&&Ft.delete(xn.key===null?jt:xn.key),fe=R(xn,fe,jt),Ot===null?Nt=xn:Ot.sibling=xn,Ot=xn);return l&&Ft.forEach(function(dL){return c(ye,dL)}),Fn&&la(ye,jt),Nt}function _r(ye,fe,_e,Je){if(typeof _e=="object"&&_e!==null&&_e.type===V&&_e.key===null&&(_e=_e.props.children),typeof _e=="object"&&_e!==null){switch(_e.$$typeof){case F:e:{for(var Nt=_e.key,Ot=fe;Ot!==null;){if(Ot.key===Nt){if(Nt=_e.type,Nt===V){if(Ot.tag===7){g(ye,Ot.sibling),fe=M(Ot,_e.props.children),fe.return=ye,ye=fe;break e}}else if(Ot.elementType===Nt||typeof Nt=="object"&&Nt!==null&&Nt.$$typeof===de&&Wd(Nt)===Ot.type){g(ye,Ot.sibling),fe=M(Ot,_e.props),fe.ref=Zu(ye,Ot,_e),fe.return=ye,ye=fe;break e}g(ye,Ot);break}else c(ye,Ot);Ot=Ot.sibling}_e.type===V?(fe=mc(_e.props.children,ye.mode,Je,_e.key),fe.return=ye,ye=fe):(Je=Ag(_e.type,_e.key,_e.props,null,ye.mode,Je),Je.ref=Zu(ye,fe,_e),Je.return=ye,ye=Je)}return B(ye);case U:e:{for(Ot=_e.key;fe!==null;){if(fe.key===Ot)if(fe.tag===4&&fe.stateNode.containerInfo===_e.containerInfo&&fe.stateNode.implementation===_e.implementation){g(ye,fe.sibling),fe=M(fe,_e.children||[]),fe.return=ye,ye=fe;break e}else{g(ye,fe);break}else c(ye,fe);fe=fe.sibling}fe=Uv(_e,ye.mode,Je),fe.return=ye,ye=fe}return B(ye);case de:return Ot=_e._init,_r(ye,fe,Ot(_e._payload),Je)}if(Pt(_e))return wt(ye,fe,_e,Je);if(re(_e))return Tt(ye,fe,_e,Je);Ju(ye,_e)}return typeof _e=="string"&&_e!==""||typeof _e=="number"?(_e=""+_e,fe!==null&&fe.tag===6?(g(ye,fe.sibling),fe=M(fe,_e),fe.return=ye,ye=fe):(g(ye,fe),fe=Fv(_e,ye.mode,Je),fe.return=ye,ye=fe),B(ye)):g(ye,fe)}return _r}var Lo=jd(!0),Qu=jd(!1),ko=er(null),Do=null,ca=null,Fl=null;function Oo(){Fl=ca=Do=null}function ec(l){var c=ko.current;kn(ko),l._currentValue=c}function tc(l,c,g){for(;l!==null;){var x=l.alternate;if((l.childLanes&c)!==c?(l.childLanes|=c,x!==null&&(x.childLanes|=c)):x!==null&&(x.childLanes&c)!==c&&(x.childLanes|=c),l===g)break;l=l.return}}function ja(l,c){Do=l,Fl=ca=null,l=l.dependencies,l!==null&&l.firstContext!==null&&((l.lanes&c)!==0&&(Qt=!0),l.firstContext=null)}function Fi(l){var c=l._currentValue;if(Fl!==l)if(l={context:l,memoizedValue:c,next:null},ca===null){if(Do===null)throw Error(t(308));ca=l,Do.dependencies={lanes:0,firstContext:l}}else ca=ca.next=l;return c}var fa=null;function qd(l){fa===null?fa=[l]:fa.push(l)}function nc(l,c,g,x){var M=c.interleaved;return M===null?(g.next=g,qd(c)):(g.next=M.next,M.next=g),c.interleaved=g,Es(l,x)}function Es(l,c){l.lanes|=c;var g=l.alternate;for(g!==null&&(g.lanes|=c),g=l,l=l.return;l!==null;)l.childLanes|=c,g=l.alternate,g!==null&&(g.childLanes|=c),g=l,l=l.return;return g.tag===3?g.stateNode:null}var Tn=!1;function Zt(l){l.updateQueue={baseState:l.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function lr(l,c){l=l.updateQueue,c.updateQueue===l&&(c.updateQueue={baseState:l.baseState,firstBaseUpdate:l.firstBaseUpdate,lastBaseUpdate:l.lastBaseUpdate,shared:l.shared,effects:l.effects})}function Mn(l,c){return{eventTime:l,lane:c,tag:0,payload:null,callback:null,next:null}}function jn(l,c,g){var x=l.updateQueue;if(x===null)return null;if(x=x.shared,(vn&2)!==0){var M=x.pending;return M===null?c.next=c:(c.next=M.next,M.next=c),x.pending=c,Es(l,g)}return M=x.interleaved,M===null?(c.next=c,qd(x)):(c.next=M.next,M.next=c),x.interleaved=c,Es(l,g)}function Kr(l,c,g){if(c=c.updateQueue,c!==null&&(c=c.shared,(g&4194240)!==0)){var x=c.lanes;x&=l.pendingLanes,g|=x,c.lanes=g,yl(l,g)}}function Fo(l,c){var g=l.updateQueue,x=l.alternate;if(x!==null&&(x=x.updateQueue,g===x)){var M=null,R=null;if(g=g.firstBaseUpdate,g!==null){do{var B={eventTime:g.eventTime,lane:g.lane,tag:g.tag,payload:g.payload,callback:g.callback,next:null};R===null?M=R=B:R=R.next=B,g=g.next}while(g!==null);R===null?M=R=c:R=R.next=c}else M=R=c;g={baseState:x.baseState,firstBaseUpdate:M,lastBaseUpdate:R,shared:x.shared,effects:x.effects},l.updateQueue=g;return}l=g.lastBaseUpdate,l===null?g.firstBaseUpdate=c:l.next=c,g.lastBaseUpdate=c}function tr(l,c,g,x){var M=l.updateQueue;Tn=!1;var R=M.firstBaseUpdate,B=M.lastBaseUpdate,te=M.shared.pending;if(te!==null){M.shared.pending=null;var oe=te,we=oe.next;oe.next=null,B===null?R=we:B.next=we,B=oe;var Be=l.alternate;Be!==null&&(Be=Be.updateQueue,te=Be.lastBaseUpdate,te!==B&&(te===null?Be.firstBaseUpdate=we:te.next=we,Be.lastBaseUpdate=oe))}if(R!==null){var Ge=M.baseState;B=0,Be=we=oe=null,te=R;do{var Ue=te.lane,pt=te.eventTime;if((x&Ue)===Ue){Be!==null&&(Be=Be.next={eventTime:pt,lane:0,tag:te.tag,payload:te.payload,callback:te.callback,next:null});e:{var wt=l,Tt=te;switch(Ue=c,pt=g,Tt.tag){case 1:if(wt=Tt.payload,typeof wt=="function"){Ge=wt.call(pt,Ge,Ue);break e}Ge=wt;break e;case 3:wt.flags=wt.flags&-65537|128;case 0:if(wt=Tt.payload,Ue=typeof wt=="function"?wt.call(pt,Ge,Ue):wt,Ue==null)break e;Ge=ee({},Ge,Ue);break e;case 2:Tn=!0}}te.callback!==null&&te.lane!==0&&(l.flags|=64,Ue=M.effects,Ue===null?M.effects=[te]:Ue.push(te))}else pt={eventTime:pt,lane:Ue,tag:te.tag,payload:te.payload,callback:te.callback,next:null},Be===null?(we=Be=pt,oe=Ge):Be=Be.next=pt,B|=Ue;if(te=te.next,te===null){if(te=M.shared.pending,te===null)break;Ue=te,te=Ue.next,Ue.next=null,M.lastBaseUpdate=Ue,M.shared.pending=null}}while(!0);if(Be===null&&(oe=Ge),M.baseState=oe,M.firstBaseUpdate=we,M.lastBaseUpdate=Be,c=M.shared.interleaved,c!==null){M=c;do B|=M.lane,M=M.next;while(M!==c)}else R===null&&(M.shared.lanes=0);fc|=B,l.lanes=B,l.memoizedState=Ge}}function Ul(l,c,g){if(l=c.effects,c.effects=null,l!==null)for(c=0;c<l.length;c++){var x=l[c],M=x.callback;if(M!==null){if(x.callback=null,x=g,typeof M!="function")throw Error(t(191,M));M.call(x)}}}var zs={},Ui=er(zs),Uo=er(zs),ha=er(zs);function fr(l){if(l===zs)throw Error(t(174));return l}function rc(l,c){switch(An(ha,c),An(Uo,l),An(Ui,zs),l=c.nodeType,l){case 9:case 11:c=(c=c.documentElement)?c.namespaceURI:Oe(null,"");break;default:l=l===8?c.parentNode:c,c=l.namespaceURI||null,l=l.tagName,c=Oe(c,l)}kn(Ui),An(Ui,c)}function qa(){kn(Ui),kn(Uo),kn(ha)}function zo(l){fr(ha.current);var c=fr(Ui.current),g=Oe(c,l.type);c!==g&&(An(Uo,l),An(Ui,g))}function zl(l){Uo.current===l&&(kn(Ui),kn(Uo))}var Un=er(0);function bs(l){for(var c=l;c!==null;){if(c.tag===13){var g=c.memoizedState;if(g!==null&&(g=g.dehydrated,g===null||g.data==="$?"||g.data==="$!"))return c}else if(c.tag===19&&c.memoizedProps.revealOrder!==void 0){if((c.flags&128)!==0)return c}else if(c.child!==null){c.child.return=c,c=c.child;continue}if(c===l)break;for(;c.sibling===null;){if(c.return===null||c.return===l)return null;c=c.return}c.sibling.return=c.return,c=c.sibling}return null}var Bl=[];function Bs(){for(var l=0;l<Bl.length;l++)Bl[l]._workInProgressVersionPrimary=null;Bl.length=0}var Bo=I.ReactCurrentDispatcher,Vo=I.ReactCurrentBatchConfig,da=0,Dn=null,nr=null,gn=null,Ts=!1,Yr=!1,Xa=0,_i=0;function Ur(){throw Error(t(321))}function ic(l,c){if(c===null)return!1;for(var g=0;g<c.length&&g<l.length;g++)if(!ki(l[g],c[g]))return!1;return!0}function sc(l,c,g,x,M,R){if(da=R,Dn=c,c.memoizedState=null,c.updateQueue=null,c.lanes=0,Bo.current=l===null||l.memoizedState===null?fg:hg,l=g(x,M),Yr){R=0;do{if(Yr=!1,Xa=0,25<=R)throw Error(t(301));R+=1,gn=nr=null,c.updateQueue=null,Bo.current=dg,l=g(x,M)}while(Yr)}if(Bo.current=ih,c=nr!==null&&nr.next!==null,da=0,gn=nr=Dn=null,Ts=!1,c)throw Error(t(300));return l}function Xd(){var l=Xa!==0;return Xa=0,l}function zr(){var l={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return gn===null?Dn.memoizedState=gn=l:gn=gn.next=l,gn}function zi(){if(nr===null){var l=Dn.alternate;l=l!==null?l.memoizedState:null}else l=nr.next;var c=gn===null?Dn.memoizedState:gn.next;if(c!==null)gn=c,nr=l;else{if(l===null)throw Error(t(310));nr=l,l={memoizedState:nr.memoizedState,baseState:nr.baseState,baseQueue:nr.baseQueue,queue:nr.queue,next:null},gn===null?Dn.memoizedState=gn=l:gn=gn.next=l}return gn}function Vl(l,c){return typeof c=="function"?c(l):c}function ac(l){var c=zi(),g=c.queue;if(g===null)throw Error(t(311));g.lastRenderedReducer=l;var x=nr,M=x.baseQueue,R=g.pending;if(R!==null){if(M!==null){var B=M.next;M.next=R.next,R.next=B}x.baseQueue=M=R,g.pending=null}if(M!==null){R=M.next,x=x.baseState;var te=B=null,oe=null,we=R;do{var Be=we.lane;if((da&Be)===Be)oe!==null&&(oe=oe.next={lane:0,action:we.action,hasEagerState:we.hasEagerState,eagerState:we.eagerState,next:null}),x=we.hasEagerState?we.eagerState:l(x,we.action);else{var Ge={lane:Be,action:we.action,hasEagerState:we.hasEagerState,eagerState:we.eagerState,next:null};oe===null?(te=oe=Ge,B=x):oe=oe.next=Ge,Dn.lanes|=Be,fc|=Be}we=we.next}while(we!==null&&we!==R);oe===null?B=x:oe.next=te,ki(x,c.memoizedState)||(Qt=!0),c.memoizedState=x,c.baseState=B,c.baseQueue=oe,g.lastRenderedState=x}if(l=g.interleaved,l!==null){M=l;do R=M.lane,Dn.lanes|=R,fc|=R,M=M.next;while(M!==l)}else M===null&&(g.lanes=0);return[c.memoizedState,g.dispatch]}function pa(l){var c=zi(),g=c.queue;if(g===null)throw Error(t(311));g.lastRenderedReducer=l;var x=g.dispatch,M=g.pending,R=c.memoizedState;if(M!==null){g.pending=null;var B=M=M.next;do R=l(R,B.action),B=B.next;while(B!==M);ki(R,c.memoizedState)||(Qt=!0),c.memoizedState=R,c.baseQueue===null&&(c.baseState=R),g.lastRenderedState=R}return[R,x]}function Kd(){}function Yd(l,c){var g=Dn,x=zi(),M=c(),R=!ki(x.memoizedState,M);if(R&&(x.memoizedState=M,Qt=!0),x=x.queue,Qd(sg.bind(null,g,x,l),[l]),x.getSnapshot!==c||R||gn!==null&&gn.memoizedState.tag&1){if(g.flags|=2048,Ms(9,oc.bind(null,g,x,M,c),void 0,null),Zr===null)throw Error(t(349));(da&30)!==0||Jf(g,c,M)}return M}function Jf(l,c,g){l.flags|=16384,l={getSnapshot:c,value:g},c=Dn.updateQueue,c===null?(c={lastEffect:null,stores:null},Dn.updateQueue=c,c.stores=[l]):(g=c.stores,g===null?c.stores=[l]:g.push(l))}function oc(l,c,g,x){c.value=g,c.getSnapshot=x,ag(c)&&Zd(l)}function sg(l,c,g){return g(function(){ag(c)&&Zd(l)})}function ag(l){var c=l.getSnapshot;l=l.value;try{var g=c();return!ki(l,g)}catch{return!0}}function Zd(l){var c=Es(l,1);c!==null&&_a(c,l,1,-1)}function Jd(l){var c=zr();return typeof l=="function"&&(l=l()),c.memoizedState=c.baseState=l,l={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Vl,lastRenderedState:l},c.queue=l,l=l.dispatch=Ho.bind(null,Dn,l),[c.memoizedState,l]}function Ms(l,c,g,x){return l={tag:l,create:c,destroy:g,deps:x,next:null},c=Dn.updateQueue,c===null?(c={lastEffect:null,stores:null},Dn.updateQueue=c,c.lastEffect=l.next=l):(g=c.lastEffect,g===null?c.lastEffect=l.next=l:(x=g.next,g.next=l,l.next=x,c.lastEffect=l)),l}function og(){return zi().memoizedState}function Vs(l,c,g,x){var M=zr();Dn.flags|=l,M.memoizedState=Ms(1|c,g,void 0,x===void 0?null:x)}function lc(l,c,g,x){var M=zi();x=x===void 0?null:x;var R=void 0;if(nr!==null){var B=nr.memoizedState;if(R=B.destroy,x!==null&&ic(x,B.deps)){M.memoizedState=Ms(c,g,R,x);return}}Dn.flags|=l,M.memoizedState=Ms(1|c,g,R,x)}function ui(l,c){return Vs(8390656,8,l,c)}function Qd(l,c){return lc(2048,8,l,c)}function ep(l,c){return lc(4,2,l,c)}function lg(l,c){return lc(4,4,l,c)}function ug(l,c){if(typeof c=="function")return l=l(),c(l),function(){c(null)};if(c!=null)return l=l(),c.current=l,function(){c.current=null}}function tp(l,c,g){return g=g!=null?g.concat([l]):null,lc(4,4,ug.bind(null,c,l),g)}function Qf(){}function cg(l,c){var g=zi();c=c===void 0?null:c;var x=g.memoizedState;return x!==null&&c!==null&&ic(c,x[1])?x[0]:(g.memoizedState=[l,c],l)}function Bi(l,c){var g=zi();c=c===void 0?null:c;var x=g.memoizedState;return x!==null&&c!==null&&ic(c,x[1])?x[0]:(l=l(),g.memoizedState=[l,c],l)}function eh(l,c,g){return(da&21)===0?(l.baseState&&(l.baseState=!1,Qt=!0),l.memoizedState=g):(ki(g,c)||(g=pi(),Dn.lanes|=g,fc|=g,l.baseState=!0),c)}function _v(l,c){var g=mn;mn=g!==0&&4>g?g:4,l(!0);var x=Vo.transition;Vo.transition={};try{l(!1),c()}finally{mn=g,Vo.transition=x}}function ma(){return zi().memoizedState}function th(l,c,g){var x=Wl(l);if(g={lane:x,action:g,hasEagerState:!1,eagerState:null,next:null},uc(l))nh(c,g);else if(g=nc(l,c,g,x),g!==null){var M=Hi();_a(g,l,x,M),rh(g,c,x)}}function Ho(l,c,g){var x=Wl(l),M={lane:x,action:g,hasEagerState:!1,eagerState:null,next:null};if(uc(l))nh(c,M);else{var R=l.alternate;if(l.lanes===0&&(R===null||R.lanes===0)&&(R=c.lastRenderedReducer,R!==null))try{var B=c.lastRenderedState,te=R(B,g);if(M.hasEagerState=!0,M.eagerState=te,ki(te,B)){var oe=c.interleaved;oe===null?(M.next=M,qd(c)):(M.next=oe.next,oe.next=M),c.interleaved=M;return}}catch{}finally{}g=nc(l,c,M,x),g!==null&&(M=Hi(),_a(g,l,x,M),rh(g,c,x))}}function uc(l){var c=l.alternate;return l===Dn||c!==null&&c===Dn}function nh(l,c){Yr=Ts=!0;var g=l.pending;g===null?c.next=c:(c.next=g.next,g.next=c),l.pending=c}function rh(l,c,g){if((g&4194240)!==0){var x=c.lanes;x&=l.pendingLanes,g|=x,c.lanes=g,yl(l,g)}}var ih={readContext:Fi,useCallback:Ur,useContext:Ur,useEffect:Ur,useImperativeHandle:Ur,useInsertionEffect:Ur,useLayoutEffect:Ur,useMemo:Ur,useReducer:Ur,useRef:Ur,useState:Ur,useDebugValue:Ur,useDeferredValue:Ur,useTransition:Ur,useMutableSource:Ur,useSyncExternalStore:Ur,useId:Ur,unstable_isNewReconciler:!1},fg={readContext:Fi,useCallback:function(l,c){return zr().memoizedState=[l,c===void 0?null:c],l},useContext:Fi,useEffect:ui,useImperativeHandle:function(l,c,g){return g=g!=null?g.concat([l]):null,Vs(4194308,4,ug.bind(null,c,l),g)},useLayoutEffect:function(l,c){return Vs(4194308,4,l,c)},useInsertionEffect:function(l,c){return Vs(4,2,l,c)},useMemo:function(l,c){var g=zr();return c=c===void 0?null:c,l=l(),g.memoizedState=[l,c],l},useReducer:function(l,c,g){var x=zr();return c=g!==void 0?g(c):c,x.memoizedState=x.baseState=c,l={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:l,lastRenderedState:c},x.queue=l,l=l.dispatch=th.bind(null,Dn,l),[x.memoizedState,l]},useRef:function(l){var c=zr();return l={current:l},c.memoizedState=l},useState:Jd,useDebugValue:Qf,useDeferredValue:function(l){return zr().memoizedState=l},useTransition:function(){var l=Jd(!1),c=l[0];return l=_v.bind(null,l[1]),zr().memoizedState=l,[c,l]},useMutableSource:function(){},useSyncExternalStore:function(l,c,g){var x=Dn,M=zr();if(Fn){if(g===void 0)throw Error(t(407));g=g()}else{if(g=c(),Zr===null)throw Error(t(349));(da&30)!==0||Jf(x,c,g)}M.memoizedState=g;var R={value:g,getSnapshot:c};return M.queue=R,ui(sg.bind(null,x,R,l),[l]),x.flags|=2048,Ms(9,oc.bind(null,x,R,g,c),void 0,null),g},useId:function(){var l=zr(),c=Zr.identifierPrefix;if(Fn){var g=es,x=et;g=(x&~(1<<32-Jn(x)-1)).toString(32)+g,c=":"+c+"R"+g,g=Xa++,0<g&&(c+="H"+g.toString(32)),c+=":"}else g=_i++,c=":"+c+"r"+g.toString(32)+":";return l.memoizedState=c},unstable_isNewReconciler:!1},hg={readContext:Fi,useCallback:cg,useContext:Fi,useEffect:Qd,useImperativeHandle:tp,useInsertionEffect:ep,useLayoutEffect:lg,useMemo:Bi,useReducer:ac,useRef:og,useState:function(){return ac(Vl)},useDebugValue:Qf,useDeferredValue:function(l){var c=zi();return eh(c,nr.memoizedState,l)},useTransition:function(){var l=ac(Vl)[0],c=zi().memoizedState;return[l,c]},useMutableSource:Kd,useSyncExternalStore:Yd,useId:ma,unstable_isNewReconciler:!1},dg={readContext:Fi,useCallback:cg,useContext:Fi,useEffect:Qd,useImperativeHandle:tp,useInsertionEffect:ep,useLayoutEffect:lg,useMemo:Bi,useReducer:pa,useRef:og,useState:function(){return pa(Vl)},useDebugValue:Qf,useDeferredValue:function(l){var c=zi();return nr===null?c.memoizedState=l:eh(c,nr.memoizedState,l)},useTransition:function(){var l=pa(Vl)[0],c=zi().memoizedState;return[l,c]},useMutableSource:Kd,useSyncExternalStore:Yd,useId:ma,unstable_isNewReconciler:!1};function ns(l,c){if(l&&l.defaultProps){c=ee({},c),l=l.defaultProps;for(var g in l)c[g]===void 0&&(c[g]=l[g]);return c}return c}function cc(l,c,g,x){c=l.memoizedState,g=g(x,c),g=g==null?c:ee({},c,g),l.memoizedState=g,l.lanes===0&&(l.updateQueue.baseState=g)}var sh={isMounted:function(l){return(l=l._reactInternals)?Ys(l)===l:!1},enqueueSetState:function(l,c,g){l=l._reactInternals;var x=Hi(),M=Wl(l),R=Mn(x,M);R.payload=c,g!=null&&(R.callback=g),c=jn(l,R,M),c!==null&&(_a(c,l,M,x),Kr(c,l,M))},enqueueReplaceState:function(l,c,g){l=l._reactInternals;var x=Hi(),M=Wl(l),R=Mn(x,M);R.tag=1,R.payload=c,g!=null&&(R.callback=g),c=jn(l,R,M),c!==null&&(_a(c,l,M,x),Kr(c,l,M))},enqueueForceUpdate:function(l,c){l=l._reactInternals;var g=Hi(),x=Wl(l),M=Mn(g,x);M.tag=2,c!=null&&(M.callback=c),c=jn(l,M,x),c!==null&&(_a(c,l,x,g),Kr(c,l,x))}};function pg(l,c,g,x,M,R,B){return l=l.stateNode,typeof l.shouldComponentUpdate=="function"?l.shouldComponentUpdate(x,R,B):c.prototype&&c.prototype.isPureReactComponent?!Eo(g,x)||!Eo(M,R):!0}function f(l,c,g){var x=!1,M=aa,R=c.contextType;return typeof R=="object"&&R!==null?R=Fi(R):(M=Xr(c)?oa:Or.current,x=c.contextTypes,R=(x=x!=null)?Co(l,M):aa),c=new c(g,R),l.memoizedState=c.state!==null&&c.state!==void 0?c.state:null,c.updater=sh,l.stateNode=c,c._reactInternals=l,x&&(l=l.stateNode,l.__reactInternalMemoizedUnmaskedChildContext=M,l.__reactInternalMemoizedMaskedChildContext=R),c}function d(l,c,g,x){l=c.state,typeof c.componentWillReceiveProps=="function"&&c.componentWillReceiveProps(g,x),typeof c.UNSAFE_componentWillReceiveProps=="function"&&c.UNSAFE_componentWillReceiveProps(g,x),c.state!==l&&sh.enqueueReplaceState(c,c.state,null)}function _(l,c,g,x){var M=l.stateNode;M.props=g,M.state=l.memoizedState,M.refs={},Zt(l);var R=c.contextType;typeof R=="object"&&R!==null?M.context=Fi(R):(R=Xr(c)?oa:Or.current,M.context=Co(l,R)),M.state=l.memoizedState,R=c.getDerivedStateFromProps,typeof R=="function"&&(cc(l,c,R,g),M.state=l.memoizedState),typeof c.getDerivedStateFromProps=="function"||typeof M.getSnapshotBeforeUpdate=="function"||typeof M.UNSAFE_componentWillMount!="function"&&typeof M.componentWillMount!="function"||(c=M.state,typeof M.componentWillMount=="function"&&M.componentWillMount(),typeof M.UNSAFE_componentWillMount=="function"&&M.UNSAFE_componentWillMount(),c!==M.state&&sh.enqueueReplaceState(M,M.state,null),tr(l,g,M,x),M.state=l.memoizedState),typeof M.componentDidMount=="function"&&(l.flags|=4194308)}function b(l,c){try{var g="",x=c;do g+=ke(x),x=x.return;while(x);var M=g}catch(R){M=`
Error generating stack: `+R.message+`
`+R.stack}return{value:l,source:c,stack:M,digest:null}}function N(l,c,g){return{value:l,source:null,stack:g??null,digest:c??null}}function D(l,c){try{console.error(c.value)}catch(g){setTimeout(function(){throw g})}}var Y=typeof WeakMap=="function"?WeakMap:Map;function he(l,c,g){g=Mn(-1,g),g.tag=3,g.payload={element:null};var x=c.value;return g.callback=function(){Sg||(Sg=!0,Cv=x),D(l,c)},g}function Ae(l,c,g){g=Mn(-1,g),g.tag=3;var x=l.type.getDerivedStateFromError;if(typeof x=="function"){var M=c.value;g.payload=function(){return x(M)},g.callback=function(){D(l,c)}}var R=l.stateNode;return R!==null&&typeof R.componentDidCatch=="function"&&(g.callback=function(){D(l,c),typeof x!="function"&&($l===null?$l=new Set([this]):$l.add(this));var B=c.stack;this.componentDidCatch(c.value,{componentStack:B!==null?B:""})}),g}function Ye(l,c,g){var x=l.pingCache;if(x===null){x=l.pingCache=new Y;var M=new Set;x.set(c,M)}else M=x.get(c),M===void 0&&(M=new Set,x.set(c,M));M.has(g)||(M.add(g),l=nL.bind(null,l,c,g),c.then(l,l))}function mt(l){do{var c;if((c=l.tag===13)&&(c=l.memoizedState,c=c!==null?c.dehydrated!==null:!0),c)return l;l=l.return}while(l!==null);return null}function qt(l,c,g,x,M){return(l.mode&1)===0?(l===c?l.flags|=65536:(l.flags|=128,g.flags|=131072,g.flags&=-52805,g.tag===1&&(g.alternate===null?g.tag=17:(c=Mn(-1,1),c.tag=2,jn(g,c,1))),g.lanes|=1),l):(l.flags|=65536,l.lanes=M,l)}var Lt=I.ReactCurrentOwner,Qt=!1;function ct(l,c,g,x){c.child=l===null?Qu(c,null,g,x):Lo(c,l.child,g,x)}function Br(l,c,g,x,M){g=g.render;var R=c.ref;return ja(c,M),x=sc(l,c,g,x,R,M),g=Xd(),l!==null&&!Qt?(c.updateQueue=l.updateQueue,c.flags&=-2053,l.lanes&=~M,$o(l,c,M)):(Fn&&g&&Vd(c),c.flags|=1,ct(l,c,x,M),c.child)}function Vi(l,c,g,x,M){if(l===null){var R=g.type;return typeof R=="function"&&!Ov(R)&&R.defaultProps===void 0&&g.compare===null&&g.defaultProps===void 0?(c.tag=15,c.type=R,xe(l,c,R,x,M)):(l=Ag(g.type,null,x,c,c.mode,M),l.ref=c.ref,l.return=c,c.child=l)}if(R=l.child,(l.lanes&M)===0){var B=R.memoizedProps;if(g=g.compare,g=g!==null?g:Eo,g(B,x)&&l.ref===c.ref)return $o(l,c,M)}return c.flags|=1,l=ql(R,x),l.ref=c.ref,l.return=c,c.child=l}function xe(l,c,g,x,M){if(l!==null){var R=l.memoizedProps;if(Eo(R,x)&&l.ref===c.ref)if(Qt=!1,c.pendingProps=x=R,(l.lanes&M)!==0)(l.flags&131072)!==0&&(Qt=!0);else return c.lanes=l.lanes,$o(l,c,M)}return ot(l,c,g,x,M)}function pe(l,c,g){var x=c.pendingProps,M=x.children,R=l!==null?l.memoizedState:null;if(x.mode==="hidden")if((c.mode&1)===0)c.memoizedState={baseLanes:0,cachePool:null,transitions:null},An(oh,As),As|=g;else{if((g&1073741824)===0)return l=R!==null?R.baseLanes|g:g,c.lanes=c.childLanes=1073741824,c.memoizedState={baseLanes:l,cachePool:null,transitions:null},c.updateQueue=null,An(oh,As),As|=l,null;c.memoizedState={baseLanes:0,cachePool:null,transitions:null},x=R!==null?R.baseLanes:g,An(oh,As),As|=x}else R!==null?(x=R.baseLanes|g,c.memoizedState=null):x=g,An(oh,As),As|=x;return ct(l,c,M,g),c.child}function be(l,c){var g=c.ref;(l===null&&g!==null||l!==null&&l.ref!==g)&&(c.flags|=512,c.flags|=2097152)}function ot(l,c,g,x,M){var R=Xr(g)?oa:Or.current;return R=Co(c,R),ja(c,M),g=sc(l,c,g,x,R,M),x=Xd(),l!==null&&!Qt?(c.updateQueue=l.updateQueue,c.flags&=-2053,l.lanes&=~M,$o(l,c,M)):(Fn&&x&&Vd(c),c.flags|=1,ct(l,c,g,M),c.child)}function Mt(l,c,g,x,M){if(Xr(g)){var R=!0;Ro(c)}else R=!1;if(ja(c,M),c.stateNode===null)gg(l,c),f(c,g,x),_(c,g,x,M),x=!0;else if(l===null){var B=c.stateNode,te=c.memoizedProps;B.props=te;var oe=B.context,we=g.contextType;typeof we=="object"&&we!==null?we=Fi(we):(we=Xr(g)?oa:Or.current,we=Co(c,we));var Be=g.getDerivedStateFromProps,Ge=typeof Be=="function"||typeof B.getSnapshotBeforeUpdate=="function";Ge||typeof B.UNSAFE_componentWillReceiveProps!="function"&&typeof B.componentWillReceiveProps!="function"||(te!==x||oe!==we)&&d(c,B,x,we),Tn=!1;var Ue=c.memoizedState;B.state=Ue,tr(c,x,B,M),oe=c.memoizedState,te!==x||Ue!==oe||ai.current||Tn?(typeof Be=="function"&&(cc(c,g,Be,x),oe=c.memoizedState),(te=Tn||pg(c,g,te,x,Ue,oe,we))?(Ge||typeof B.UNSAFE_componentWillMount!="function"&&typeof B.componentWillMount!="function"||(typeof B.componentWillMount=="function"&&B.componentWillMount(),typeof B.UNSAFE_componentWillMount=="function"&&B.UNSAFE_componentWillMount()),typeof B.componentDidMount=="function"&&(c.flags|=4194308)):(typeof B.componentDidMount=="function"&&(c.flags|=4194308),c.memoizedProps=x,c.memoizedState=oe),B.props=x,B.state=oe,B.context=we,x=te):(typeof B.componentDidMount=="function"&&(c.flags|=4194308),x=!1)}else{B=c.stateNode,lr(l,c),te=c.memoizedProps,we=c.type===c.elementType?te:ns(c.type,te),B.props=we,Ge=c.pendingProps,Ue=B.context,oe=g.contextType,typeof oe=="object"&&oe!==null?oe=Fi(oe):(oe=Xr(g)?oa:Or.current,oe=Co(c,oe));var pt=g.getDerivedStateFromProps;(Be=typeof pt=="function"||typeof B.getSnapshotBeforeUpdate=="function")||typeof B.UNSAFE_componentWillReceiveProps!="function"&&typeof B.componentWillReceiveProps!="function"||(te!==Ge||Ue!==oe)&&d(c,B,x,oe),Tn=!1,Ue=c.memoizedState,B.state=Ue,tr(c,x,B,M);var wt=c.memoizedState;te!==Ge||Ue!==wt||ai.current||Tn?(typeof pt=="function"&&(cc(c,g,pt,x),wt=c.memoizedState),(we=Tn||pg(c,g,we,x,Ue,wt,oe)||!1)?(Be||typeof B.UNSAFE_componentWillUpdate!="function"&&typeof B.componentWillUpdate!="function"||(typeof B.componentWillUpdate=="function"&&B.componentWillUpdate(x,wt,oe),typeof B.UNSAFE_componentWillUpdate=="function"&&B.UNSAFE_componentWillUpdate(x,wt,oe)),typeof B.componentDidUpdate=="function"&&(c.flags|=4),typeof B.getSnapshotBeforeUpdate=="function"&&(c.flags|=1024)):(typeof B.componentDidUpdate!="function"||te===l.memoizedProps&&Ue===l.memoizedState||(c.flags|=4),typeof B.getSnapshotBeforeUpdate!="function"||te===l.memoizedProps&&Ue===l.memoizedState||(c.flags|=1024),c.memoizedProps=x,c.memoizedState=wt),B.props=x,B.state=wt,B.context=oe,x=we):(typeof B.componentDidUpdate!="function"||te===l.memoizedProps&&Ue===l.memoizedState||(c.flags|=4),typeof B.getSnapshotBeforeUpdate!="function"||te===l.memoizedProps&&Ue===l.memoizedState||(c.flags|=1024),x=!1)}return Kt(l,c,g,x,R,M)}function Kt(l,c,g,x,M,R){be(l,c);var B=(c.flags&128)!==0;if(!x&&!B)return M&&zd(c,g,!1),$o(l,c,R);x=c.stateNode,Lt.current=c;var te=B&&typeof g.getDerivedStateFromError!="function"?null:x.render();return c.flags|=1,l!==null&&B?(c.child=Lo(c,l.child,null,R),c.child=Lo(c,null,te,R)):ct(l,c,te,R),c.memoizedState=x.state,M&&zd(c,g,!0),c.child}function Xt(l){var c=l.stateNode;c.pendingContext?Ud(l,c.pendingContext,c.pendingContext!==c.context):c.context&&Ud(l,c.context,!1),rc(l,c.containerInfo)}function pn(l,c,g,x,M){return Wa(),Ol(M),c.flags|=256,ct(l,c,g,x),c.child}var hr={dehydrated:null,treeContext:null,retryLane:0};function hn(l){return{baseLanes:l,cachePool:null,transitions:null}}function ga(l,c,g){var x=c.pendingProps,M=Un.current,R=!1,B=(c.flags&128)!==0,te;if((te=B)||(te=l!==null&&l.memoizedState===null?!1:(M&2)!==0),te?(R=!0,c.flags&=-129):(l===null||l.memoizedState!==null)&&(M|=1),An(Un,M&1),l===null)return Yf(c),l=c.memoizedState,l!==null&&(l=l.dehydrated,l!==null)?((c.mode&1)===0?c.lanes=1:l.data==="$!"?c.lanes=8:c.lanes=1073741824,null):(B=x.children,l=x.fallback,R?(x=c.mode,R=c.child,B={mode:"hidden",children:B},(x&1)===0&&R!==null?(R.childLanes=0,R.pendingProps=B):R=Ng(B,x,0,null),l=mc(l,x,g,null),R.return=c,l.return=c,R.sibling=l,c.child=R,c.child.memoizedState=hn(g),c.memoizedState=hr,l):np(c,B));if(M=l.memoizedState,M!==null&&(te=M.dehydrated,te!==null))return G3(l,c,B,x,te,M,g);if(R){R=x.fallback,B=c.mode,M=l.child,te=M.sibling;var oe={mode:"hidden",children:x.children};return(B&1)===0&&c.child!==M?(x=c.child,x.childLanes=0,x.pendingProps=oe,c.deletions=null):(x=ql(M,oe),x.subtreeFlags=M.subtreeFlags&14680064),te!==null?R=ql(te,R):(R=mc(R,B,g,null),R.flags|=2),R.return=c,x.return=c,x.sibling=R,c.child=x,x=R,R=c.child,B=l.child.memoizedState,B=B===null?hn(g):{baseLanes:B.baseLanes|g,cachePool:null,transitions:B.transitions},R.memoizedState=B,R.childLanes=l.childLanes&~g,c.memoizedState=hr,x}return R=l.child,l=R.sibling,x=ql(R,{mode:"visible",children:x.children}),(c.mode&1)===0&&(x.lanes=g),x.return=c,x.sibling=null,l!==null&&(g=c.deletions,g===null?(c.deletions=[l],c.flags|=16):g.push(l)),c.child=x,c.memoizedState=null,x}function np(l,c){return c=Ng({mode:"visible",children:c},l.mode,0,null),c.return=l,l.child=c}function mg(l,c,g,x){return x!==null&&Ol(x),Lo(c,l.child,null,g),l=np(c,c.pendingProps.children),l.flags|=2,c.memoizedState=null,l}function G3(l,c,g,x,M,R,B){if(g)return c.flags&256?(c.flags&=-257,x=N(Error(t(422))),mg(l,c,B,x)):c.memoizedState!==null?(c.child=l.child,c.flags|=128,null):(R=x.fallback,M=c.mode,x=Ng({mode:"visible",children:x.children},M,0,null),R=mc(R,M,B,null),R.flags|=2,x.return=c,R.return=c,x.sibling=R,c.child=x,(c.mode&1)!==0&&Lo(c,l.child,null,B),c.child.memoizedState=hn(B),c.memoizedState=hr,R);if((c.mode&1)===0)return mg(l,c,B,null);if(M.data==="$!"){if(x=M.nextSibling&&M.nextSibling.dataset,x)var te=x.dgst;return x=te,R=Error(t(419)),x=N(R,x,void 0),mg(l,c,B,x)}if(te=(B&l.childLanes)!==0,Qt||te){if(x=Zr,x!==null){switch(B&-B){case 4:M=2;break;case 16:M=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:M=32;break;case 536870912:M=268435456;break;default:M=0}M=(M&(x.suspendedLanes|B))!==0?0:M,M!==0&&M!==R.retryLane&&(R.retryLane=M,Es(l,M),_a(x,l,M,-1))}return Dv(),x=N(Error(t(421))),mg(l,c,B,x)}return M.data==="$?"?(c.flags|=128,c.child=l.child,c=rL.bind(null,l),M._reactRetry=c,null):(l=R.treeContext,li=ia(M.nextSibling),Fr=c,Fn=!0,ts=null,l!==null&&(oi[Ir++]=et,oi[Ir++]=es,oi[Ir++]=Po,et=l.id,es=l.overflow,Po=c),c=np(c,x.children),c.flags|=4096,c)}function bw(l,c,g){l.lanes|=c;var x=l.alternate;x!==null&&(x.lanes|=c),tc(l.return,c,g)}function xv(l,c,g,x,M){var R=l.memoizedState;R===null?l.memoizedState={isBackwards:c,rendering:null,renderingStartTime:0,last:x,tail:g,tailMode:M}:(R.isBackwards=c,R.rendering=null,R.renderingStartTime=0,R.last=x,R.tail=g,R.tailMode=M)}function Tw(l,c,g){var x=c.pendingProps,M=x.revealOrder,R=x.tail;if(ct(l,c,x.children,g),x=Un.current,(x&2)!==0)x=x&1|2,c.flags|=128;else{if(l!==null&&(l.flags&128)!==0)e:for(l=c.child;l!==null;){if(l.tag===13)l.memoizedState!==null&&bw(l,g,c);else if(l.tag===19)bw(l,g,c);else if(l.child!==null){l.child.return=l,l=l.child;continue}if(l===c)break e;for(;l.sibling===null;){if(l.return===null||l.return===c)break e;l=l.return}l.sibling.return=l.return,l=l.sibling}x&=1}if(An(Un,x),(c.mode&1)===0)c.memoizedState=null;else switch(M){case"forwards":for(g=c.child,M=null;g!==null;)l=g.alternate,l!==null&&bs(l)===null&&(M=g),g=g.sibling;g=M,g===null?(M=c.child,c.child=null):(M=g.sibling,g.sibling=null),xv(c,!1,M,g,R);break;case"backwards":for(g=null,M=c.child,c.child=null;M!==null;){if(l=M.alternate,l!==null&&bs(l)===null){c.child=M;break}l=M.sibling,M.sibling=g,g=M,M=l}xv(c,!0,g,null,R);break;case"together":xv(c,!1,null,null,void 0);break;default:c.memoizedState=null}return c.child}function gg(l,c){(c.mode&1)===0&&l!==null&&(l.alternate=null,c.alternate=null,c.flags|=2)}function $o(l,c,g){if(l!==null&&(c.dependencies=l.dependencies),fc|=c.lanes,(g&c.childLanes)===0)return null;if(l!==null&&c.child!==l.child)throw Error(t(153));if(c.child!==null){for(l=c.child,g=ql(l,l.pendingProps),c.child=g,g.return=c;l.sibling!==null;)l=l.sibling,g=g.sibling=ql(l,l.pendingProps),g.return=c;g.sibling=null}return c.child}function W3(l,c,g){switch(c.tag){case 3:Xt(c),Wa();break;case 5:zo(c);break;case 1:Xr(c.type)&&Ro(c);break;case 4:rc(c,c.stateNode.containerInfo);break;case 10:var x=c.type._context,M=c.memoizedProps.value;An(ko,x._currentValue),x._currentValue=M;break;case 13:if(x=c.memoizedState,x!==null)return x.dehydrated!==null?(An(Un,Un.current&1),c.flags|=128,null):(g&c.child.childLanes)!==0?ga(l,c,g):(An(Un,Un.current&1),l=$o(l,c,g),l!==null?l.sibling:null);An(Un,Un.current&1);break;case 19:if(x=(g&c.childLanes)!==0,(l.flags&128)!==0){if(x)return Tw(l,c,g);c.flags|=128}if(M=c.memoizedState,M!==null&&(M.rendering=null,M.tail=null,M.lastEffect=null),An(Un,Un.current),x)break;return null;case 22:case 23:return c.lanes=0,pe(l,c,g)}return $o(l,c,g)}var Mw,Sv,Aw,Nw;Mw=function(l,c){for(var g=c.child;g!==null;){if(g.tag===5||g.tag===6)l.appendChild(g.stateNode);else if(g.tag!==4&&g.child!==null){g.child.return=g,g=g.child;continue}if(g===c)break;for(;g.sibling===null;){if(g.return===null||g.return===c)return;g=g.return}g.sibling.return=g.return,g=g.sibling}},Sv=function(){},Aw=function(l,c,g,x){var M=l.memoizedProps;if(M!==x){l=c.stateNode,fr(Ui.current);var R=null;switch(g){case"input":M=Ie(l,M),x=Ie(l,x),R=[];break;case"select":M=ee({},M,{value:void 0}),x=ee({},x,{value:void 0}),R=[];break;case"textarea":M=wn(l,M),x=wn(l,x),R=[];break;default:typeof M.onClick!="function"&&typeof x.onClick=="function"&&(l.onclick=ju)}ae(g,x);var B;g=null;for(we in M)if(!x.hasOwnProperty(we)&&M.hasOwnProperty(we)&&M[we]!=null)if(we==="style"){var te=M[we];for(B in te)te.hasOwnProperty(B)&&(g||(g={}),g[B]="")}else we!=="dangerouslySetInnerHTML"&&we!=="children"&&we!=="suppressContentEditableWarning"&&we!=="suppressHydrationWarning"&&we!=="autoFocus"&&(i.hasOwnProperty(we)?R||(R=[]):(R=R||[]).push(we,null));for(we in x){var oe=x[we];if(te=M!=null?M[we]:void 0,x.hasOwnProperty(we)&&oe!==te&&(oe!=null||te!=null))if(we==="style")if(te){for(B in te)!te.hasOwnProperty(B)||oe&&oe.hasOwnProperty(B)||(g||(g={}),g[B]="");for(B in oe)oe.hasOwnProperty(B)&&te[B]!==oe[B]&&(g||(g={}),g[B]=oe[B])}else g||(R||(R=[]),R.push(we,g)),g=oe;else we==="dangerouslySetInnerHTML"?(oe=oe?oe.__html:void 0,te=te?te.__html:void 0,oe!=null&&te!==oe&&(R=R||[]).push(we,oe)):we==="children"?typeof oe!="string"&&typeof oe!="number"||(R=R||[]).push(we,""+oe):we!=="suppressContentEditableWarning"&&we!=="suppressHydrationWarning"&&(i.hasOwnProperty(we)?(oe!=null&&we==="onScroll"&&Ln("scroll",l),R||te===oe||(R=[])):(R=R||[]).push(we,oe))}g&&(R=R||[]).push("style",g);var we=R;(c.updateQueue=we)&&(c.flags|=4)}},Nw=function(l,c,g,x){g!==x&&(c.flags|=4)};function rp(l,c){if(!Fn)switch(l.tailMode){case"hidden":c=l.tail;for(var g=null;c!==null;)c.alternate!==null&&(g=c),c=c.sibling;g===null?l.tail=null:g.sibling=null;break;case"collapsed":g=l.tail;for(var x=null;g!==null;)g.alternate!==null&&(x=g),g=g.sibling;x===null?c||l.tail===null?l.tail=null:l.tail.sibling=null:x.sibling=null}}function xi(l){var c=l.alternate!==null&&l.alternate.child===l.child,g=0,x=0;if(c)for(var M=l.child;M!==null;)g|=M.lanes|M.childLanes,x|=M.subtreeFlags&14680064,x|=M.flags&14680064,M.return=l,M=M.sibling;else for(M=l.child;M!==null;)g|=M.lanes|M.childLanes,x|=M.subtreeFlags,x|=M.flags,M.return=l,M=M.sibling;return l.subtreeFlags|=x,l.childLanes=g,c}function j3(l,c,g){var x=c.pendingProps;switch(ua(c),c.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return xi(c),null;case 1:return Xr(c.type)&&qu(),xi(c),null;case 3:return x=c.stateNode,qa(),kn(ai),kn(Or),Bs(),x.pendingContext&&(x.context=x.pendingContext,x.pendingContext=null),(l===null||l.child===null)&&(Dl(c)?c.flags|=4:l===null||l.memoizedState.isDehydrated&&(c.flags&256)===0||(c.flags|=1024,ts!==null&&(Pv(ts),ts=null))),Sv(l,c),xi(c),null;case 5:zl(c);var M=fr(ha.current);if(g=c.type,l!==null&&c.stateNode!=null)Aw(l,c,g,x,M),l.ref!==c.ref&&(c.flags|=512,c.flags|=2097152);else{if(!x){if(c.stateNode===null)throw Error(t(166));return xi(c),null}if(l=fr(Ui.current),Dl(c)){x=c.stateNode,g=c.type;var R=c.memoizedProps;switch(x[vr]=c,x[kl]=R,l=(c.mode&1)!==0,g){case"dialog":Ln("cancel",x),Ln("close",x);break;case"iframe":case"object":case"embed":Ln("load",x);break;case"video":case"audio":for(M=0;M<$a.length;M++)Ln($a[M],x);break;case"source":Ln("error",x);break;case"img":case"image":case"link":Ln("error",x),Ln("load",x);break;case"details":Ln("toggle",x);break;case"input":je(x,R),Ln("invalid",x);break;case"select":x._wrapperState={wasMultiple:!!R.multiple},Ln("invalid",x);break;case"textarea":J(x,R),Ln("invalid",x)}ae(g,R),M=null;for(var B in R)if(R.hasOwnProperty(B)){var te=R[B];B==="children"?typeof te=="string"?x.textContent!==te&&(R.suppressHydrationWarning!==!0&&Wu(x.textContent,te,l),M=["children",te]):typeof te=="number"&&x.textContent!==""+te&&(R.suppressHydrationWarning!==!0&&Wu(x.textContent,te,l),M=["children",""+te]):i.hasOwnProperty(B)&&te!=null&&B==="onScroll"&&Ln("scroll",x)}switch(g){case"input":vt(x),at(x,R,!0);break;case"textarea":vt(x),Se(x);break;case"select":case"option":break;default:typeof R.onClick=="function"&&(x.onclick=ju)}x=M,c.updateQueue=x,x!==null&&(c.flags|=4)}else{B=M.nodeType===9?M:M.ownerDocument,l==="http://www.w3.org/1999/xhtml"&&(l=qe(g)),l==="http://www.w3.org/1999/xhtml"?g==="script"?(l=B.createElement("div"),l.innerHTML="<script><\/script>",l=l.removeChild(l.firstChild)):typeof x.is=="string"?l=B.createElement(g,{is:x.is}):(l=B.createElement(g),g==="select"&&(B=l,x.multiple?B.multiple=!0:x.size&&(B.size=x.size))):l=B.createElementNS(l,g),l[vr]=c,l[kl]=x,Mw(l,c,!1,!1),c.stateNode=l;e:{switch(B=Ne(g,x),g){case"dialog":Ln("cancel",l),Ln("close",l),M=x;break;case"iframe":case"object":case"embed":Ln("load",l),M=x;break;case"video":case"audio":for(M=0;M<$a.length;M++)Ln($a[M],l);M=x;break;case"source":Ln("error",l),M=x;break;case"img":case"image":case"link":Ln("error",l),Ln("load",l),M=x;break;case"details":Ln("toggle",l),M=x;break;case"input":je(l,x),M=Ie(l,x),Ln("invalid",l);break;case"option":M=x;break;case"select":l._wrapperState={wasMultiple:!!x.multiple},M=ee({},x,{value:void 0}),Ln("invalid",l);break;case"textarea":J(l,x),M=wn(l,x),Ln("invalid",l);break;default:M=x}ae(g,M),te=M;for(R in te)if(te.hasOwnProperty(R)){var oe=te[R];R==="style"?Xe(l,oe):R==="dangerouslySetInnerHTML"?(oe=oe?oe.__html:void 0,oe!=null&&St(l,oe)):R==="children"?typeof oe=="string"?(g!=="textarea"||oe!=="")&&Ke(l,oe):typeof oe=="number"&&Ke(l,""+oe):R!=="suppressContentEditableWarning"&&R!=="suppressHydrationWarning"&&R!=="autoFocus"&&(i.hasOwnProperty(R)?oe!=null&&R==="onScroll"&&Ln("scroll",l):oe!=null&&A(l,R,oe,B))}switch(g){case"input":vt(l),at(l,x,!1);break;case"textarea":vt(l),Se(l);break;case"option":x.value!=null&&l.setAttribute("value",""+nt(x.value));break;case"select":l.multiple=!!x.multiple,R=x.value,R!=null?Gt(l,!!x.multiple,R,!1):x.defaultValue!=null&&Gt(l,!!x.multiple,x.defaultValue,!0);break;default:typeof M.onClick=="function"&&(l.onclick=ju)}switch(g){case"button":case"input":case"select":case"textarea":x=!!x.autoFocus;break e;case"img":x=!0;break e;default:x=!1}}x&&(c.flags|=4)}c.ref!==null&&(c.flags|=512,c.flags|=2097152)}return xi(c),null;case 6:if(l&&c.stateNode!=null)Nw(l,c,l.memoizedProps,x);else{if(typeof x!="string"&&c.stateNode===null)throw Error(t(166));if(g=fr(ha.current),fr(Ui.current),Dl(c)){if(x=c.stateNode,g=c.memoizedProps,x[vr]=c,(R=x.nodeValue!==g)&&(l=Fr,l!==null))switch(l.tag){case 3:Wu(x.nodeValue,g,(l.mode&1)!==0);break;case 5:l.memoizedProps.suppressHydrationWarning!==!0&&Wu(x.nodeValue,g,(l.mode&1)!==0)}R&&(c.flags|=4)}else x=(g.nodeType===9?g:g.ownerDocument).createTextNode(x),x[vr]=c,c.stateNode=x}return xi(c),null;case 13:if(kn(Un),x=c.memoizedState,l===null||l.memoizedState!==null&&l.memoizedState.dehydrated!==null){if(Fn&&li!==null&&(c.mode&1)!==0&&(c.flags&128)===0)Gd(),Wa(),c.flags|=98560,R=!1;else if(R=Dl(c),x!==null&&x.dehydrated!==null){if(l===null){if(!R)throw Error(t(318));if(R=c.memoizedState,R=R!==null?R.dehydrated:null,!R)throw Error(t(317));R[vr]=c}else Wa(),(c.flags&128)===0&&(c.memoizedState=null),c.flags|=4;xi(c),R=!1}else ts!==null&&(Pv(ts),ts=null),R=!0;if(!R)return c.flags&65536?c:null}return(c.flags&128)!==0?(c.lanes=g,c):(x=x!==null,x!==(l!==null&&l.memoizedState!==null)&&x&&(c.child.flags|=8192,(c.mode&1)!==0&&(l===null||(Un.current&1)!==0?Vr===0&&(Vr=3):Dv())),c.updateQueue!==null&&(c.flags|=4),xi(c),null);case 4:return qa(),Sv(l,c),l===null&&Il(c.stateNode.containerInfo),xi(c),null;case 10:return ec(c.type._context),xi(c),null;case 17:return Xr(c.type)&&qu(),xi(c),null;case 19:if(kn(Un),R=c.memoizedState,R===null)return xi(c),null;if(x=(c.flags&128)!==0,B=R.rendering,B===null)if(x)rp(R,!1);else{if(Vr!==0||l!==null&&(l.flags&128)!==0)for(l=c.child;l!==null;){if(B=bs(l),B!==null){for(c.flags|=128,rp(R,!1),x=B.updateQueue,x!==null&&(c.updateQueue=x,c.flags|=4),c.subtreeFlags=0,x=g,g=c.child;g!==null;)R=g,l=x,R.flags&=14680066,B=R.alternate,B===null?(R.childLanes=0,R.lanes=l,R.child=null,R.subtreeFlags=0,R.memoizedProps=null,R.memoizedState=null,R.updateQueue=null,R.dependencies=null,R.stateNode=null):(R.childLanes=B.childLanes,R.lanes=B.lanes,R.child=B.child,R.subtreeFlags=0,R.deletions=null,R.memoizedProps=B.memoizedProps,R.memoizedState=B.memoizedState,R.updateQueue=B.updateQueue,R.type=B.type,l=B.dependencies,R.dependencies=l===null?null:{lanes:l.lanes,firstContext:l.firstContext}),g=g.sibling;return An(Un,Un.current&1|2),c.child}l=l.sibling}R.tail!==null&&ht()>lh&&(c.flags|=128,x=!0,rp(R,!1),c.lanes=4194304)}else{if(!x)if(l=bs(B),l!==null){if(c.flags|=128,x=!0,g=l.updateQueue,g!==null&&(c.updateQueue=g,c.flags|=4),rp(R,!0),R.tail===null&&R.tailMode==="hidden"&&!B.alternate&&!Fn)return xi(c),null}else 2*ht()-R.renderingStartTime>lh&&g!==1073741824&&(c.flags|=128,x=!0,rp(R,!1),c.lanes=4194304);R.isBackwards?(B.sibling=c.child,c.child=B):(g=R.last,g!==null?g.sibling=B:c.child=B,R.last=B)}return R.tail!==null?(c=R.tail,R.rendering=c,R.tail=c.sibling,R.renderingStartTime=ht(),c.sibling=null,g=Un.current,An(Un,x?g&1|2:g&1),c):(xi(c),null);case 22:case 23:return kv(),x=c.memoizedState!==null,l!==null&&l.memoizedState!==null!==x&&(c.flags|=8192),x&&(c.mode&1)!==0?(As&1073741824)!==0&&(xi(c),c.subtreeFlags&6&&(c.flags|=8192)):xi(c),null;case 24:return null;case 25:return null}throw Error(t(156,c.tag))}function q3(l,c){switch(ua(c),c.tag){case 1:return Xr(c.type)&&qu(),l=c.flags,l&65536?(c.flags=l&-65537|128,c):null;case 3:return qa(),kn(ai),kn(Or),Bs(),l=c.flags,(l&65536)!==0&&(l&128)===0?(c.flags=l&-65537|128,c):null;case 5:return zl(c),null;case 13:if(kn(Un),l=c.memoizedState,l!==null&&l.dehydrated!==null){if(c.alternate===null)throw Error(t(340));Wa()}return l=c.flags,l&65536?(c.flags=l&-65537|128,c):null;case 19:return kn(Un),null;case 4:return qa(),null;case 10:return ec(c.type._context),null;case 22:case 23:return kv(),null;case 24:return null;default:return null}}var yg=!1,Si=!1,X3=typeof WeakSet=="function"?WeakSet:Set,_t=null;function ah(l,c){var g=l.ref;if(g!==null)if(typeof g=="function")try{g(null)}catch(x){dr(l,c,x)}else g.current=null}function wv(l,c,g){try{g()}catch(x){dr(l,c,x)}}var Cw=!1;function K3(l,c){if(Ll=Xi,l=Kn(),Ar(l)){if("selectionStart"in l)var g={start:l.selectionStart,end:l.selectionEnd};else e:{g=(g=l.ownerDocument)&&g.defaultView||window;var x=g.getSelection&&g.getSelection();if(x&&x.rangeCount!==0){g=x.anchorNode;var M=x.anchorOffset,R=x.focusNode;x=x.focusOffset;try{g.nodeType,R.nodeType}catch{g=null;break e}var B=0,te=-1,oe=-1,we=0,Be=0,Ge=l,Ue=null;t:for(;;){for(var pt;Ge!==g||M!==0&&Ge.nodeType!==3||(te=B+M),Ge!==R||x!==0&&Ge.nodeType!==3||(oe=B+x),Ge.nodeType===3&&(B+=Ge.nodeValue.length),(pt=Ge.firstChild)!==null;)Ue=Ge,Ge=pt;for(;;){if(Ge===l)break t;if(Ue===g&&++we===M&&(te=B),Ue===R&&++Be===x&&(oe=B),(pt=Ge.nextSibling)!==null)break;Ge=Ue,Ue=Ge.parentNode}Ge=pt}g=te===-1||oe===-1?null:{start:te,end:oe}}else g=null}g=g||{start:0,end:0}}else g=null;for(Pd={focusedElem:l,selectionRange:g},Xi=!1,_t=c;_t!==null;)if(c=_t,l=c.child,(c.subtreeFlags&1028)!==0&&l!==null)l.return=c,_t=l;else for(;_t!==null;){c=_t;try{var wt=c.alternate;if((c.flags&1024)!==0)switch(c.tag){case 0:case 11:case 15:break;case 1:if(wt!==null){var Tt=wt.memoizedProps,_r=wt.memoizedState,ye=c.stateNode,fe=ye.getSnapshotBeforeUpdate(c.elementType===c.type?Tt:ns(c.type,Tt),_r);ye.__reactInternalSnapshotBeforeUpdate=fe}break;case 3:var _e=c.stateNode.containerInfo;_e.nodeType===1?_e.textContent="":_e.nodeType===9&&_e.documentElement&&_e.removeChild(_e.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(t(163))}}catch(Je){dr(c,c.return,Je)}if(l=c.sibling,l!==null){l.return=c.return,_t=l;break}_t=c.return}return wt=Cw,Cw=!1,wt}function ip(l,c,g){var x=c.updateQueue;if(x=x!==null?x.lastEffect:null,x!==null){var M=x=x.next;do{if((M.tag&l)===l){var R=M.destroy;M.destroy=void 0,R!==void 0&&wv(c,g,R)}M=M.next}while(M!==x)}}function vg(l,c){if(c=c.updateQueue,c=c!==null?c.lastEffect:null,c!==null){var g=c=c.next;do{if((g.tag&l)===l){var x=g.create;g.destroy=x()}g=g.next}while(g!==c)}}function Ev(l){var c=l.ref;if(c!==null){var g=l.stateNode;switch(l.tag){case 5:l=g;break;default:l=g}typeof c=="function"?c(l):c.current=l}}function Rw(l){var c=l.alternate;c!==null&&(l.alternate=null,Rw(c)),l.child=null,l.deletions=null,l.sibling=null,l.tag===5&&(c=l.stateNode,c!==null&&(delete c[vr],delete c[kl],delete c[No],delete c[$f],delete c[Gf])),l.stateNode=null,l.return=null,l.dependencies=null,l.memoizedProps=null,l.memoizedState=null,l.pendingProps=null,l.stateNode=null,l.updateQueue=null}function Iw(l){return l.tag===5||l.tag===3||l.tag===4}function Pw(l){e:for(;;){for(;l.sibling===null;){if(l.return===null||Iw(l.return))return null;l=l.return}for(l.sibling.return=l.return,l=l.sibling;l.tag!==5&&l.tag!==6&&l.tag!==18;){if(l.flags&2||l.child===null||l.tag===4)continue e;l.child.return=l,l=l.child}if(!(l.flags&2))return l.stateNode}}function bv(l,c,g){var x=l.tag;if(x===5||x===6)l=l.stateNode,c?g.nodeType===8?g.parentNode.insertBefore(l,c):g.insertBefore(l,c):(g.nodeType===8?(c=g.parentNode,c.insertBefore(l,g)):(c=g,c.appendChild(l)),g=g._reactRootContainer,g!=null||c.onclick!==null||(c.onclick=ju));else if(x!==4&&(l=l.child,l!==null))for(bv(l,c,g),l=l.sibling;l!==null;)bv(l,c,g),l=l.sibling}function Tv(l,c,g){var x=l.tag;if(x===5||x===6)l=l.stateNode,c?g.insertBefore(l,c):g.appendChild(l);else if(x!==4&&(l=l.child,l!==null))for(Tv(l,c,g),l=l.sibling;l!==null;)Tv(l,c,g),l=l.sibling}var ci=null,ya=!1;function Hl(l,c,g){for(g=g.child;g!==null;)Lw(l,c,g),g=g.sibling}function Lw(l,c,g){if(It&&typeof It.onCommitFiberUnmount=="function")try{It.onCommitFiberUnmount(sr,g)}catch{}switch(g.tag){case 5:Si||ah(g,c);case 6:var x=ci,M=ya;ci=null,Hl(l,c,g),ci=x,ya=M,ci!==null&&(ya?(l=ci,g=g.stateNode,l.nodeType===8?l.parentNode.removeChild(g):l.removeChild(g)):ci.removeChild(g.stateNode));break;case 18:ci!==null&&(ya?(l=ci,g=g.stateNode,l.nodeType===8?Hf(l.parentNode,g):l.nodeType===1&&Hf(l,g),ku(l)):Hf(ci,g.stateNode));break;case 4:x=ci,M=ya,ci=g.stateNode.containerInfo,ya=!0,Hl(l,c,g),ci=x,ya=M;break;case 0:case 11:case 14:case 15:if(!Si&&(x=g.updateQueue,x!==null&&(x=x.lastEffect,x!==null))){M=x=x.next;do{var R=M,B=R.destroy;R=R.tag,B!==void 0&&((R&2)!==0||(R&4)!==0)&&wv(g,c,B),M=M.next}while(M!==x)}Hl(l,c,g);break;case 1:if(!Si&&(ah(g,c),x=g.stateNode,typeof x.componentWillUnmount=="function"))try{x.props=g.memoizedProps,x.state=g.memoizedState,x.componentWillUnmount()}catch(te){dr(g,c,te)}Hl(l,c,g);break;case 21:Hl(l,c,g);break;case 22:g.mode&1?(Si=(x=Si)||g.memoizedState!==null,Hl(l,c,g),Si=x):Hl(l,c,g);break;default:Hl(l,c,g)}}function kw(l){var c=l.updateQueue;if(c!==null){l.updateQueue=null;var g=l.stateNode;g===null&&(g=l.stateNode=new X3),c.forEach(function(x){var M=iL.bind(null,l,x);g.has(x)||(g.add(x),x.then(M,M))})}}function va(l,c){var g=c.deletions;if(g!==null)for(var x=0;x<g.length;x++){var M=g[x];try{var R=l,B=c,te=B;e:for(;te!==null;){switch(te.tag){case 5:ci=te.stateNode,ya=!1;break e;case 3:ci=te.stateNode.containerInfo,ya=!0;break e;case 4:ci=te.stateNode.containerInfo,ya=!0;break e}te=te.return}if(ci===null)throw Error(t(160));Lw(R,B,M),ci=null,ya=!1;var oe=M.alternate;oe!==null&&(oe.return=null),M.return=null}catch(we){dr(M,c,we)}}if(c.subtreeFlags&12854)for(c=c.child;c!==null;)Dw(c,l),c=c.sibling}function Dw(l,c){var g=l.alternate,x=l.flags;switch(l.tag){case 0:case 11:case 14:case 15:if(va(c,l),Ka(l),x&4){try{ip(3,l,l.return),vg(3,l)}catch(Tt){dr(l,l.return,Tt)}try{ip(5,l,l.return)}catch(Tt){dr(l,l.return,Tt)}}break;case 1:va(c,l),Ka(l),x&512&&g!==null&&ah(g,g.return);break;case 5:if(va(c,l),Ka(l),x&512&&g!==null&&ah(g,g.return),l.flags&32){var M=l.stateNode;try{Ke(M,"")}catch(Tt){dr(l,l.return,Tt)}}if(x&4&&(M=l.stateNode,M!=null)){var R=l.memoizedProps,B=g!==null?g.memoizedProps:R,te=l.type,oe=l.updateQueue;if(l.updateQueue=null,oe!==null)try{te==="input"&&R.type==="radio"&&R.name!=null&&De(M,R),Ne(te,B);var we=Ne(te,R);for(B=0;B<oe.length;B+=2){var Be=oe[B],Ge=oe[B+1];Be==="style"?Xe(M,Ge):Be==="dangerouslySetInnerHTML"?St(M,Ge):Be==="children"?Ke(M,Ge):A(M,Be,Ge,we)}switch(te){case"input":bt(M,R);break;case"textarea":$(M,R);break;case"select":var Ue=M._wrapperState.wasMultiple;M._wrapperState.wasMultiple=!!R.multiple;var pt=R.value;pt!=null?Gt(M,!!R.multiple,pt,!1):Ue!==!!R.multiple&&(R.defaultValue!=null?Gt(M,!!R.multiple,R.defaultValue,!0):Gt(M,!!R.multiple,R.multiple?[]:"",!1))}M[kl]=R}catch(Tt){dr(l,l.return,Tt)}}break;case 6:if(va(c,l),Ka(l),x&4){if(l.stateNode===null)throw Error(t(162));M=l.stateNode,R=l.memoizedProps;try{M.nodeValue=R}catch(Tt){dr(l,l.return,Tt)}}break;case 3:if(va(c,l),Ka(l),x&4&&g!==null&&g.memoizedState.isDehydrated)try{ku(c.containerInfo)}catch(Tt){dr(l,l.return,Tt)}break;case 4:va(c,l),Ka(l);break;case 13:va(c,l),Ka(l),M=l.child,M.flags&8192&&(R=M.memoizedState!==null,M.stateNode.isHidden=R,!R||M.alternate!==null&&M.alternate.memoizedState!==null||(Nv=ht())),x&4&&kw(l);break;case 22:if(Be=g!==null&&g.memoizedState!==null,l.mode&1?(Si=(we=Si)||Be,va(c,l),Si=we):va(c,l),Ka(l),x&8192){if(we=l.memoizedState!==null,(l.stateNode.isHidden=we)&&!Be&&(l.mode&1)!==0)for(_t=l,Be=l.child;Be!==null;){for(Ge=_t=Be;_t!==null;){switch(Ue=_t,pt=Ue.child,Ue.tag){case 0:case 11:case 14:case 15:ip(4,Ue,Ue.return);break;case 1:ah(Ue,Ue.return);var wt=Ue.stateNode;if(typeof wt.componentWillUnmount=="function"){x=Ue,g=Ue.return;try{c=x,wt.props=c.memoizedProps,wt.state=c.memoizedState,wt.componentWillUnmount()}catch(Tt){dr(x,g,Tt)}}break;case 5:ah(Ue,Ue.return);break;case 22:if(Ue.memoizedState!==null){Uw(Ge);continue}}pt!==null?(pt.return=Ue,_t=pt):Uw(Ge)}Be=Be.sibling}e:for(Be=null,Ge=l;;){if(Ge.tag===5){if(Be===null){Be=Ge;try{M=Ge.stateNode,we?(R=M.style,typeof R.setProperty=="function"?R.setProperty("display","none","important"):R.display="none"):(te=Ge.stateNode,oe=Ge.memoizedProps.style,B=oe!=null&&oe.hasOwnProperty("display")?oe.display:null,te.style.display=un("display",B))}catch(Tt){dr(l,l.return,Tt)}}}else if(Ge.tag===6){if(Be===null)try{Ge.stateNode.nodeValue=we?"":Ge.memoizedProps}catch(Tt){dr(l,l.return,Tt)}}else if((Ge.tag!==22&&Ge.tag!==23||Ge.memoizedState===null||Ge===l)&&Ge.child!==null){Ge.child.return=Ge,Ge=Ge.child;continue}if(Ge===l)break e;for(;Ge.sibling===null;){if(Ge.return===null||Ge.return===l)break e;Be===Ge&&(Be=null),Ge=Ge.return}Be===Ge&&(Be=null),Ge.sibling.return=Ge.return,Ge=Ge.sibling}}break;case 19:va(c,l),Ka(l),x&4&&kw(l);break;case 21:break;default:va(c,l),Ka(l)}}function Ka(l){var c=l.flags;if(c&2){try{e:{for(var g=l.return;g!==null;){if(Iw(g)){var x=g;break e}g=g.return}throw Error(t(160))}switch(x.tag){case 5:var M=x.stateNode;x.flags&32&&(Ke(M,""),x.flags&=-33);var R=Pw(l);Tv(l,R,M);break;case 3:case 4:var B=x.stateNode.containerInfo,te=Pw(l);bv(l,te,B);break;default:throw Error(t(161))}}catch(oe){dr(l,l.return,oe)}l.flags&=-3}c&4096&&(l.flags&=-4097)}function Y3(l,c,g){_t=l,Ow(l)}function Ow(l,c,g){for(var x=(l.mode&1)!==0;_t!==null;){var M=_t,R=M.child;if(M.tag===22&&x){var B=M.memoizedState!==null||yg;if(!B){var te=M.alternate,oe=te!==null&&te.memoizedState!==null||Si;te=yg;var we=Si;if(yg=B,(Si=oe)&&!we)for(_t=M;_t!==null;)B=_t,oe=B.child,B.tag===22&&B.memoizedState!==null?zw(M):oe!==null?(oe.return=B,_t=oe):zw(M);for(;R!==null;)_t=R,Ow(R),R=R.sibling;_t=M,yg=te,Si=we}Fw(l)}else(M.subtreeFlags&8772)!==0&&R!==null?(R.return=M,_t=R):Fw(l)}}function Fw(l){for(;_t!==null;){var c=_t;if((c.flags&8772)!==0){var g=c.alternate;try{if((c.flags&8772)!==0)switch(c.tag){case 0:case 11:case 15:Si||vg(5,c);break;case 1:var x=c.stateNode;if(c.flags&4&&!Si)if(g===null)x.componentDidMount();else{var M=c.elementType===c.type?g.memoizedProps:ns(c.type,g.memoizedProps);x.componentDidUpdate(M,g.memoizedState,x.__reactInternalSnapshotBeforeUpdate)}var R=c.updateQueue;R!==null&&Ul(c,R,x);break;case 3:var B=c.updateQueue;if(B!==null){if(g=null,c.child!==null)switch(c.child.tag){case 5:g=c.child.stateNode;break;case 1:g=c.child.stateNode}Ul(c,B,g)}break;case 5:var te=c.stateNode;if(g===null&&c.flags&4){g=te;var oe=c.memoizedProps;switch(c.type){case"button":case"input":case"select":case"textarea":oe.autoFocus&&g.focus();break;case"img":oe.src&&(g.src=oe.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(c.memoizedState===null){var we=c.alternate;if(we!==null){var Be=we.memoizedState;if(Be!==null){var Ge=Be.dehydrated;Ge!==null&&ku(Ge)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(t(163))}Si||c.flags&512&&Ev(c)}catch(Ue){dr(c,c.return,Ue)}}if(c===l){_t=null;break}if(g=c.sibling,g!==null){g.return=c.return,_t=g;break}_t=c.return}}function Uw(l){for(;_t!==null;){var c=_t;if(c===l){_t=null;break}var g=c.sibling;if(g!==null){g.return=c.return,_t=g;break}_t=c.return}}function zw(l){for(;_t!==null;){var c=_t;try{switch(c.tag){case 0:case 11:case 15:var g=c.return;try{vg(4,c)}catch(oe){dr(c,g,oe)}break;case 1:var x=c.stateNode;if(typeof x.componentDidMount=="function"){var M=c.return;try{x.componentDidMount()}catch(oe){dr(c,M,oe)}}var R=c.return;try{Ev(c)}catch(oe){dr(c,R,oe)}break;case 5:var B=c.return;try{Ev(c)}catch(oe){dr(c,B,oe)}}}catch(oe){dr(c,c.return,oe)}if(c===l){_t=null;break}var te=c.sibling;if(te!==null){te.return=c.return,_t=te;break}_t=c.return}}var Z3=Math.ceil,_g=I.ReactCurrentDispatcher,Mv=I.ReactCurrentOwner,Hs=I.ReactCurrentBatchConfig,vn=0,Zr=null,Pr=null,fi=0,As=0,oh=er(0),Vr=0,sp=null,fc=0,xg=0,Av=0,ap=null,rs=null,Nv=0,lh=1/0,Go=null,Sg=!1,Cv=null,$l=null,wg=!1,Gl=null,Eg=0,op=0,Rv=null,bg=-1,Tg=0;function Hi(){return(vn&6)!==0?ht():bg!==-1?bg:bg=ht()}function Wl(l){return(l.mode&1)===0?1:(vn&2)!==0&&fi!==0?fi&-fi:vv.transition!==null?(Tg===0&&(Tg=pi()),Tg):(l=mn,l!==0||(l=window.event,l=l===void 0?16:Gm(l.type)),l)}function _a(l,c,g,x){if(50<op)throw op=0,Rv=null,Error(t(185));Ru(l,g,x),((vn&2)===0||l!==Zr)&&(l===Zr&&((vn&2)===0&&(xg|=g),Vr===4&&jl(l,fi)),is(l,x),g===1&&vn===0&&(c.mode&1)===0&&(lh=ht()+500,Ku&&Us()))}function is(l,c){var g=l.callbackNode;Mr(l,c);var x=Pi(l,l===Zr?fi:0);if(x===0)g!==null&&ft(g),l.callbackNode=null,l.callbackPriority=0;else if(c=x&-x,l.callbackPriority!==c){if(g!=null&&ft(g),c===1)l.tag===0?ig(Vw.bind(null,l)):Yu(Vw.bind(null,l)),yv(function(){(vn&6)===0&&Us()}),g=null;else{switch(vl(x)){case 1:g=Bt;break;case 4:g=$t;break;case 16:g=In;break;case 536870912:g=Pn;break;default:g=In}g=Kw(g,Bw.bind(null,l))}l.callbackPriority=c,l.callbackNode=g}}function Bw(l,c){if(bg=-1,Tg=0,(vn&6)!==0)throw Error(t(327));var g=l.callbackNode;if(uh()&&l.callbackNode!==g)return null;var x=Pi(l,l===Zr?fi:0);if(x===0)return null;if((x&30)!==0||(x&l.expiredLanes)!==0||c)c=Mg(l,x);else{c=x;var M=vn;vn|=2;var R=$w();(Zr!==l||fi!==c)&&(Go=null,lh=ht()+500,dc(l,c));do try{eL();break}catch(te){Hw(l,te)}while(!0);Oo(),_g.current=R,vn=M,Pr!==null?c=0:(Zr=null,fi=0,c=Vr)}if(c!==0){if(c===2&&(M=Oa(l),M!==0&&(x=M,c=Iv(l,M))),c===1)throw g=sp,dc(l,0),jl(l,x),is(l,ht()),g;if(c===6)jl(l,x);else{if(M=l.current.alternate,(x&30)===0&&!J3(M)&&(c=Mg(l,x),c===2&&(R=Oa(l),R!==0&&(x=R,c=Iv(l,R))),c===1))throw g=sp,dc(l,0),jl(l,x),is(l,ht()),g;switch(l.finishedWork=M,l.finishedLanes=x,c){case 0:case 1:throw Error(t(345));case 2:pc(l,rs,Go);break;case 3:if(jl(l,x),(x&130023424)===x&&(c=Nv+500-ht(),10<c)){if(Pi(l,0)!==0)break;if(M=l.suspendedLanes,(M&x)!==x){Hi(),l.pingedLanes|=l.suspendedLanes&M;break}l.timeoutHandle=kd(pc.bind(null,l,rs,Go),c);break}pc(l,rs,Go);break;case 4:if(jl(l,x),(x&4194240)===x)break;for(c=l.eventTimes,M=-1;0<x;){var B=31-Jn(x);R=1<<B,B=c[B],B>M&&(M=B),x&=~R}if(x=M,x=ht()-x,x=(120>x?120:480>x?480:1080>x?1080:1920>x?1920:3e3>x?3e3:4320>x?4320:1960*Z3(x/1960))-x,10<x){l.timeoutHandle=kd(pc.bind(null,l,rs,Go),x);break}pc(l,rs,Go);break;case 5:pc(l,rs,Go);break;default:throw Error(t(329))}}}return is(l,ht()),l.callbackNode===g?Bw.bind(null,l):null}function Iv(l,c){var g=ap;return l.current.memoizedState.isDehydrated&&(dc(l,c).flags|=256),l=Mg(l,c),l!==2&&(c=rs,rs=g,c!==null&&Pv(c)),l}function Pv(l){rs===null?rs=l:rs.push.apply(rs,l)}function J3(l){for(var c=l;;){if(c.flags&16384){var g=c.updateQueue;if(g!==null&&(g=g.stores,g!==null))for(var x=0;x<g.length;x++){var M=g[x],R=M.getSnapshot;M=M.value;try{if(!ki(R(),M))return!1}catch{return!1}}}if(g=c.child,c.subtreeFlags&16384&&g!==null)g.return=c,c=g;else{if(c===l)break;for(;c.sibling===null;){if(c.return===null||c.return===l)return!0;c=c.return}c.sibling.return=c.return,c=c.sibling}}return!0}function jl(l,c){for(c&=~Av,c&=~xg,l.suspendedLanes|=c,l.pingedLanes&=~c,l=l.expirationTimes;0<c;){var g=31-Jn(c),x=1<<g;l[g]=-1,c&=~x}}function Vw(l){if((vn&6)!==0)throw Error(t(327));uh();var c=Pi(l,0);if((c&1)===0)return is(l,ht()),null;var g=Mg(l,c);if(l.tag!==0&&g===2){var x=Oa(l);x!==0&&(c=x,g=Iv(l,x))}if(g===1)throw g=sp,dc(l,0),jl(l,c),is(l,ht()),g;if(g===6)throw Error(t(345));return l.finishedWork=l.current.alternate,l.finishedLanes=c,pc(l,rs,Go),is(l,ht()),null}function Lv(l,c){var g=vn;vn|=1;try{return l(c)}finally{vn=g,vn===0&&(lh=ht()+500,Ku&&Us())}}function hc(l){Gl!==null&&Gl.tag===0&&(vn&6)===0&&uh();var c=vn;vn|=1;var g=Hs.transition,x=mn;try{if(Hs.transition=null,mn=1,l)return l()}finally{mn=x,Hs.transition=g,vn=c,(vn&6)===0&&Us()}}function kv(){As=oh.current,kn(oh)}function dc(l,c){l.finishedWork=null,l.finishedLanes=0;var g=l.timeoutHandle;if(g!==-1&&(l.timeoutHandle=-1,Dd(g)),Pr!==null)for(g=Pr.return;g!==null;){var x=g;switch(ua(x),x.tag){case 1:x=x.type.childContextTypes,x!=null&&qu();break;case 3:qa(),kn(ai),kn(Or),Bs();break;case 5:zl(x);break;case 4:qa();break;case 13:kn(Un);break;case 19:kn(Un);break;case 10:ec(x.type._context);break;case 22:case 23:kv()}g=g.return}if(Zr=l,Pr=l=ql(l.current,null),fi=As=c,Vr=0,sp=null,Av=xg=fc=0,rs=ap=null,fa!==null){for(c=0;c<fa.length;c++)if(g=fa[c],x=g.interleaved,x!==null){g.interleaved=null;var M=x.next,R=g.pending;if(R!==null){var B=R.next;R.next=M,x.next=B}g.pending=x}fa=null}return l}function Hw(l,c){do{var g=Pr;try{if(Oo(),Bo.current=ih,Ts){for(var x=Dn.memoizedState;x!==null;){var M=x.queue;M!==null&&(M.pending=null),x=x.next}Ts=!1}if(da=0,gn=nr=Dn=null,Yr=!1,Xa=0,Mv.current=null,g===null||g.return===null){Vr=1,sp=c,Pr=null;break}e:{var R=l,B=g.return,te=g,oe=c;if(c=fi,te.flags|=32768,oe!==null&&typeof oe=="object"&&typeof oe.then=="function"){var we=oe,Be=te,Ge=Be.tag;if((Be.mode&1)===0&&(Ge===0||Ge===11||Ge===15)){var Ue=Be.alternate;Ue?(Be.updateQueue=Ue.updateQueue,Be.memoizedState=Ue.memoizedState,Be.lanes=Ue.lanes):(Be.updateQueue=null,Be.memoizedState=null)}var pt=mt(B);if(pt!==null){pt.flags&=-257,qt(pt,B,te,R,c),pt.mode&1&&Ye(R,we,c),c=pt,oe=we;var wt=c.updateQueue;if(wt===null){var Tt=new Set;Tt.add(oe),c.updateQueue=Tt}else wt.add(oe);break e}else{if((c&1)===0){Ye(R,we,c),Dv();break e}oe=Error(t(426))}}else if(Fn&&te.mode&1){var _r=mt(B);if(_r!==null){(_r.flags&65536)===0&&(_r.flags|=256),qt(_r,B,te,R,c),Ol(b(oe,te));break e}}R=oe=b(oe,te),Vr!==4&&(Vr=2),ap===null?ap=[R]:ap.push(R),R=B;do{switch(R.tag){case 3:R.flags|=65536,c&=-c,R.lanes|=c;var ye=he(R,oe,c);Fo(R,ye);break e;case 1:te=oe;var fe=R.type,_e=R.stateNode;if((R.flags&128)===0&&(typeof fe.getDerivedStateFromError=="function"||_e!==null&&typeof _e.componentDidCatch=="function"&&($l===null||!$l.has(_e)))){R.flags|=65536,c&=-c,R.lanes|=c;var Je=Ae(R,te,c);Fo(R,Je);break e}}R=R.return}while(R!==null)}Ww(g)}catch(Nt){c=Nt,Pr===g&&g!==null&&(Pr=g=g.return);continue}break}while(!0)}function $w(){var l=_g.current;return _g.current=ih,l===null?ih:l}function Dv(){(Vr===0||Vr===3||Vr===2)&&(Vr=4),Zr===null||(fc&268435455)===0&&(xg&268435455)===0||jl(Zr,fi)}function Mg(l,c){var g=vn;vn|=2;var x=$w();(Zr!==l||fi!==c)&&(Go=null,dc(l,c));do try{Q3();break}catch(M){Hw(l,M)}while(!0);if(Oo(),vn=g,_g.current=x,Pr!==null)throw Error(t(261));return Zr=null,fi=0,Vr}function Q3(){for(;Pr!==null;)Gw(Pr)}function eL(){for(;Pr!==null&&!Rt();)Gw(Pr)}function Gw(l){var c=Xw(l.alternate,l,As);l.memoizedProps=l.pendingProps,c===null?Ww(l):Pr=c,Mv.current=null}function Ww(l){var c=l;do{var g=c.alternate;if(l=c.return,(c.flags&32768)===0){if(g=j3(g,c,As),g!==null){Pr=g;return}}else{if(g=q3(g,c),g!==null){g.flags&=32767,Pr=g;return}if(l!==null)l.flags|=32768,l.subtreeFlags=0,l.deletions=null;else{Vr=6,Pr=null;return}}if(c=c.sibling,c!==null){Pr=c;return}Pr=c=l}while(c!==null);Vr===0&&(Vr=5)}function pc(l,c,g){var x=mn,M=Hs.transition;try{Hs.transition=null,mn=1,tL(l,c,g,x)}finally{Hs.transition=M,mn=x}return null}function tL(l,c,g,x){do uh();while(Gl!==null);if((vn&6)!==0)throw Error(t(327));g=l.finishedWork;var M=l.finishedLanes;if(g===null)return null;if(l.finishedWork=null,l.finishedLanes=0,g===l.current)throw Error(t(177));l.callbackNode=null,l.callbackPriority=0;var R=g.lanes|g.childLanes;if(dv(l,R),l===Zr&&(Pr=Zr=null,fi=0),(g.subtreeFlags&2064)===0&&(g.flags&2064)===0||wg||(wg=!0,Kw(In,function(){return uh(),null})),R=(g.flags&15990)!==0,(g.subtreeFlags&15990)!==0||R){R=Hs.transition,Hs.transition=null;var B=mn;mn=1;var te=vn;vn|=4,Mv.current=null,K3(l,g),Dw(g,l),Nr(Pd),Xi=!!Ll,Pd=Ll=null,l.current=g,Y3(g),Dt(),vn=te,mn=B,Hs.transition=R}else l.current=g;if(wg&&(wg=!1,Gl=l,Eg=M),R=l.pendingLanes,R===0&&($l=null),xt(g.stateNode),is(l,ht()),c!==null)for(x=l.onRecoverableError,g=0;g<c.length;g++)M=c[g],x(M.value,{componentStack:M.stack,digest:M.digest});if(Sg)throw Sg=!1,l=Cv,Cv=null,l;return(Eg&1)!==0&&l.tag!==0&&uh(),R=l.pendingLanes,(R&1)!==0?l===Rv?op++:(op=0,Rv=l):op=0,Us(),null}function uh(){if(Gl!==null){var l=vl(Eg),c=Hs.transition,g=mn;try{if(Hs.transition=null,mn=16>l?16:l,Gl===null)var x=!1;else{if(l=Gl,Gl=null,Eg=0,(vn&6)!==0)throw Error(t(331));var M=vn;for(vn|=4,_t=l.current;_t!==null;){var R=_t,B=R.child;if((_t.flags&16)!==0){var te=R.deletions;if(te!==null){for(var oe=0;oe<te.length;oe++){var we=te[oe];for(_t=we;_t!==null;){var Be=_t;switch(Be.tag){case 0:case 11:case 15:ip(8,Be,R)}var Ge=Be.child;if(Ge!==null)Ge.return=Be,_t=Ge;else for(;_t!==null;){Be=_t;var Ue=Be.sibling,pt=Be.return;if(Rw(Be),Be===we){_t=null;break}if(Ue!==null){Ue.return=pt,_t=Ue;break}_t=pt}}}var wt=R.alternate;if(wt!==null){var Tt=wt.child;if(Tt!==null){wt.child=null;do{var _r=Tt.sibling;Tt.sibling=null,Tt=_r}while(Tt!==null)}}_t=R}}if((R.subtreeFlags&2064)!==0&&B!==null)B.return=R,_t=B;else e:for(;_t!==null;){if(R=_t,(R.flags&2048)!==0)switch(R.tag){case 0:case 11:case 15:ip(9,R,R.return)}var ye=R.sibling;if(ye!==null){ye.return=R.return,_t=ye;break e}_t=R.return}}var fe=l.current;for(_t=fe;_t!==null;){B=_t;var _e=B.child;if((B.subtreeFlags&2064)!==0&&_e!==null)_e.return=B,_t=_e;else e:for(B=fe;_t!==null;){if(te=_t,(te.flags&2048)!==0)try{switch(te.tag){case 0:case 11:case 15:vg(9,te)}}catch(Nt){dr(te,te.return,Nt)}if(te===B){_t=null;break e}var Je=te.sibling;if(Je!==null){Je.return=te.return,_t=Je;break e}_t=te.return}}if(vn=M,Us(),It&&typeof It.onPostCommitFiberRoot=="function")try{It.onPostCommitFiberRoot(sr,l)}catch{}x=!0}return x}finally{mn=g,Hs.transition=c}}return!1}function jw(l,c,g){c=b(g,c),c=he(l,c,1),l=jn(l,c,1),c=Hi(),l!==null&&(Ru(l,1,c),is(l,c))}function dr(l,c,g){if(l.tag===3)jw(l,l,g);else for(;c!==null;){if(c.tag===3){jw(c,l,g);break}else if(c.tag===1){var x=c.stateNode;if(typeof c.type.getDerivedStateFromError=="function"||typeof x.componentDidCatch=="function"&&($l===null||!$l.has(x))){l=b(g,l),l=Ae(c,l,1),c=jn(c,l,1),l=Hi(),c!==null&&(Ru(c,1,l),is(c,l));break}}c=c.return}}function nL(l,c,g){var x=l.pingCache;x!==null&&x.delete(c),c=Hi(),l.pingedLanes|=l.suspendedLanes&g,Zr===l&&(fi&g)===g&&(Vr===4||Vr===3&&(fi&130023424)===fi&&500>ht()-Nv?dc(l,0):Av|=g),is(l,c)}function qw(l,c){c===0&&((l.mode&1)===0?c=1:(c=ar,ar<<=1,(ar&130023424)===0&&(ar=4194304)));var g=Hi();l=Es(l,c),l!==null&&(Ru(l,c,g),is(l,g))}function rL(l){var c=l.memoizedState,g=0;c!==null&&(g=c.retryLane),qw(l,g)}function iL(l,c){var g=0;switch(l.tag){case 13:var x=l.stateNode,M=l.memoizedState;M!==null&&(g=M.retryLane);break;case 19:x=l.stateNode;break;default:throw Error(t(314))}x!==null&&x.delete(c),qw(l,g)}var Xw;Xw=function(l,c,g){if(l!==null)if(l.memoizedProps!==c.pendingProps||ai.current)Qt=!0;else{if((l.lanes&g)===0&&(c.flags&128)===0)return Qt=!1,W3(l,c,g);Qt=(l.flags&131072)!==0}else Qt=!1,Fn&&(c.flags&1048576)!==0&&Bd(c,Xf,c.index);switch(c.lanes=0,c.tag){case 2:var x=c.type;gg(l,c),l=c.pendingProps;var M=Co(c,Or.current);ja(c,g),M=sc(null,c,x,l,M,g);var R=Xd();return c.flags|=1,typeof M=="object"&&M!==null&&typeof M.render=="function"&&M.$$typeof===void 0?(c.tag=1,c.memoizedState=null,c.updateQueue=null,Xr(x)?(R=!0,Ro(c)):R=!1,c.memoizedState=M.state!==null&&M.state!==void 0?M.state:null,Zt(c),M.updater=sh,c.stateNode=M,M._reactInternals=c,_(c,x,l,g),c=Kt(null,c,x,!0,R,g)):(c.tag=0,Fn&&R&&Vd(c),ct(null,c,M,g),c=c.child),c;case 16:x=c.elementType;e:{switch(gg(l,c),l=c.pendingProps,M=x._init,x=M(x._payload),c.type=x,M=c.tag=aL(x),l=ns(x,l),M){case 0:c=ot(null,c,x,l,g);break e;case 1:c=Mt(null,c,x,l,g);break e;case 11:c=Br(null,c,x,l,g);break e;case 14:c=Vi(null,c,x,ns(x.type,l),g);break e}throw Error(t(306,x,""))}return c;case 0:return x=c.type,M=c.pendingProps,M=c.elementType===x?M:ns(x,M),ot(l,c,x,M,g);case 1:return x=c.type,M=c.pendingProps,M=c.elementType===x?M:ns(x,M),Mt(l,c,x,M,g);case 3:e:{if(Xt(c),l===null)throw Error(t(387));x=c.pendingProps,R=c.memoizedState,M=R.element,lr(l,c),tr(c,x,null,g);var B=c.memoizedState;if(x=B.element,R.isDehydrated)if(R={element:x,isDehydrated:!1,cache:B.cache,pendingSuspenseBoundaries:B.pendingSuspenseBoundaries,transitions:B.transitions},c.updateQueue.baseState=R,c.memoizedState=R,c.flags&256){M=b(Error(t(423)),c),c=pn(l,c,x,g,M);break e}else if(x!==M){M=b(Error(t(424)),c),c=pn(l,c,x,g,M);break e}else for(li=ia(c.stateNode.containerInfo.firstChild),Fr=c,Fn=!0,ts=null,g=Qu(c,null,x,g),c.child=g;g;)g.flags=g.flags&-3|4096,g=g.sibling;else{if(Wa(),x===M){c=$o(l,c,g);break e}ct(l,c,x,g)}c=c.child}return c;case 5:return zo(c),l===null&&Yf(c),x=c.type,M=c.pendingProps,R=l!==null?l.memoizedProps:null,B=M.children,Ld(x,M)?B=null:R!==null&&Ld(x,R)&&(c.flags|=32),be(l,c),ct(l,c,B,g),c.child;case 6:return l===null&&Yf(c),null;case 13:return ga(l,c,g);case 4:return rc(c,c.stateNode.containerInfo),x=c.pendingProps,l===null?c.child=Lo(c,null,x,g):ct(l,c,x,g),c.child;case 11:return x=c.type,M=c.pendingProps,M=c.elementType===x?M:ns(x,M),Br(l,c,x,M,g);case 7:return ct(l,c,c.pendingProps,g),c.child;case 8:return ct(l,c,c.pendingProps.children,g),c.child;case 12:return ct(l,c,c.pendingProps.children,g),c.child;case 10:e:{if(x=c.type._context,M=c.pendingProps,R=c.memoizedProps,B=M.value,An(ko,x._currentValue),x._currentValue=B,R!==null)if(ki(R.value,B)){if(R.children===M.children&&!ai.current){c=$o(l,c,g);break e}}else for(R=c.child,R!==null&&(R.return=c);R!==null;){var te=R.dependencies;if(te!==null){B=R.child;for(var oe=te.firstContext;oe!==null;){if(oe.context===x){if(R.tag===1){oe=Mn(-1,g&-g),oe.tag=2;var we=R.updateQueue;if(we!==null){we=we.shared;var Be=we.pending;Be===null?oe.next=oe:(oe.next=Be.next,Be.next=oe),we.pending=oe}}R.lanes|=g,oe=R.alternate,oe!==null&&(oe.lanes|=g),tc(R.return,g,c),te.lanes|=g;break}oe=oe.next}}else if(R.tag===10)B=R.type===c.type?null:R.child;else if(R.tag===18){if(B=R.return,B===null)throw Error(t(341));B.lanes|=g,te=B.alternate,te!==null&&(te.lanes|=g),tc(B,g,c),B=R.sibling}else B=R.child;if(B!==null)B.return=R;else for(B=R;B!==null;){if(B===c){B=null;break}if(R=B.sibling,R!==null){R.return=B.return,B=R;break}B=B.return}R=B}ct(l,c,M.children,g),c=c.child}return c;case 9:return M=c.type,x=c.pendingProps.children,ja(c,g),M=Fi(M),x=x(M),c.flags|=1,ct(l,c,x,g),c.child;case 14:return x=c.type,M=ns(x,c.pendingProps),M=ns(x.type,M),Vi(l,c,x,M,g);case 15:return xe(l,c,c.type,c.pendingProps,g);case 17:return x=c.type,M=c.pendingProps,M=c.elementType===x?M:ns(x,M),gg(l,c),c.tag=1,Xr(x)?(l=!0,Ro(c)):l=!1,ja(c,g),f(c,x,M),_(c,x,M,g),Kt(null,c,x,!0,l,g);case 19:return Tw(l,c,g);case 22:return pe(l,c,g)}throw Error(t(156,c.tag))};function Kw(l,c){return Me(l,c)}function sL(l,c,g,x){this.tag=l,this.key=g,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=c,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=x,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function $s(l,c,g,x){return new sL(l,c,g,x)}function Ov(l){return l=l.prototype,!(!l||!l.isReactComponent)}function aL(l){if(typeof l=="function")return Ov(l)?1:0;if(l!=null){if(l=l.$$typeof,l===Q)return 11;if(l===ce)return 14}return 2}function ql(l,c){var g=l.alternate;return g===null?(g=$s(l.tag,c,l.key,l.mode),g.elementType=l.elementType,g.type=l.type,g.stateNode=l.stateNode,g.alternate=l,l.alternate=g):(g.pendingProps=c,g.type=l.type,g.flags=0,g.subtreeFlags=0,g.deletions=null),g.flags=l.flags&14680064,g.childLanes=l.childLanes,g.lanes=l.lanes,g.child=l.child,g.memoizedProps=l.memoizedProps,g.memoizedState=l.memoizedState,g.updateQueue=l.updateQueue,c=l.dependencies,g.dependencies=c===null?null:{lanes:c.lanes,firstContext:c.firstContext},g.sibling=l.sibling,g.index=l.index,g.ref=l.ref,g}function Ag(l,c,g,x,M,R){var B=2;if(x=l,typeof l=="function")Ov(l)&&(B=1);else if(typeof l=="string")B=5;else e:switch(l){case V:return mc(g.children,M,R,c);case G:B=8,M|=8;break;case L:return l=$s(12,g,c,M|2),l.elementType=L,l.lanes=R,l;case le:return l=$s(13,g,c,M),l.elementType=le,l.lanes=R,l;case K:return l=$s(19,g,c,M),l.elementType=K,l.lanes=R,l;case me:return Ng(g,M,R,c);default:if(typeof l=="object"&&l!==null)switch(l.$$typeof){case k:B=10;break e;case O:B=9;break e;case Q:B=11;break e;case ce:B=14;break e;case de:B=16,x=null;break e}throw Error(t(130,l==null?l:typeof l,""))}return c=$s(B,g,c,M),c.elementType=l,c.type=x,c.lanes=R,c}function mc(l,c,g,x){return l=$s(7,l,x,c),l.lanes=g,l}function Ng(l,c,g,x){return l=$s(22,l,x,c),l.elementType=me,l.lanes=g,l.stateNode={isHidden:!1},l}function Fv(l,c,g){return l=$s(6,l,null,c),l.lanes=g,l}function Uv(l,c,g){return c=$s(4,l.children!==null?l.children:[],l.key,c),c.lanes=g,c.stateNode={containerInfo:l.containerInfo,pendingChildren:null,implementation:l.implementation},c}function oL(l,c,g,x,M){this.tag=c,this.containerInfo=l,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=gl(0),this.expirationTimes=gl(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=gl(0),this.identifierPrefix=x,this.onRecoverableError=M,this.mutableSourceEagerHydrationData=null}function zv(l,c,g,x,M,R,B,te,oe){return l=new oL(l,c,g,te,oe),c===1?(c=1,R===!0&&(c|=8)):c=0,R=$s(3,null,null,c),l.current=R,R.stateNode=l,R.memoizedState={element:x,isDehydrated:g,cache:null,transitions:null,pendingSuspenseBoundaries:null},Zt(R),l}function lL(l,c,g){var x=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:U,key:x==null?null:""+x,children:l,containerInfo:c,implementation:g}}function Yw(l){if(!l)return aa;l=l._reactInternals;e:{if(Ys(l)!==l||l.tag!==1)throw Error(t(170));var c=l;do{switch(c.tag){case 3:c=c.stateNode.context;break e;case 1:if(Xr(c.type)){c=c.stateNode.__reactInternalMemoizedMergedChildContext;break e}}c=c.return}while(c!==null);throw Error(t(171))}if(l.tag===1){var g=l.type;if(Xr(g))return Xu(l,g,c)}return c}function Zw(l,c,g,x,M,R,B,te,oe){return l=zv(g,x,!0,l,M,R,B,te,oe),l.context=Yw(null),g=l.current,x=Hi(),M=Wl(g),R=Mn(x,M),R.callback=c??null,jn(g,R,M),l.current.lanes=M,Ru(l,M,x),is(l,x),l}function Cg(l,c,g,x){var M=c.current,R=Hi(),B=Wl(M);return g=Yw(g),c.context===null?c.context=g:c.pendingContext=g,c=Mn(R,B),c.payload={element:l},x=x===void 0?null:x,x!==null&&(c.callback=x),l=jn(M,c,B),l!==null&&(_a(l,M,B,R),Kr(l,M,B)),B}function Rg(l){if(l=l.current,!l.child)return null;switch(l.child.tag){case 5:return l.child.stateNode;default:return l.child.stateNode}}function Jw(l,c){if(l=l.memoizedState,l!==null&&l.dehydrated!==null){var g=l.retryLane;l.retryLane=g!==0&&g<c?g:c}}function Bv(l,c){Jw(l,c),(l=l.alternate)&&Jw(l,c)}function uL(){return null}var Qw=typeof reportError=="function"?reportError:function(l){console.error(l)};function Vv(l){this._internalRoot=l}Ig.prototype.render=Vv.prototype.render=function(l){var c=this._internalRoot;if(c===null)throw Error(t(409));Cg(l,c,null,null)},Ig.prototype.unmount=Vv.prototype.unmount=function(){var l=this._internalRoot;if(l!==null){this._internalRoot=null;var c=l.containerInfo;hc(function(){Cg(null,l,null,null)}),c[Oi]=null}};function Ig(l){this._internalRoot=l}Ig.prototype.unstable_scheduleHydration=function(l){if(l){var c=df();l={blockedOn:null,target:l,priority:c};for(var g=0;g<Fa.length&&c!==0&&c<Fa[g].priority;g++);Fa.splice(g,0,l),g===0&&gf(l)}};function Hv(l){return!(!l||l.nodeType!==1&&l.nodeType!==9&&l.nodeType!==11)}function Pg(l){return!(!l||l.nodeType!==1&&l.nodeType!==9&&l.nodeType!==11&&(l.nodeType!==8||l.nodeValue!==" react-mount-point-unstable "))}function eE(){}function cL(l,c,g,x,M){if(M){if(typeof x=="function"){var R=x;x=function(){var we=Rg(B);R.call(we)}}var B=Zw(c,x,l,0,null,!1,!1,"",eE);return l._reactRootContainer=B,l[Oi]=B.current,Il(l.nodeType===8?l.parentNode:l),hc(),B}for(;M=l.lastChild;)l.removeChild(M);if(typeof x=="function"){var te=x;x=function(){var we=Rg(oe);te.call(we)}}var oe=zv(l,0,!1,null,null,!1,!1,"",eE);return l._reactRootContainer=oe,l[Oi]=oe.current,Il(l.nodeType===8?l.parentNode:l),hc(function(){Cg(c,oe,g,x)}),oe}function Lg(l,c,g,x,M){var R=g._reactRootContainer;if(R){var B=R;if(typeof M=="function"){var te=M;M=function(){var oe=Rg(B);te.call(oe)}}Cg(c,B,l,M)}else B=cL(g,c,l,M,x);return Rg(B)}Iu=function(l){switch(l.tag){case 3:var c=l.stateNode;if(c.current.memoizedState.isDehydrated){var g=Gn(c.pendingLanes);g!==0&&(yl(c,g|1),is(c,ht()),(vn&6)===0&&(lh=ht()+500,Us()))}break;case 13:hc(function(){var x=Es(l,1);if(x!==null){var M=Hi();_a(x,l,1,M)}}),Bv(l,1)}},md=function(l){if(l.tag===13){var c=Es(l,134217728);if(c!==null){var g=Hi();_a(c,l,134217728,g)}Bv(l,134217728)}},$m=function(l){if(l.tag===13){var c=Wl(l),g=Es(l,c);if(g!==null){var x=Hi();_a(g,l,c,x)}Bv(l,c)}},df=function(){return mn},pf=function(l,c){var g=mn;try{return mn=l,c()}finally{mn=g}},Ct=function(l,c,g){switch(c){case"input":if(bt(l,g),c=g.name,g.type==="radio"&&c!=null){for(g=l;g.parentNode;)g=g.parentNode;for(g=g.querySelectorAll("input[name="+JSON.stringify(""+c)+'][type="radio"]'),c=0;c<g.length;c++){var x=g[c];if(x!==l&&x.form===l.form){var M=Wf(x);if(!M)throw Error(t(90));se(x),bt(x,M)}}}break;case"textarea":$(l,g);break;case"select":c=g.value,c!=null&&Gt(l,!!g.multiple,c,!1)}},Et=Lv,Yt=hc;var fL={usingClientEntryPoint:!1,Events:[sa,or,Wf,Re,$e,Lv]},lp={findFiberByHostInstance:Ga,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},hL={bundleType:lp.bundleType,version:lp.version,rendererPackageName:lp.rendererPackageName,rendererConfig:lp.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:I.ReactCurrentDispatcher,findHostInstanceByFiber:function(l){return l=Ee(l),l===null?null:l.stateNode},findFiberByHostInstance:lp.findFiberByHostInstance||uL,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var kg=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!kg.isDisabled&&kg.supportsFiber)try{sr=kg.inject(hL),It=kg}catch{}}return ss.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=fL,ss.createPortal=function(l,c){var g=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!Hv(c))throw Error(t(200));return lL(l,c,null,g)},ss.createRoot=function(l,c){if(!Hv(l))throw Error(t(299));var g=!1,x="",M=Qw;return c!=null&&(c.unstable_strictMode===!0&&(g=!0),c.identifierPrefix!==void 0&&(x=c.identifierPrefix),c.onRecoverableError!==void 0&&(M=c.onRecoverableError)),c=zv(l,1,!1,null,null,g,!1,x,M),l[Oi]=c.current,Il(l.nodeType===8?l.parentNode:l),new Vv(c)},ss.findDOMNode=function(l){if(l==null)return null;if(l.nodeType===1)return l;var c=l._reactInternals;if(c===void 0)throw typeof l.render=="function"?Error(t(188)):(l=Object.keys(l).join(","),Error(t(268,l)));return l=Ee(c),l=l===null?null:l.stateNode,l},ss.flushSync=function(l){return hc(l)},ss.hydrate=function(l,c,g){if(!Pg(c))throw Error(t(200));return Lg(null,l,c,!0,g)},ss.hydrateRoot=function(l,c,g){if(!Hv(l))throw Error(t(405));var x=g!=null&&g.hydratedSources||null,M=!1,R="",B=Qw;if(g!=null&&(g.unstable_strictMode===!0&&(M=!0),g.identifierPrefix!==void 0&&(R=g.identifierPrefix),g.onRecoverableError!==void 0&&(B=g.onRecoverableError)),c=Zw(c,null,l,1,g??null,M,!1,R,B),l[Oi]=c.current,Il(l),x)for(l=0;l<x.length;l++)g=x[l],M=g._getVersion,M=M(g._source),c.mutableSourceEagerHydrationData==null?c.mutableSourceEagerHydrationData=[g,M]:c.mutableSourceEagerHydrationData.push(g,M);return new Ig(c)},ss.render=function(l,c,g){if(!Pg(c))throw Error(t(200));return Lg(null,l,c,!1,g)},ss.unmountComponentAtNode=function(l){if(!Pg(l))throw Error(t(40));return l._reactRootContainer?(hc(function(){Lg(null,null,l,!1,function(){l._reactRootContainer=null,l[Oi]=null})}),!0):!1},ss.unstable_batchedUpdates=Lv,ss.unstable_renderSubtreeIntoContainer=function(l,c,g,x){if(!Pg(g))throw Error(t(200));if(l==null||l._reactInternals===void 0)throw Error(t(38));return Lg(l,c,g,!1,x)},ss.version="18.3.1-next-f1338f8080-20240426",ss}var lE;function wL(){if(lE)return Wv.exports;lE=1;function r(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(r)}catch(e){console.error(e)}}return r(),Wv.exports=SL(),Wv.exports}var uE;function EL(){if(uE)return Dg;uE=1;var r=wL();return Dg.createRoot=r.createRoot,Dg.hydrateRoot=r.hydrateRoot,Dg}var bL=EL();const TL=v0(bL);/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const x0="158",Mc={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},Ac={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},HT=0,Z_=1,$T=2,ML=3,GT=0,S0=1,Cp=2,Ea=3,ll=0,Wi=1,Za=2,AL=2,sl=0,Bc=1,J_=2,Q_=3,ex=4,WT=5,nu=100,jT=101,qT=102,tx=103,nx=104,XT=200,KT=201,YT=202,ZT=203,Zy=204,Jy=205,JT=206,QT=207,eM=208,tM=209,nM=210,rM=211,iM=212,sM=213,aM=214,oM=0,lM=1,uM=2,Fp=3,cM=4,fM=5,hM=6,dM=7,_m=0,pM=1,mM=2,eo=0,gM=1,yM=2,vM=3,wS=4,_M=5,rx="attached",xM="detached",w0=300,ul=301,du=302,Up=303,zp=304,ad=306,Bp=1e3,Mi=1001,Vp=1002,Sr=1003,Qy=1004,NL=1004,Rp=1005,CL=1005,wr=1006,ES=1007,RL=1007,pu=1008,IL=1008,to=1009,SM=1010,wM=1011,E0=1012,bS=1013,il=1014,Ja=1015,qh=1016,TS=1017,MS=1018,lu=1020,EM=1021,hs=1023,bM=1024,TM=1025,uu=1026,qc=1027,MM=1028,AS=1029,AM=1030,NS=1031,CS=1033,Py=33776,Ly=33777,ky=33778,Dy=33779,ix=35840,sx=35841,ax=35842,ox=35843,NM=36196,lx=37492,ux=37496,cx=37808,fx=37809,hx=37810,dx=37811,px=37812,mx=37813,gx=37814,yx=37815,vx=37816,_x=37817,xx=37818,Sx=37819,wx=37820,Ex=37821,Oy=36492,bx=36494,Tx=36495,CM=36283,Mx=36284,Ax=36285,Nx=36286,RM=2200,IM=2201,PM=2202,Hp=2300,$p=2301,Fy=2302,Dc=2400,Oc=2401,Gp=2402,b0=2500,RS=2501,PL=0,LL=1,kL=2,IS=3e3,cu=3001,LM=3200,kM=3201,wu=0,DM=1,Rs="",Hr="srgb",ro="srgb-linear",T0="display-p3",xm="display-p3-linear",Wp="linear",qn="srgb",jp="rec709",qp="p3",DL=0,Nc=7680,OL=7681,FL=7682,UL=7683,zL=34055,BL=34056,VL=5386,HL=512,$L=513,GL=514,WL=515,jL=516,qL=517,XL=518,Cx=519,OM=512,FM=513,UM=514,zM=515,BM=516,VM=517,HM=518,$M=519,Xp=35044,KL=35048,YL=35040,ZL=35045,JL=35049,QL=35041,ek=35046,tk=35050,nk=35042,rk="100",Rx="300 es",e0=1035,Qa=2e3,Kp=2001;let hl=class{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const n=this._listeners;n[e]===void 0&&(n[e]=[]),n[e].indexOf(t)===-1&&n[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;const n=this._listeners;return n[e]!==void 0&&n[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;const i=this._listeners[e];if(i!==void 0){const s=i.indexOf(t);s!==-1&&i.splice(s,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const n=this._listeners[e.type];if(n!==void 0){e.target=this;const i=n.slice(0);for(let s=0,a=i.length;s<a;s++)i[s].call(this,e);e.target=null}}};const wi=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let cE=1234567;const Vc=Math.PI/180,Xh=180/Math.PI;function Ps(){const r=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,n=Math.random()*4294967295|0;return(wi[r&255]+wi[r>>8&255]+wi[r>>16&255]+wi[r>>24&255]+"-"+wi[e&255]+wi[e>>8&255]+"-"+wi[e>>16&15|64]+wi[e>>24&255]+"-"+wi[t&63|128]+wi[t>>8&255]+"-"+wi[t>>16&255]+wi[t>>24&255]+wi[n&255]+wi[n>>8&255]+wi[n>>16&255]+wi[n>>24&255]).toLowerCase()}function mr(r,e,t){return Math.max(e,Math.min(t,r))}function PS(r,e){return(r%e+e)%e}function ik(r,e,t,n,i){return n+(r-e)*(i-n)/(t-e)}function sk(r,e,t){return r!==e?(t-r)/(e-r):0}function Ip(r,e,t){return(1-t)*r+t*e}function ak(r,e,t,n){return Ip(r,e,1-Math.exp(-t*n))}function ok(r,e=1){return e-Math.abs(PS(r,e*2)-e)}function lk(r,e,t){return r<=e?0:r>=t?1:(r=(r-e)/(t-e),r*r*(3-2*r))}function uk(r,e,t){return r<=e?0:r>=t?1:(r=(r-e)/(t-e),r*r*r*(r*(r*6-15)+10))}function ck(r,e){return r+Math.floor(Math.random()*(e-r+1))}function fk(r,e){return r+Math.random()*(e-r)}function hk(r){return r*(.5-Math.random())}function dk(r){r!==void 0&&(cE=r);let e=cE+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}function pk(r){return r*Vc}function mk(r){return r*Xh}function Ix(r){return(r&r-1)===0&&r!==0}function GM(r){return Math.pow(2,Math.ceil(Math.log(r)/Math.LN2))}function t0(r){return Math.pow(2,Math.floor(Math.log(r)/Math.LN2))}function gk(r,e,t,n,i){const s=Math.cos,a=Math.sin,o=s(t/2),u=a(t/2),h=s((e+n)/2),p=a((e+n)/2),m=s((e-n)/2),y=a((e-n)/2),v=s((n-e)/2),S=a((n-e)/2);switch(i){case"XYX":r.set(o*p,u*m,u*y,o*h);break;case"YZY":r.set(u*y,o*p,u*m,o*h);break;case"ZXZ":r.set(u*m,u*y,o*p,o*h);break;case"XZX":r.set(o*p,u*S,u*v,o*h);break;case"YXY":r.set(u*v,o*p,u*S,o*h);break;case"ZYZ":r.set(u*S,u*v,o*p,o*h);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}}function ds(r,e){switch(e.constructor){case Float32Array:return r;case Uint32Array:return r/4294967295;case Uint16Array:return r/65535;case Uint8Array:return r/255;case Int32Array:return Math.max(r/2147483647,-1);case Int16Array:return Math.max(r/32767,-1);case Int8Array:return Math.max(r/127,-1);default:throw new Error("Invalid component type.")}}function nn(r,e){switch(e.constructor){case Float32Array:return r;case Uint32Array:return Math.round(r*4294967295);case Uint16Array:return Math.round(r*65535);case Uint8Array:return Math.round(r*255);case Int32Array:return Math.round(r*2147483647);case Int16Array:return Math.round(r*32767);case Int8Array:return Math.round(r*127);default:throw new Error("Invalid component type.")}}const yk={DEG2RAD:Vc,RAD2DEG:Xh,generateUUID:Ps,clamp:mr,euclideanModulo:PS,mapLinear:ik,inverseLerp:sk,lerp:Ip,damp:ak,pingpong:ok,smoothstep:lk,smootherstep:uk,randInt:ck,randFloat:fk,randFloatSpread:hk,seededRandom:dk,degToRad:pk,radToDeg:mk,isPowerOfTwo:Ix,ceilPowerOfTwo:GM,floorPowerOfTwo:t0,setQuaternionFromProperEuler:gk,normalize:nn,denormalize:ds};class Pe{constructor(e=0,t=0){Pe.prototype.isVector2=!0,this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,n=this.y,i=e.elements;return this.x=i[0]*t+i[3]*n+i[6],this.y=i[1]*t+i[4]*n+i[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(mr(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y;return t*t+n*n}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const n=Math.cos(t),i=Math.sin(t),s=this.x-e.x,a=this.y-e.y;return this.x=s*n-a*i+e.x,this.y=s*i+a*n+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class rn{constructor(e,t,n,i,s,a,o,u,h){rn.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],e!==void 0&&this.set(e,t,n,i,s,a,o,u,h)}set(e,t,n,i,s,a,o,u,h){const p=this.elements;return p[0]=e,p[1]=i,p[2]=o,p[3]=t,p[4]=s,p[5]=u,p[6]=n,p[7]=a,p[8]=h,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],this}extractBasis(e,t,n){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,i=t.elements,s=this.elements,a=n[0],o=n[3],u=n[6],h=n[1],p=n[4],m=n[7],y=n[2],v=n[5],S=n[8],T=i[0],E=i[3],w=i[6],C=i[1],A=i[4],I=i[7],F=i[2],U=i[5],V=i[8];return s[0]=a*T+o*C+u*F,s[3]=a*E+o*A+u*U,s[6]=a*w+o*I+u*V,s[1]=h*T+p*C+m*F,s[4]=h*E+p*A+m*U,s[7]=h*w+p*I+m*V,s[2]=y*T+v*C+S*F,s[5]=y*E+v*A+S*U,s[8]=y*w+v*I+S*V,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[1],i=e[2],s=e[3],a=e[4],o=e[5],u=e[6],h=e[7],p=e[8];return t*a*p-t*o*h-n*s*p+n*o*u+i*s*h-i*a*u}invert(){const e=this.elements,t=e[0],n=e[1],i=e[2],s=e[3],a=e[4],o=e[5],u=e[6],h=e[7],p=e[8],m=p*a-o*h,y=o*u-p*s,v=h*s-a*u,S=t*m+n*y+i*v;if(S===0)return this.set(0,0,0,0,0,0,0,0,0);const T=1/S;return e[0]=m*T,e[1]=(i*h-p*n)*T,e[2]=(o*n-i*a)*T,e[3]=y*T,e[4]=(p*t-i*u)*T,e[5]=(i*s-o*t)*T,e[6]=v*T,e[7]=(n*u-h*t)*T,e[8]=(a*t-n*s)*T,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,n,i,s,a,o){const u=Math.cos(s),h=Math.sin(s);return this.set(n*u,n*h,-n*(u*a+h*o)+a+e,-i*h,i*u,-i*(-h*a+u*o)+o+t,0,0,1),this}scale(e,t){return this.premultiply(Xv.makeScale(e,t)),this}rotate(e){return this.premultiply(Xv.makeRotation(-e)),this}translate(e,t){return this.premultiply(Xv.makeTranslation(e,t)),this}makeTranslation(e,t){return e.isVector2?this.set(1,0,e.x,0,1,e.y,0,0,1):this.set(1,0,e,0,1,t,0,0,1),this}makeRotation(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,n,t,0,0,0,1),this}makeScale(e,t){return this.set(e,0,0,0,t,0,0,0,1),this}equals(e){const t=this.elements,n=e.elements;for(let i=0;i<9;i++)if(t[i]!==n[i])return!1;return!0}fromArray(e,t=0){for(let n=0;n<9;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e}clone(){return new this.constructor().fromArray(this.elements)}}const Xv=new rn;function WM(r){for(let e=r.length-1;e>=0;--e)if(r[e]>=65535)return!0;return!1}const vk={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function Oh(r,e){return new vk[r](e)}function Yp(r){return document.createElementNS("http://www.w3.org/1999/xhtml",r)}function jM(){const r=Yp("canvas");return r.style.display="block",r}const fE={};function Pp(r){r in fE||(fE[r]=!0,console.warn(r))}const hE=new rn().set(.8224621,.177538,0,.0331941,.9668058,0,.0170827,.0723974,.9105199),dE=new rn().set(1.2249401,-.2249404,0,-.0420569,1.0420571,0,-.0196376,-.0786361,1.0982735),Og={[ro]:{transfer:Wp,primaries:jp,toReference:r=>r,fromReference:r=>r},[Hr]:{transfer:qn,primaries:jp,toReference:r=>r.convertSRGBToLinear(),fromReference:r=>r.convertLinearToSRGB()},[xm]:{transfer:Wp,primaries:qp,toReference:r=>r.applyMatrix3(dE),fromReference:r=>r.applyMatrix3(hE)},[T0]:{transfer:qn,primaries:qp,toReference:r=>r.convertSRGBToLinear().applyMatrix3(dE),fromReference:r=>r.applyMatrix3(hE).convertLinearToSRGB()}},_k=new Set([ro,xm]),Nn={enabled:!0,_workingColorSpace:ro,get legacyMode(){return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),!this.enabled},set legacyMode(r){console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),this.enabled=!r},get workingColorSpace(){return this._workingColorSpace},set workingColorSpace(r){if(!_k.has(r))throw new Error(`Unsupported working color space, "${r}".`);this._workingColorSpace=r},convert:function(r,e,t){if(this.enabled===!1||e===t||!e||!t)return r;const n=Og[e].toReference,i=Og[t].fromReference;return i(n(r))},fromWorkingColorSpace:function(r,e){return this.convert(r,this._workingColorSpace,e)},toWorkingColorSpace:function(r,e){return this.convert(r,e,this._workingColorSpace)},getPrimaries:function(r){return Og[r].primaries},getTransfer:function(r){return r===Rs?Wp:Og[r].transfer}};function Vh(r){return r<.04045?r*.0773993808:Math.pow(r*.9478672986+.0521327014,2.4)}function Kv(r){return r<.0031308?r*12.92:1.055*Math.pow(r,.41666)-.055}let ch;class LS{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{ch===void 0&&(ch=Yp("canvas")),ch.width=e.width,ch.height=e.height;const n=ch.getContext("2d");e instanceof ImageData?n.putImageData(e,0,0):n.drawImage(e,0,0,e.width,e.height),t=ch}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}static sRGBToLinear(e){if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap){const t=Yp("canvas");t.width=e.width,t.height=e.height;const n=t.getContext("2d");n.drawImage(e,0,0,e.width,e.height);const i=n.getImageData(0,0,e.width,e.height),s=i.data;for(let a=0;a<s.length;a++)s[a]=Vh(s[a]/255)*255;return n.putImageData(i,0,0),t}else if(e.data){const t=e.data.slice(0);for(let n=0;n<t.length;n++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[n]=Math.floor(Vh(t[n]/255)*255):t[n]=Vh(t[n]);return{data:t,width:e.width,height:e.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}let xk=0;class Fc{constructor(e=null){this.isSource=!0,Object.defineProperty(this,"id",{value:xk++}),this.uuid=Ps(),this.data=e,this.version=0}set needsUpdate(e){e===!0&&this.version++}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.images[this.uuid]!==void 0)return e.images[this.uuid];const n={uuid:this.uuid,url:""},i=this.data;if(i!==null){let s;if(Array.isArray(i)){s=[];for(let a=0,o=i.length;a<o;a++)i[a].isDataTexture?s.push(Yv(i[a].image)):s.push(Yv(i[a]))}else s=Yv(i);n.url=s}return t||(e.images[this.uuid]=n),n}}function Yv(r){return typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&r instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&r instanceof ImageBitmap?LS.getDataURL(r):r.data?{data:Array.from(r.data),width:r.width,height:r.height,type:r.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let Sk=0;class br extends hl{constructor(e=br.DEFAULT_IMAGE,t=br.DEFAULT_MAPPING,n=Mi,i=Mi,s=wr,a=pu,o=hs,u=to,h=br.DEFAULT_ANISOTROPY,p=Rs){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:Sk++}),this.uuid=Ps(),this.name="",this.source=new Fc(e),this.mipmaps=[],this.mapping=t,this.channel=0,this.wrapS=n,this.wrapT=i,this.magFilter=s,this.minFilter=a,this.anisotropy=h,this.format=o,this.internalFormat=null,this.type=u,this.offset=new Pe(0,0),this.repeat=new Pe(1,1),this.center=new Pe(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new rn,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,typeof p=="string"?this.colorSpace=p:(Pp("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace=p===cu?Hr:Rs),this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(e=null){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.channel=e.channel,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.colorSpace=e.colorSpace,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const n={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(n.userData=this.userData),t||(e.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==w0)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case Bp:e.x=e.x-Math.floor(e.x);break;case Mi:e.x=e.x<0?0:1;break;case Vp:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case Bp:e.y=e.y-Math.floor(e.y);break;case Mi:e.y=e.y<0?0:1;break;case Vp:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}get encoding(){return Pp("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace===Hr?cu:IS}set encoding(e){Pp("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace=e===cu?Hr:Rs}}br.DEFAULT_IMAGE=null;br.DEFAULT_MAPPING=w0;br.DEFAULT_ANISOTROPY=1;class Cn{constructor(e=0,t=0,n=0,i=1){Cn.prototype.isVector4=!0,this.x=e,this.y=t,this.z=n,this.w=i}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,n,i){return this.x=e,this.y=t,this.z=n,this.w=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,n=this.y,i=this.z,s=this.w,a=e.elements;return this.x=a[0]*t+a[4]*n+a[8]*i+a[12]*s,this.y=a[1]*t+a[5]*n+a[9]*i+a[13]*s,this.z=a[2]*t+a[6]*n+a[10]*i+a[14]*s,this.w=a[3]*t+a[7]*n+a[11]*i+a[15]*s,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,n,i,s;const u=e.elements,h=u[0],p=u[4],m=u[8],y=u[1],v=u[5],S=u[9],T=u[2],E=u[6],w=u[10];if(Math.abs(p-y)<.01&&Math.abs(m-T)<.01&&Math.abs(S-E)<.01){if(Math.abs(p+y)<.1&&Math.abs(m+T)<.1&&Math.abs(S+E)<.1&&Math.abs(h+v+w-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const A=(h+1)/2,I=(v+1)/2,F=(w+1)/2,U=(p+y)/4,V=(m+T)/4,G=(S+E)/4;return A>I&&A>F?A<.01?(n=0,i=.707106781,s=.707106781):(n=Math.sqrt(A),i=U/n,s=V/n):I>F?I<.01?(n=.707106781,i=0,s=.707106781):(i=Math.sqrt(I),n=U/i,s=G/i):F<.01?(n=.707106781,i=.707106781,s=0):(s=Math.sqrt(F),n=V/s,i=G/s),this.set(n,i,s,t),this}let C=Math.sqrt((E-S)*(E-S)+(m-T)*(m-T)+(y-p)*(y-p));return Math.abs(C)<.001&&(C=1),this.x=(E-S)/C,this.y=(m-T)/C,this.z=(y-p)/C,this.w=Math.acos((h+v+w-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this.w=e.w+(t.w-e.w)*n,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class qM extends hl{constructor(e=1,t=1,n={}){super(),this.isRenderTarget=!0,this.width=e,this.height=t,this.depth=1,this.scissor=new Cn(0,0,e,t),this.scissorTest=!1,this.viewport=new Cn(0,0,e,t);const i={width:e,height:t,depth:1};n.encoding!==void 0&&(Pp("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."),n.colorSpace=n.encoding===cu?Hr:Rs),n=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:wr,depthBuffer:!0,stencilBuffer:!1,depthTexture:null,samples:0},n),this.texture=new br(i,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=n.generateMipmaps,this.texture.internalFormat=n.internalFormat,this.depthBuffer=n.depthBuffer,this.stencilBuffer=n.stencilBuffer,this.depthTexture=n.depthTexture,this.samples=n.samples}setSize(e,t,n=1){(this.width!==e||this.height!==t||this.depth!==n)&&(this.width=e,this.height=t,this.depth=n,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.scissor.copy(e.scissor),this.scissorTest=e.scissorTest,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.texture.isRenderTargetTexture=!0;const t=Object.assign({},e.texture.image);return this.texture.source=new Fc(t),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class Ca extends qM{constructor(e=1,t=1,n={}){super(e,t,n),this.isWebGLRenderTarget=!0}}class M0 extends br{constructor(e=null,t=1,n=1,i=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:t,height:n,depth:i},this.magFilter=Sr,this.minFilter=Sr,this.wrapR=Mi,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class wk extends Ca{constructor(e=1,t=1,n=1){super(e,t),this.isWebGLArrayRenderTarget=!0,this.depth=n,this.texture=new M0(null,e,t,n),this.texture.isRenderTargetTexture=!0}}class kS extends br{constructor(e=null,t=1,n=1,i=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:t,height:n,depth:i},this.magFilter=Sr,this.minFilter=Sr,this.wrapR=Mi,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Ek extends Ca{constructor(e=1,t=1,n=1){super(e,t),this.isWebGL3DRenderTarget=!0,this.depth=n,this.texture=new kS(null,e,t,n),this.texture.isRenderTargetTexture=!0}}class bk extends Ca{constructor(e=1,t=1,n=1,i={}){super(e,t,i),this.isWebGLMultipleRenderTargets=!0;const s=this.texture;this.texture=[];for(let a=0;a<n;a++)this.texture[a]=s.clone(),this.texture[a].isRenderTargetTexture=!0}setSize(e,t,n=1){if(this.width!==e||this.height!==t||this.depth!==n){this.width=e,this.height=t,this.depth=n;for(let i=0,s=this.texture.length;i<s;i++)this.texture[i].image.width=e,this.texture[i].image.height=t,this.texture[i].image.depth=n;this.dispose()}this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}copy(e){this.dispose(),this.width=e.width,this.height=e.height,this.depth=e.depth,this.scissor.copy(e.scissor),this.scissorTest=e.scissorTest,this.viewport.copy(e.viewport),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.texture.length=0;for(let t=0,n=e.texture.length;t<n;t++)this.texture[t]=e.texture[t].clone(),this.texture[t].isRenderTargetTexture=!0;return this}}class Ni{constructor(e=0,t=0,n=0,i=1){this.isQuaternion=!0,this._x=e,this._y=t,this._z=n,this._w=i}static slerpFlat(e,t,n,i,s,a,o){let u=n[i+0],h=n[i+1],p=n[i+2],m=n[i+3];const y=s[a+0],v=s[a+1],S=s[a+2],T=s[a+3];if(o===0){e[t+0]=u,e[t+1]=h,e[t+2]=p,e[t+3]=m;return}if(o===1){e[t+0]=y,e[t+1]=v,e[t+2]=S,e[t+3]=T;return}if(m!==T||u!==y||h!==v||p!==S){let E=1-o;const w=u*y+h*v+p*S+m*T,C=w>=0?1:-1,A=1-w*w;if(A>Number.EPSILON){const F=Math.sqrt(A),U=Math.atan2(F,w*C);E=Math.sin(E*U)/F,o=Math.sin(o*U)/F}const I=o*C;if(u=u*E+y*I,h=h*E+v*I,p=p*E+S*I,m=m*E+T*I,E===1-o){const F=1/Math.sqrt(u*u+h*h+p*p+m*m);u*=F,h*=F,p*=F,m*=F}}e[t]=u,e[t+1]=h,e[t+2]=p,e[t+3]=m}static multiplyQuaternionsFlat(e,t,n,i,s,a){const o=n[i],u=n[i+1],h=n[i+2],p=n[i+3],m=s[a],y=s[a+1],v=s[a+2],S=s[a+3];return e[t]=o*S+p*m+u*v-h*y,e[t+1]=u*S+p*y+h*m-o*v,e[t+2]=h*S+p*v+o*y-u*m,e[t+3]=p*S-o*m-u*y-h*v,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,n,i){return this._x=e,this._y=t,this._z=n,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){const n=e._x,i=e._y,s=e._z,a=e._order,o=Math.cos,u=Math.sin,h=o(n/2),p=o(i/2),m=o(s/2),y=u(n/2),v=u(i/2),S=u(s/2);switch(a){case"XYZ":this._x=y*p*m+h*v*S,this._y=h*v*m-y*p*S,this._z=h*p*S+y*v*m,this._w=h*p*m-y*v*S;break;case"YXZ":this._x=y*p*m+h*v*S,this._y=h*v*m-y*p*S,this._z=h*p*S-y*v*m,this._w=h*p*m+y*v*S;break;case"ZXY":this._x=y*p*m-h*v*S,this._y=h*v*m+y*p*S,this._z=h*p*S+y*v*m,this._w=h*p*m-y*v*S;break;case"ZYX":this._x=y*p*m-h*v*S,this._y=h*v*m+y*p*S,this._z=h*p*S-y*v*m,this._w=h*p*m+y*v*S;break;case"YZX":this._x=y*p*m+h*v*S,this._y=h*v*m+y*p*S,this._z=h*p*S-y*v*m,this._w=h*p*m-y*v*S;break;case"XZY":this._x=y*p*m-h*v*S,this._y=h*v*m-y*p*S,this._z=h*p*S+y*v*m,this._w=h*p*m+y*v*S;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+a)}return t!==!1&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const n=t/2,i=Math.sin(n);return this._x=e.x*i,this._y=e.y*i,this._z=e.z*i,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,n=t[0],i=t[4],s=t[8],a=t[1],o=t[5],u=t[9],h=t[2],p=t[6],m=t[10],y=n+o+m;if(y>0){const v=.5/Math.sqrt(y+1);this._w=.25/v,this._x=(p-u)*v,this._y=(s-h)*v,this._z=(a-i)*v}else if(n>o&&n>m){const v=2*Math.sqrt(1+n-o-m);this._w=(p-u)/v,this._x=.25*v,this._y=(i+a)/v,this._z=(s+h)/v}else if(o>m){const v=2*Math.sqrt(1+o-n-m);this._w=(s-h)/v,this._x=(i+a)/v,this._y=.25*v,this._z=(u+p)/v}else{const v=2*Math.sqrt(1+m-n-o);this._w=(a-i)/v,this._x=(s+h)/v,this._y=(u+p)/v,this._z=.25*v}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let n=e.dot(t)+1;return n<Number.EPSILON?(n=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=n):(this._x=0,this._y=-e.z,this._z=e.y,this._w=n)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=n),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(mr(this.dot(e),-1,1)))}rotateTowards(e,t){const n=this.angleTo(e);if(n===0)return this;const i=Math.min(1,t/n);return this.slerp(e,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e){return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const n=e._x,i=e._y,s=e._z,a=e._w,o=t._x,u=t._y,h=t._z,p=t._w;return this._x=n*p+a*o+i*h-s*u,this._y=i*p+a*u+s*o-n*h,this._z=s*p+a*h+n*u-i*o,this._w=a*p-n*o-i*u-s*h,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const n=this._x,i=this._y,s=this._z,a=this._w;let o=a*e._w+n*e._x+i*e._y+s*e._z;if(o<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,o=-o):this.copy(e),o>=1)return this._w=a,this._x=n,this._y=i,this._z=s,this;const u=1-o*o;if(u<=Number.EPSILON){const v=1-t;return this._w=v*a+t*this._w,this._x=v*n+t*this._x,this._y=v*i+t*this._y,this._z=v*s+t*this._z,this.normalize(),this._onChangeCallback(),this}const h=Math.sqrt(u),p=Math.atan2(h,o),m=Math.sin((1-t)*p)/h,y=Math.sin(t*p)/h;return this._w=a*m+this._w*y,this._x=n*m+this._x*y,this._y=i*m+this._y*y,this._z=s*m+this._z*y,this._onChangeCallback(),this}slerpQuaternions(e,t,n){return this.copy(e).slerp(t,n)}random(){const e=Math.random(),t=Math.sqrt(1-e),n=Math.sqrt(e),i=2*Math.PI*Math.random(),s=2*Math.PI*Math.random();return this.set(t*Math.cos(i),n*Math.sin(s),n*Math.cos(s),t*Math.sin(i))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}toJSON(){return this.toArray()}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class X{constructor(e=0,t=0,n=0){X.prototype.isVector3=!0,this.x=e,this.y=t,this.z=n}set(e,t,n){return n===void 0&&(n=this.z),this.x=e,this.y=t,this.z=n,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return this.applyQuaternion(pE.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(pE.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,n=this.y,i=this.z,s=e.elements;return this.x=s[0]*t+s[3]*n+s[6]*i,this.y=s[1]*t+s[4]*n+s[7]*i,this.z=s[2]*t+s[5]*n+s[8]*i,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,n=this.y,i=this.z,s=e.elements,a=1/(s[3]*t+s[7]*n+s[11]*i+s[15]);return this.x=(s[0]*t+s[4]*n+s[8]*i+s[12])*a,this.y=(s[1]*t+s[5]*n+s[9]*i+s[13])*a,this.z=(s[2]*t+s[6]*n+s[10]*i+s[14])*a,this}applyQuaternion(e){const t=this.x,n=this.y,i=this.z,s=e.x,a=e.y,o=e.z,u=e.w,h=2*(a*i-o*n),p=2*(o*t-s*i),m=2*(s*n-a*t);return this.x=t+u*h+a*m-o*p,this.y=n+u*p+o*h-s*m,this.z=i+u*m+s*p-a*h,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,n=this.y,i=this.z,s=e.elements;return this.x=s[0]*t+s[4]*n+s[8]*i,this.y=s[1]*t+s[5]*n+s[9]*i,this.z=s[2]*t+s[6]*n+s[10]*i,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this}cross(e){return this.crossVectors(this,e)}crossVectors(e,t){const n=e.x,i=e.y,s=e.z,a=t.x,o=t.y,u=t.z;return this.x=i*u-s*o,this.y=s*a-n*u,this.z=n*o-i*a,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const n=e.dot(this)/t;return this.copy(e).multiplyScalar(n)}projectOnPlane(e){return Zv.copy(this).projectOnVector(e),this.sub(Zv)}reflect(e){return this.sub(Zv.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(mr(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y,i=this.z-e.z;return t*t+n*n+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,n){const i=Math.sin(t)*e;return this.x=i*Math.sin(n),this.y=Math.cos(t)*e,this.z=i*Math.cos(n),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,n){return this.x=e*Math.sin(t),this.y=n,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),n=this.setFromMatrixColumn(e,1).length(),i=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=n,this.z=i,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}setFromColor(e){return this.x=e.r,this.y=e.g,this.z=e.b,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=(Math.random()-.5)*2,t=Math.random()*Math.PI*2,n=Math.sqrt(1-e**2);return this.x=n*Math.cos(t),this.y=n*Math.sin(t),this.z=e,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const Zv=new X,pE=new Ni;class co{constructor(e=new X(1/0,1/0,1/0),t=new X(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t+=3)this.expandByPoint(xa.fromArray(e,t));return this}setFromBufferAttribute(e){this.makeEmpty();for(let t=0,n=e.count;t<n;t++)this.expandByPoint(xa.fromBufferAttribute(e,t));return this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=xa.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){e.updateWorldMatrix(!1,!1);const n=e.geometry;if(n!==void 0){const s=n.getAttribute("position");if(t===!0&&s!==void 0&&e.isInstancedMesh!==!0)for(let a=0,o=s.count;a<o;a++)e.isMesh===!0?e.getVertexPosition(a,xa):xa.fromBufferAttribute(s,a),xa.applyMatrix4(e.matrixWorld),this.expandByPoint(xa);else e.boundingBox!==void 0?(e.boundingBox===null&&e.computeBoundingBox(),Fg.copy(e.boundingBox)):(n.boundingBox===null&&n.computeBoundingBox(),Fg.copy(n.boundingBox)),Fg.applyMatrix4(e.matrixWorld),this.union(Fg)}const i=e.children;for(let s=0,a=i.length;s<a;s++)this.expandByObject(i[s],t);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,xa),xa.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,n;return e.normal.x>0?(t=e.normal.x*this.min.x,n=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,n=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,n+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,n+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,n+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,n+=e.normal.z*this.min.z),t<=-e.constant&&n>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(cp),Ug.subVectors(this.max,cp),fh.subVectors(e.a,cp),hh.subVectors(e.b,cp),dh.subVectors(e.c,cp),Kl.subVectors(hh,fh),Yl.subVectors(dh,hh),gc.subVectors(fh,dh);let t=[0,-Kl.z,Kl.y,0,-Yl.z,Yl.y,0,-gc.z,gc.y,Kl.z,0,-Kl.x,Yl.z,0,-Yl.x,gc.z,0,-gc.x,-Kl.y,Kl.x,0,-Yl.y,Yl.x,0,-gc.y,gc.x,0];return!Jv(t,fh,hh,dh,Ug)||(t=[1,0,0,0,1,0,0,0,1],!Jv(t,fh,hh,dh,Ug))?!1:(zg.crossVectors(Kl,Yl),t=[zg.x,zg.y,zg.z],Jv(t,fh,hh,dh,Ug))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,xa).distanceTo(e)}getBoundingSphere(e){return this.isEmpty()?e.makeEmpty():(this.getCenter(e.center),e.radius=this.getSize(xa).length()*.5),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(Wo[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),Wo[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),Wo[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),Wo[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),Wo[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),Wo[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),Wo[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),Wo[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(Wo),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const Wo=[new X,new X,new X,new X,new X,new X,new X,new X],xa=new X,Fg=new co,fh=new X,hh=new X,dh=new X,Kl=new X,Yl=new X,gc=new X,cp=new X,Ug=new X,zg=new X,yc=new X;function Jv(r,e,t,n,i){for(let s=0,a=r.length-3;s<=a;s+=3){yc.fromArray(r,s);const o=i.x*Math.abs(yc.x)+i.y*Math.abs(yc.y)+i.z*Math.abs(yc.z),u=e.dot(yc),h=t.dot(yc),p=n.dot(yc);if(Math.max(-Math.max(u,h,p),Math.min(u,h,p))>o)return!1}return!0}const Tk=new co,fp=new X,Qv=new X;class Ia{constructor(e=new X,t=-1){this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const n=this.center;t!==void 0?n.copy(t):Tk.setFromPoints(e).getCenter(n);let i=0;for(let s=0,a=e.length;s<a;s++)i=Math.max(i,n.distanceToSquared(e[s]));return this.radius=Math.sqrt(i),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const n=this.center.distanceToSquared(e);return t.copy(e),n>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){if(this.isEmpty())return this.center.copy(e),this.radius=0,this;fp.subVectors(e,this.center);const t=fp.lengthSq();if(t>this.radius*this.radius){const n=Math.sqrt(t),i=(n-this.radius)*.5;this.center.addScaledVector(fp,i/n),this.radius+=i}return this}union(e){return e.isEmpty()?this:this.isEmpty()?(this.copy(e),this):(this.center.equals(e.center)===!0?this.radius=Math.max(this.radius,e.radius):(Qv.subVectors(e.center,this.center).setLength(e.radius),this.expandByPoint(fp.copy(e.center).add(Qv)),this.expandByPoint(fp.copy(e.center).sub(Qv))),this)}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}const jo=new X,e_=new X,Bg=new X,Zl=new X,t_=new X,Vg=new X,n_=new X;class sf{constructor(e=new X,t=new X(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.origin).addScaledVector(this.direction,e)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,jo)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const n=t.dot(this.direction);return n<0?t.copy(this.origin):t.copy(this.origin).addScaledVector(this.direction,n)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=jo.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(jo.copy(this.origin).addScaledVector(this.direction,t),jo.distanceToSquared(e))}distanceSqToSegment(e,t,n,i){e_.copy(e).add(t).multiplyScalar(.5),Bg.copy(t).sub(e).normalize(),Zl.copy(this.origin).sub(e_);const s=e.distanceTo(t)*.5,a=-this.direction.dot(Bg),o=Zl.dot(this.direction),u=-Zl.dot(Bg),h=Zl.lengthSq(),p=Math.abs(1-a*a);let m,y,v,S;if(p>0)if(m=a*u-o,y=a*o-u,S=s*p,m>=0)if(y>=-S)if(y<=S){const T=1/p;m*=T,y*=T,v=m*(m+a*y+2*o)+y*(a*m+y+2*u)+h}else y=s,m=Math.max(0,-(a*y+o)),v=-m*m+y*(y+2*u)+h;else y=-s,m=Math.max(0,-(a*y+o)),v=-m*m+y*(y+2*u)+h;else y<=-S?(m=Math.max(0,-(-a*s+o)),y=m>0?-s:Math.min(Math.max(-s,-u),s),v=-m*m+y*(y+2*u)+h):y<=S?(m=0,y=Math.min(Math.max(-s,-u),s),v=y*(y+2*u)+h):(m=Math.max(0,-(a*s+o)),y=m>0?s:Math.min(Math.max(-s,-u),s),v=-m*m+y*(y+2*u)+h);else y=a>0?-s:s,m=Math.max(0,-(a*y+o)),v=-m*m+y*(y+2*u)+h;return n&&n.copy(this.origin).addScaledVector(this.direction,m),i&&i.copy(e_).addScaledVector(Bg,y),v}intersectSphere(e,t){jo.subVectors(e.center,this.origin);const n=jo.dot(this.direction),i=jo.dot(jo)-n*n,s=e.radius*e.radius;if(i>s)return null;const a=Math.sqrt(s-i),o=n-a,u=n+a;return u<0?null:o<0?this.at(u,t):this.at(o,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const n=-(this.origin.dot(e.normal)+e.constant)/t;return n>=0?n:null}intersectPlane(e,t){const n=this.distanceToPlane(e);return n===null?null:this.at(n,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let n,i,s,a,o,u;const h=1/this.direction.x,p=1/this.direction.y,m=1/this.direction.z,y=this.origin;return h>=0?(n=(e.min.x-y.x)*h,i=(e.max.x-y.x)*h):(n=(e.max.x-y.x)*h,i=(e.min.x-y.x)*h),p>=0?(s=(e.min.y-y.y)*p,a=(e.max.y-y.y)*p):(s=(e.max.y-y.y)*p,a=(e.min.y-y.y)*p),n>a||s>i||((s>n||isNaN(n))&&(n=s),(a<i||isNaN(i))&&(i=a),m>=0?(o=(e.min.z-y.z)*m,u=(e.max.z-y.z)*m):(o=(e.max.z-y.z)*m,u=(e.min.z-y.z)*m),n>u||o>i)||((o>n||n!==n)&&(n=o),(u<i||i!==i)&&(i=u),i<0)?null:this.at(n>=0?n:i,t)}intersectsBox(e){return this.intersectBox(e,jo)!==null}intersectTriangle(e,t,n,i,s){t_.subVectors(t,e),Vg.subVectors(n,e),n_.crossVectors(t_,Vg);let a=this.direction.dot(n_),o;if(a>0){if(i)return null;o=1}else if(a<0)o=-1,a=-a;else return null;Zl.subVectors(this.origin,e);const u=o*this.direction.dot(Vg.crossVectors(Zl,Vg));if(u<0)return null;const h=o*this.direction.dot(t_.cross(Zl));if(h<0||u+h>a)return null;const p=-o*Zl.dot(n_);return p<0?null:this.at(p/a,s)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class Jt{constructor(e,t,n,i,s,a,o,u,h,p,m,y,v,S,T,E){Jt.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],e!==void 0&&this.set(e,t,n,i,s,a,o,u,h,p,m,y,v,S,T,E)}set(e,t,n,i,s,a,o,u,h,p,m,y,v,S,T,E){const w=this.elements;return w[0]=e,w[4]=t,w[8]=n,w[12]=i,w[1]=s,w[5]=a,w[9]=o,w[13]=u,w[2]=h,w[6]=p,w[10]=m,w[14]=y,w[3]=v,w[7]=S,w[11]=T,w[15]=E,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Jt().fromArray(this.elements)}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],this}copyPosition(e){const t=this.elements,n=e.elements;return t[12]=n[12],t[13]=n[13],t[14]=n[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,n){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(e,t,n){return this.set(e.x,t.x,n.x,0,e.y,t.y,n.y,0,e.z,t.z,n.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,n=e.elements,i=1/ph.setFromMatrixColumn(e,0).length(),s=1/ph.setFromMatrixColumn(e,1).length(),a=1/ph.setFromMatrixColumn(e,2).length();return t[0]=n[0]*i,t[1]=n[1]*i,t[2]=n[2]*i,t[3]=0,t[4]=n[4]*s,t[5]=n[5]*s,t[6]=n[6]*s,t[7]=0,t[8]=n[8]*a,t[9]=n[9]*a,t[10]=n[10]*a,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){const t=this.elements,n=e.x,i=e.y,s=e.z,a=Math.cos(n),o=Math.sin(n),u=Math.cos(i),h=Math.sin(i),p=Math.cos(s),m=Math.sin(s);if(e.order==="XYZ"){const y=a*p,v=a*m,S=o*p,T=o*m;t[0]=u*p,t[4]=-u*m,t[8]=h,t[1]=v+S*h,t[5]=y-T*h,t[9]=-o*u,t[2]=T-y*h,t[6]=S+v*h,t[10]=a*u}else if(e.order==="YXZ"){const y=u*p,v=u*m,S=h*p,T=h*m;t[0]=y+T*o,t[4]=S*o-v,t[8]=a*h,t[1]=a*m,t[5]=a*p,t[9]=-o,t[2]=v*o-S,t[6]=T+y*o,t[10]=a*u}else if(e.order==="ZXY"){const y=u*p,v=u*m,S=h*p,T=h*m;t[0]=y-T*o,t[4]=-a*m,t[8]=S+v*o,t[1]=v+S*o,t[5]=a*p,t[9]=T-y*o,t[2]=-a*h,t[6]=o,t[10]=a*u}else if(e.order==="ZYX"){const y=a*p,v=a*m,S=o*p,T=o*m;t[0]=u*p,t[4]=S*h-v,t[8]=y*h+T,t[1]=u*m,t[5]=T*h+y,t[9]=v*h-S,t[2]=-h,t[6]=o*u,t[10]=a*u}else if(e.order==="YZX"){const y=a*u,v=a*h,S=o*u,T=o*h;t[0]=u*p,t[4]=T-y*m,t[8]=S*m+v,t[1]=m,t[5]=a*p,t[9]=-o*p,t[2]=-h*p,t[6]=v*m+S,t[10]=y-T*m}else if(e.order==="XZY"){const y=a*u,v=a*h,S=o*u,T=o*h;t[0]=u*p,t[4]=-m,t[8]=h*p,t[1]=y*m+T,t[5]=a*p,t[9]=v*m-S,t[2]=S*m-v,t[6]=o*p,t[10]=T*m+y}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(Mk,e,Ak)}lookAt(e,t,n){const i=this.elements;return Ns.subVectors(e,t),Ns.lengthSq()===0&&(Ns.z=1),Ns.normalize(),Jl.crossVectors(n,Ns),Jl.lengthSq()===0&&(Math.abs(n.z)===1?Ns.x+=1e-4:Ns.z+=1e-4,Ns.normalize(),Jl.crossVectors(n,Ns)),Jl.normalize(),Hg.crossVectors(Ns,Jl),i[0]=Jl.x,i[4]=Hg.x,i[8]=Ns.x,i[1]=Jl.y,i[5]=Hg.y,i[9]=Ns.y,i[2]=Jl.z,i[6]=Hg.z,i[10]=Ns.z,this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,i=t.elements,s=this.elements,a=n[0],o=n[4],u=n[8],h=n[12],p=n[1],m=n[5],y=n[9],v=n[13],S=n[2],T=n[6],E=n[10],w=n[14],C=n[3],A=n[7],I=n[11],F=n[15],U=i[0],V=i[4],G=i[8],L=i[12],k=i[1],O=i[5],Q=i[9],le=i[13],K=i[2],ce=i[6],de=i[10],me=i[14],Z=i[3],re=i[7],ee=i[11],z=i[15];return s[0]=a*U+o*k+u*K+h*Z,s[4]=a*V+o*O+u*ce+h*re,s[8]=a*G+o*Q+u*de+h*ee,s[12]=a*L+o*le+u*me+h*z,s[1]=p*U+m*k+y*K+v*Z,s[5]=p*V+m*O+y*ce+v*re,s[9]=p*G+m*Q+y*de+v*ee,s[13]=p*L+m*le+y*me+v*z,s[2]=S*U+T*k+E*K+w*Z,s[6]=S*V+T*O+E*ce+w*re,s[10]=S*G+T*Q+E*de+w*ee,s[14]=S*L+T*le+E*me+w*z,s[3]=C*U+A*k+I*K+F*Z,s[7]=C*V+A*O+I*ce+F*re,s[11]=C*G+A*Q+I*de+F*ee,s[15]=C*L+A*le+I*me+F*z,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[4],i=e[8],s=e[12],a=e[1],o=e[5],u=e[9],h=e[13],p=e[2],m=e[6],y=e[10],v=e[14],S=e[3],T=e[7],E=e[11],w=e[15];return S*(+s*u*m-i*h*m-s*o*y+n*h*y+i*o*v-n*u*v)+T*(+t*u*v-t*h*y+s*a*y-i*a*v+i*h*p-s*u*p)+E*(+t*h*m-t*o*v-s*a*m+n*a*v+s*o*p-n*h*p)+w*(-i*o*p-t*u*m+t*o*y+i*a*m-n*a*y+n*u*p)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,n){const i=this.elements;return e.isVector3?(i[12]=e.x,i[13]=e.y,i[14]=e.z):(i[12]=e,i[13]=t,i[14]=n),this}invert(){const e=this.elements,t=e[0],n=e[1],i=e[2],s=e[3],a=e[4],o=e[5],u=e[6],h=e[7],p=e[8],m=e[9],y=e[10],v=e[11],S=e[12],T=e[13],E=e[14],w=e[15],C=m*E*h-T*y*h+T*u*v-o*E*v-m*u*w+o*y*w,A=S*y*h-p*E*h-S*u*v+a*E*v+p*u*w-a*y*w,I=p*T*h-S*m*h+S*o*v-a*T*v-p*o*w+a*m*w,F=S*m*u-p*T*u-S*o*y+a*T*y+p*o*E-a*m*E,U=t*C+n*A+i*I+s*F;if(U===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const V=1/U;return e[0]=C*V,e[1]=(T*y*s-m*E*s-T*i*v+n*E*v+m*i*w-n*y*w)*V,e[2]=(o*E*s-T*u*s+T*i*h-n*E*h-o*i*w+n*u*w)*V,e[3]=(m*u*s-o*y*s-m*i*h+n*y*h+o*i*v-n*u*v)*V,e[4]=A*V,e[5]=(p*E*s-S*y*s+S*i*v-t*E*v-p*i*w+t*y*w)*V,e[6]=(S*u*s-a*E*s-S*i*h+t*E*h+a*i*w-t*u*w)*V,e[7]=(a*y*s-p*u*s+p*i*h-t*y*h-a*i*v+t*u*v)*V,e[8]=I*V,e[9]=(S*m*s-p*T*s-S*n*v+t*T*v+p*n*w-t*m*w)*V,e[10]=(a*T*s-S*o*s+S*n*h-t*T*h-a*n*w+t*o*w)*V,e[11]=(p*o*s-a*m*s-p*n*h+t*m*h+a*n*v-t*o*v)*V,e[12]=F*V,e[13]=(p*T*i-S*m*i+S*n*y-t*T*y-p*n*E+t*m*E)*V,e[14]=(S*o*i-a*T*i-S*n*u+t*T*u+a*n*E-t*o*E)*V,e[15]=(a*m*i-p*o*i+p*n*u-t*m*u-a*n*y+t*o*y)*V,this}scale(e){const t=this.elements,n=e.x,i=e.y,s=e.z;return t[0]*=n,t[4]*=i,t[8]*=s,t[1]*=n,t[5]*=i,t[9]*=s,t[2]*=n,t[6]*=i,t[10]*=s,t[3]*=n,t[7]*=i,t[11]*=s,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],n=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],i=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,n,i))}makeTranslation(e,t,n){return e.isVector3?this.set(1,0,0,e.x,0,1,0,e.y,0,0,1,e.z,0,0,0,1):this.set(1,0,0,e,0,1,0,t,0,0,1,n,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),n=Math.sin(e);return this.set(1,0,0,0,0,t,-n,0,0,n,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,0,n,0,0,1,0,0,-n,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,0,n,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const n=Math.cos(t),i=Math.sin(t),s=1-n,a=e.x,o=e.y,u=e.z,h=s*a,p=s*o;return this.set(h*a+n,h*o-i*u,h*u+i*o,0,h*o+i*u,p*o+n,p*u-i*a,0,h*u-i*o,p*u+i*a,s*u*u+n,0,0,0,0,1),this}makeScale(e,t,n){return this.set(e,0,0,0,0,t,0,0,0,0,n,0,0,0,0,1),this}makeShear(e,t,n,i,s,a){return this.set(1,n,s,0,e,1,a,0,t,i,1,0,0,0,0,1),this}compose(e,t,n){const i=this.elements,s=t._x,a=t._y,o=t._z,u=t._w,h=s+s,p=a+a,m=o+o,y=s*h,v=s*p,S=s*m,T=a*p,E=a*m,w=o*m,C=u*h,A=u*p,I=u*m,F=n.x,U=n.y,V=n.z;return i[0]=(1-(T+w))*F,i[1]=(v+I)*F,i[2]=(S-A)*F,i[3]=0,i[4]=(v-I)*U,i[5]=(1-(y+w))*U,i[6]=(E+C)*U,i[7]=0,i[8]=(S+A)*V,i[9]=(E-C)*V,i[10]=(1-(y+T))*V,i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1,this}decompose(e,t,n){const i=this.elements;let s=ph.set(i[0],i[1],i[2]).length();const a=ph.set(i[4],i[5],i[6]).length(),o=ph.set(i[8],i[9],i[10]).length();this.determinant()<0&&(s=-s),e.x=i[12],e.y=i[13],e.z=i[14],Sa.copy(this);const h=1/s,p=1/a,m=1/o;return Sa.elements[0]*=h,Sa.elements[1]*=h,Sa.elements[2]*=h,Sa.elements[4]*=p,Sa.elements[5]*=p,Sa.elements[6]*=p,Sa.elements[8]*=m,Sa.elements[9]*=m,Sa.elements[10]*=m,t.setFromRotationMatrix(Sa),n.x=s,n.y=a,n.z=o,this}makePerspective(e,t,n,i,s,a,o=Qa){const u=this.elements,h=2*s/(t-e),p=2*s/(n-i),m=(t+e)/(t-e),y=(n+i)/(n-i);let v,S;if(o===Qa)v=-(a+s)/(a-s),S=-2*a*s/(a-s);else if(o===Kp)v=-a/(a-s),S=-a*s/(a-s);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+o);return u[0]=h,u[4]=0,u[8]=m,u[12]=0,u[1]=0,u[5]=p,u[9]=y,u[13]=0,u[2]=0,u[6]=0,u[10]=v,u[14]=S,u[3]=0,u[7]=0,u[11]=-1,u[15]=0,this}makeOrthographic(e,t,n,i,s,a,o=Qa){const u=this.elements,h=1/(t-e),p=1/(n-i),m=1/(a-s),y=(t+e)*h,v=(n+i)*p;let S,T;if(o===Qa)S=(a+s)*m,T=-2*m;else if(o===Kp)S=s*m,T=-1*m;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+o);return u[0]=2*h,u[4]=0,u[8]=0,u[12]=-y,u[1]=0,u[5]=2*p,u[9]=0,u[13]=-v,u[2]=0,u[6]=0,u[10]=T,u[14]=-S,u[3]=0,u[7]=0,u[11]=0,u[15]=1,this}equals(e){const t=this.elements,n=e.elements;for(let i=0;i<16;i++)if(t[i]!==n[i])return!1;return!0}fromArray(e,t=0){for(let n=0;n<16;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e[t+9]=n[9],e[t+10]=n[10],e[t+11]=n[11],e[t+12]=n[12],e[t+13]=n[13],e[t+14]=n[14],e[t+15]=n[15],e}}const ph=new X,Sa=new Jt,Mk=new X(0,0,0),Ak=new X(1,1,1),Jl=new X,Hg=new X,Ns=new X,mE=new Jt,gE=new Ni;class Sm{constructor(e=0,t=0,n=0,i=Sm.DEFAULT_ORDER){this.isEuler=!0,this._x=e,this._y=t,this._z=n,this._order=i}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,n,i=this._order){return this._x=e,this._y=t,this._z=n,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,n=!0){const i=e.elements,s=i[0],a=i[4],o=i[8],u=i[1],h=i[5],p=i[9],m=i[2],y=i[6],v=i[10];switch(t){case"XYZ":this._y=Math.asin(mr(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-p,v),this._z=Math.atan2(-a,s)):(this._x=Math.atan2(y,h),this._z=0);break;case"YXZ":this._x=Math.asin(-mr(p,-1,1)),Math.abs(p)<.9999999?(this._y=Math.atan2(o,v),this._z=Math.atan2(u,h)):(this._y=Math.atan2(-m,s),this._z=0);break;case"ZXY":this._x=Math.asin(mr(y,-1,1)),Math.abs(y)<.9999999?(this._y=Math.atan2(-m,v),this._z=Math.atan2(-a,h)):(this._y=0,this._z=Math.atan2(u,s));break;case"ZYX":this._y=Math.asin(-mr(m,-1,1)),Math.abs(m)<.9999999?(this._x=Math.atan2(y,v),this._z=Math.atan2(u,s)):(this._x=0,this._z=Math.atan2(-a,h));break;case"YZX":this._z=Math.asin(mr(u,-1,1)),Math.abs(u)<.9999999?(this._x=Math.atan2(-p,h),this._y=Math.atan2(-m,s)):(this._x=0,this._y=Math.atan2(o,v));break;case"XZY":this._z=Math.asin(-mr(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(y,h),this._y=Math.atan2(o,s)):(this._x=Math.atan2(-p,v),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,n===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,n){return mE.makeRotationFromQuaternion(e),this.setFromRotationMatrix(mE,t,n)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return gE.setFromEuler(this),this.setFromQuaternion(gE,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Sm.DEFAULT_ORDER="XYZ";class Hc{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}isEnabled(e){return(this.mask&(1<<e|0))!==0}}let Nk=0;const yE=new X,mh=new Ni,qo=new Jt,$g=new X,hp=new X,Ck=new X,Rk=new Ni,vE=new X(1,0,0),_E=new X(0,1,0),xE=new X(0,0,1),Ik={type:"added"},Pk={type:"removed"};class Sn extends hl{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:Nk++}),this.uuid=Ps(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Sn.DEFAULT_UP.clone();const e=new X,t=new Sm,n=new Ni,i=new X(1,1,1);function s(){n.setFromEuler(t,!1)}function a(){t.setFromQuaternion(n,void 0,!1)}t._onChange(s),n._onChange(a),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new Jt},normalMatrix:{value:new rn}}),this.matrix=new Jt,this.matrixWorld=new Jt,this.matrixAutoUpdate=Sn.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.matrixWorldAutoUpdate=Sn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.layers=new Hc,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return mh.setFromAxisAngle(e,t),this.quaternion.multiply(mh),this}rotateOnWorldAxis(e,t){return mh.setFromAxisAngle(e,t),this.quaternion.premultiply(mh),this}rotateX(e){return this.rotateOnAxis(vE,e)}rotateY(e){return this.rotateOnAxis(_E,e)}rotateZ(e){return this.rotateOnAxis(xE,e)}translateOnAxis(e,t){return yE.copy(e).applyQuaternion(this.quaternion),this.position.add(yE.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(vE,e)}translateY(e){return this.translateOnAxis(_E,e)}translateZ(e){return this.translateOnAxis(xE,e)}localToWorld(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(qo.copy(this.matrixWorld).invert())}lookAt(e,t,n){e.isVector3?$g.copy(e):$g.set(e,t,n);const i=this.parent;this.updateWorldMatrix(!0,!1),hp.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?qo.lookAt(hp,$g,this.up):qo.lookAt($g,hp,this.up),this.quaternion.setFromRotationMatrix(qo),i&&(qo.extractRotation(i.matrixWorld),mh.setFromRotationMatrix(qo),this.quaternion.premultiply(mh.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.parent!==null&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(Ik)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(Pk)),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){return this.remove(...this.children)}attach(e){return this.updateWorldMatrix(!0,!1),qo.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),qo.multiply(e.parent.matrixWorld)),e.applyMatrix4(qo),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let n=0,i=this.children.length;n<i;n++){const a=this.children[n].getObjectByProperty(e,t);if(a!==void 0)return a}}getObjectsByProperty(e,t){let n=[];this[e]===t&&n.push(this);for(let i=0,s=this.children.length;i<s;i++){const a=this.children[i].getObjectsByProperty(e,t);a.length>0&&(n=n.concat(a))}return n}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(hp,e,Ck),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(hp,Rk,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let n=0,i=t.length;n<i;n++){const s=t[n];(s.matrixWorldAutoUpdate===!0||e===!0)&&s.updateMatrixWorld(e)}}updateWorldMatrix(e,t){const n=this.parent;if(e===!0&&n!==null&&n.matrixWorldAutoUpdate===!0&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){const i=this.children;for(let s=0,a=i.length;s<a;s++){const o=i[s];o.matrixWorldAutoUpdate===!0&&o.updateWorldMatrix(!1,!0)}}}toJSON(e){const t=e===void 0||typeof e=="string",n={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},n.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),i.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON()));function s(o,u){return o[u.uuid]===void 0&&(o[u.uuid]=u.toJSON(e)),u.uuid}if(this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(i.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=s(e.geometries,this.geometry);const o=this.geometry.parameters;if(o!==void 0&&o.shapes!==void 0){const u=o.shapes;if(Array.isArray(u))for(let h=0,p=u.length;h<p;h++){const m=u[h];s(e.shapes,m)}else s(e.shapes,u)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(s(e.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const o=[];for(let u=0,h=this.material.length;u<h;u++)o.push(s(e.materials,this.material[u]));i.material=o}else i.material=s(e.materials,this.material);if(this.children.length>0){i.children=[];for(let o=0;o<this.children.length;o++)i.children.push(this.children[o].toJSON(e).object)}if(this.animations.length>0){i.animations=[];for(let o=0;o<this.animations.length;o++){const u=this.animations[o];i.animations.push(s(e.animations,u))}}if(t){const o=a(e.geometries),u=a(e.materials),h=a(e.textures),p=a(e.images),m=a(e.shapes),y=a(e.skeletons),v=a(e.animations),S=a(e.nodes);o.length>0&&(n.geometries=o),u.length>0&&(n.materials=u),h.length>0&&(n.textures=h),p.length>0&&(n.images=p),m.length>0&&(n.shapes=m),y.length>0&&(n.skeletons=y),v.length>0&&(n.animations=v),S.length>0&&(n.nodes=S)}return n.object=i,n;function a(o){const u=[];for(const h in o){const p=o[h];delete p.metadata,u.push(p)}return u}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.matrixWorldAutoUpdate=e.matrixWorldAutoUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.animations=e.animations.slice(),this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let n=0;n<e.children.length;n++){const i=e.children[n];this.add(i.clone())}return this}}Sn.DEFAULT_UP=new X(0,1,0);Sn.DEFAULT_MATRIX_AUTO_UPDATE=!0;Sn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const wa=new X,Xo=new X,r_=new X,Ko=new X,gh=new X,yh=new X,SE=new X,i_=new X,s_=new X,a_=new X;let Gg=!1;class fs{constructor(e=new X,t=new X,n=new X){this.a=e,this.b=t,this.c=n}static getNormal(e,t,n,i){i.subVectors(n,t),wa.subVectors(e,t),i.cross(wa);const s=i.lengthSq();return s>0?i.multiplyScalar(1/Math.sqrt(s)):i.set(0,0,0)}static getBarycoord(e,t,n,i,s){wa.subVectors(i,t),Xo.subVectors(n,t),r_.subVectors(e,t);const a=wa.dot(wa),o=wa.dot(Xo),u=wa.dot(r_),h=Xo.dot(Xo),p=Xo.dot(r_),m=a*h-o*o;if(m===0)return s.set(-2,-1,-1);const y=1/m,v=(h*u-o*p)*y,S=(a*p-o*u)*y;return s.set(1-v-S,S,v)}static containsPoint(e,t,n,i){return this.getBarycoord(e,t,n,i,Ko),Ko.x>=0&&Ko.y>=0&&Ko.x+Ko.y<=1}static getUV(e,t,n,i,s,a,o,u){return Gg===!1&&(console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),Gg=!0),this.getInterpolation(e,t,n,i,s,a,o,u)}static getInterpolation(e,t,n,i,s,a,o,u){return this.getBarycoord(e,t,n,i,Ko),u.setScalar(0),u.addScaledVector(s,Ko.x),u.addScaledVector(a,Ko.y),u.addScaledVector(o,Ko.z),u}static isFrontFacing(e,t,n,i){return wa.subVectors(n,t),Xo.subVectors(e,t),wa.cross(Xo).dot(i)<0}set(e,t,n){return this.a.copy(e),this.b.copy(t),this.c.copy(n),this}setFromPointsAndIndices(e,t,n,i){return this.a.copy(e[t]),this.b.copy(e[n]),this.c.copy(e[i]),this}setFromAttributeAndIndices(e,t,n,i){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,n),this.c.fromBufferAttribute(e,i),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return wa.subVectors(this.c,this.b),Xo.subVectors(this.a,this.b),wa.cross(Xo).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return fs.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return fs.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,n,i,s){return Gg===!1&&(console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),Gg=!0),fs.getInterpolation(e,this.a,this.b,this.c,t,n,i,s)}getInterpolation(e,t,n,i,s){return fs.getInterpolation(e,this.a,this.b,this.c,t,n,i,s)}containsPoint(e){return fs.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return fs.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const n=this.a,i=this.b,s=this.c;let a,o;gh.subVectors(i,n),yh.subVectors(s,n),i_.subVectors(e,n);const u=gh.dot(i_),h=yh.dot(i_);if(u<=0&&h<=0)return t.copy(n);s_.subVectors(e,i);const p=gh.dot(s_),m=yh.dot(s_);if(p>=0&&m<=p)return t.copy(i);const y=u*m-p*h;if(y<=0&&u>=0&&p<=0)return a=u/(u-p),t.copy(n).addScaledVector(gh,a);a_.subVectors(e,s);const v=gh.dot(a_),S=yh.dot(a_);if(S>=0&&v<=S)return t.copy(s);const T=v*h-u*S;if(T<=0&&h>=0&&S<=0)return o=h/(h-S),t.copy(n).addScaledVector(yh,o);const E=p*S-v*m;if(E<=0&&m-p>=0&&v-S>=0)return SE.subVectors(s,i),o=(m-p)/(m-p+(v-S)),t.copy(i).addScaledVector(SE,o);const w=1/(E+T+y);return a=T*w,o=y*w,t.copy(n).addScaledVector(gh,a).addScaledVector(yh,o)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}const XM={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Ql={h:0,s:0,l:0},Wg={h:0,s:0,l:0};function o_(r,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?r+(e-r)*6*t:t<1/2?e:t<2/3?r+(e-r)*6*(2/3-t):r}class yt{constructor(e,t,n){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(e,t,n)}set(e,t,n){if(t===void 0&&n===void 0){const i=e;i&&i.isColor?this.copy(i):typeof i=="number"?this.setHex(i):typeof i=="string"&&this.setStyle(i)}else this.setRGB(e,t,n);return this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=Hr){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,Nn.toWorkingColorSpace(this,t),this}setRGB(e,t,n,i=Nn.workingColorSpace){return this.r=e,this.g=t,this.b=n,Nn.toWorkingColorSpace(this,i),this}setHSL(e,t,n,i=Nn.workingColorSpace){if(e=PS(e,1),t=mr(t,0,1),n=mr(n,0,1),t===0)this.r=this.g=this.b=n;else{const s=n<=.5?n*(1+t):n+t-n*t,a=2*n-s;this.r=o_(a,s,e+1/3),this.g=o_(a,s,e),this.b=o_(a,s,e-1/3)}return Nn.toWorkingColorSpace(this,i),this}setStyle(e,t=Hr){function n(s){s!==void 0&&parseFloat(s)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let i;if(i=/^(\w+)\(([^\)]*)\)/.exec(e)){let s;const a=i[1],o=i[2];switch(a){case"rgb":case"rgba":if(s=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return n(s[4]),this.setRGB(Math.min(255,parseInt(s[1],10))/255,Math.min(255,parseInt(s[2],10))/255,Math.min(255,parseInt(s[3],10))/255,t);if(s=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return n(s[4]),this.setRGB(Math.min(100,parseInt(s[1],10))/100,Math.min(100,parseInt(s[2],10))/100,Math.min(100,parseInt(s[3],10))/100,t);break;case"hsl":case"hsla":if(s=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return n(s[4]),this.setHSL(parseFloat(s[1])/360,parseFloat(s[2])/100,parseFloat(s[3])/100,t);break;default:console.warn("THREE.Color: Unknown color model "+e)}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(e)){const s=i[1],a=s.length;if(a===3)return this.setRGB(parseInt(s.charAt(0),16)/15,parseInt(s.charAt(1),16)/15,parseInt(s.charAt(2),16)/15,t);if(a===6)return this.setHex(parseInt(s,16),t);console.warn("THREE.Color: Invalid hex color "+e)}else if(e&&e.length>0)return this.setColorName(e,t);return this}setColorName(e,t=Hr){const n=XM[e.toLowerCase()];return n!==void 0?this.setHex(n,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=Vh(e.r),this.g=Vh(e.g),this.b=Vh(e.b),this}copyLinearToSRGB(e){return this.r=Kv(e.r),this.g=Kv(e.g),this.b=Kv(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=Hr){return Nn.fromWorkingColorSpace(Ei.copy(this),e),Math.round(mr(Ei.r*255,0,255))*65536+Math.round(mr(Ei.g*255,0,255))*256+Math.round(mr(Ei.b*255,0,255))}getHexString(e=Hr){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=Nn.workingColorSpace){Nn.fromWorkingColorSpace(Ei.copy(this),t);const n=Ei.r,i=Ei.g,s=Ei.b,a=Math.max(n,i,s),o=Math.min(n,i,s);let u,h;const p=(o+a)/2;if(o===a)u=0,h=0;else{const m=a-o;switch(h=p<=.5?m/(a+o):m/(2-a-o),a){case n:u=(i-s)/m+(i<s?6:0);break;case i:u=(s-n)/m+2;break;case s:u=(n-i)/m+4;break}u/=6}return e.h=u,e.s=h,e.l=p,e}getRGB(e,t=Nn.workingColorSpace){return Nn.fromWorkingColorSpace(Ei.copy(this),t),e.r=Ei.r,e.g=Ei.g,e.b=Ei.b,e}getStyle(e=Hr){Nn.fromWorkingColorSpace(Ei.copy(this),e);const t=Ei.r,n=Ei.g,i=Ei.b;return e!==Hr?`color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`:`rgb(${Math.round(t*255)},${Math.round(n*255)},${Math.round(i*255)})`}offsetHSL(e,t,n){return this.getHSL(Ql),this.setHSL(Ql.h+e,Ql.s+t,Ql.l+n)}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,n){return this.r=e.r+(t.r-e.r)*n,this.g=e.g+(t.g-e.g)*n,this.b=e.b+(t.b-e.b)*n,this}lerpHSL(e,t){this.getHSL(Ql),e.getHSL(Wg);const n=Ip(Ql.h,Wg.h,t),i=Ip(Ql.s,Wg.s,t),s=Ip(Ql.l,Wg.l,t);return this.setHSL(n,i,s),this}setFromVector3(e){return this.r=e.x,this.g=e.y,this.b=e.z,this}applyMatrix3(e){const t=this.r,n=this.g,i=this.b,s=e.elements;return this.r=s[0]*t+s[3]*n+s[6]*i,this.g=s[1]*t+s[4]*n+s[7]*i,this.b=s[2]*t+s[5]*n+s[8]*i,this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const Ei=new yt;yt.NAMES=XM;let Lk=0;class Ri extends hl{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:Lk++}),this.uuid=Ps(),this.name="",this.type="Material",this.blending=Bc,this.side=ll,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=Zy,this.blendDst=Jy,this.blendEquation=nu,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new yt(0,0,0),this.blendAlpha=0,this.depthFunc=Fp,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=Cx,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Nc,this.stencilZFail=Nc,this.stencilZPass=Nc,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const n=e[t];if(n===void 0){console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);continue}const i=this[t];if(i===void 0){console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);continue}i&&i.isColor?i.set(n):i&&i.isVector3&&n&&n.isVector3?i.copy(n):this[t]=n}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const n={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),this.roughness!==void 0&&(n.roughness=this.roughness),this.metalness!==void 0&&(n.metalness=this.metalness),this.sheen!==void 0&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(n.shininess=this.shininess),this.clearcoat!==void 0&&(n.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.iridescence!==void 0&&(n.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(n.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(n.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(n.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(n.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.anisotropy!==void 0&&(n.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(n.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(n.anisotropyMap=this.anisotropyMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(e).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(e).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(e).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(e).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(e).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(n.combine=this.combine)),this.envMapIntensity!==void 0&&(n.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(n.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(n.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(n.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(n.size=this.size),this.shadowSide!==null&&(n.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==Bc&&(n.blending=this.blending),this.side!==ll&&(n.side=this.side),this.vertexColors===!0&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.transparent===!0&&(n.transparent=!0),this.blendSrc!==Zy&&(n.blendSrc=this.blendSrc),this.blendDst!==Jy&&(n.blendDst=this.blendDst),this.blendEquation!==nu&&(n.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(n.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(n.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(n.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(n.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(n.blendAlpha=this.blendAlpha),this.depthFunc!==Fp&&(n.depthFunc=this.depthFunc),this.depthTest===!1&&(n.depthTest=this.depthTest),this.depthWrite===!1&&(n.depthWrite=this.depthWrite),this.colorWrite===!1&&(n.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(n.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==Cx&&(n.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(n.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(n.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==Nc&&(n.stencilFail=this.stencilFail),this.stencilZFail!==Nc&&(n.stencilZFail=this.stencilZFail),this.stencilZPass!==Nc&&(n.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(n.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(n.rotation=this.rotation),this.polygonOffset===!0&&(n.polygonOffset=!0),this.polygonOffsetFactor!==0&&(n.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(n.linewidth=this.linewidth),this.dashSize!==void 0&&(n.dashSize=this.dashSize),this.gapSize!==void 0&&(n.gapSize=this.gapSize),this.scale!==void 0&&(n.scale=this.scale),this.dithering===!0&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),this.alphaHash===!0&&(n.alphaHash=!0),this.alphaToCoverage===!0&&(n.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(n.premultipliedAlpha=!0),this.forceSinglePass===!0&&(n.forceSinglePass=!0),this.wireframe===!0&&(n.wireframe=!0),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(n.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(n.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(n.flatShading=!0),this.visible===!1&&(n.visible=!1),this.toneMapped===!1&&(n.toneMapped=!1),this.fog===!1&&(n.fog=!1),Object.keys(this.userData).length>0&&(n.userData=this.userData);function i(s){const a=[];for(const o in s){const u=s[o];delete u.metadata,a.push(u)}return a}if(t){const s=i(e.textures),a=i(e.images);s.length>0&&(n.textures=s),a.length>0&&(n.images=a)}return n}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.blendColor.copy(e.blendColor),this.blendAlpha=e.blendAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let n=null;if(t!==null){const i=t.length;n=new Array(i);for(let s=0;s!==i;++s)n[s]=t[s].clone()}return this.clippingPlanes=n,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaHash=e.alphaHash,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.forceSinglePass=e.forceSinglePass,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}}class Eu extends Ri{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new yt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=_m,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}const nl=kk();function kk(){const r=new ArrayBuffer(4),e=new Float32Array(r),t=new Uint32Array(r),n=new Uint32Array(512),i=new Uint32Array(512);for(let u=0;u<256;++u){const h=u-127;h<-27?(n[u]=0,n[u|256]=32768,i[u]=24,i[u|256]=24):h<-14?(n[u]=1024>>-h-14,n[u|256]=1024>>-h-14|32768,i[u]=-h-1,i[u|256]=-h-1):h<=15?(n[u]=h+15<<10,n[u|256]=h+15<<10|32768,i[u]=13,i[u|256]=13):h<128?(n[u]=31744,n[u|256]=64512,i[u]=24,i[u|256]=24):(n[u]=31744,n[u|256]=64512,i[u]=13,i[u|256]=13)}const s=new Uint32Array(2048),a=new Uint32Array(64),o=new Uint32Array(64);for(let u=1;u<1024;++u){let h=u<<13,p=0;for(;(h&8388608)===0;)h<<=1,p-=8388608;h&=-8388609,p+=947912704,s[u]=h|p}for(let u=1024;u<2048;++u)s[u]=939524096+(u-1024<<13);for(let u=1;u<31;++u)a[u]=u<<23;a[31]=1199570944,a[32]=2147483648;for(let u=33;u<63;++u)a[u]=2147483648+(u-32<<23);a[63]=3347054592;for(let u=1;u<64;++u)u!==32&&(o[u]=1024);return{floatView:e,uint32View:t,baseTable:n,shiftTable:i,mantissaTable:s,exponentTable:a,offsetTable:o}}function os(r){Math.abs(r)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),r=mr(r,-65504,65504),nl.floatView[0]=r;const e=nl.uint32View[0],t=e>>23&511;return nl.baseTable[t]+((e&8388607)>>nl.shiftTable[t])}function bp(r){const e=r>>10;return nl.uint32View[0]=nl.mantissaTable[nl.offsetTable[e]+(r&1023)]+nl.exponentTable[e],nl.floatView[0]}const Dk={toHalfFloat:os,fromHalfFloat:bp},Lr=new X,jg=new Pe;class Hn{constructor(e,t,n=!1){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=n,this.usage=Xp,this.updateRange={offset:0,count:-1},this.gpuType=Ja,this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this.gpuType=e.gpuType,this}copyAt(e,t,n){e*=this.itemSize,n*=t.itemSize;for(let i=0,s=this.itemSize;i<s;i++)this.array[e+i]=t.array[n+i];return this}copyArray(e){return this.array.set(e),this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,n=this.count;t<n;t++)jg.fromBufferAttribute(this,t),jg.applyMatrix3(e),this.setXY(t,jg.x,jg.y);else if(this.itemSize===3)for(let t=0,n=this.count;t<n;t++)Lr.fromBufferAttribute(this,t),Lr.applyMatrix3(e),this.setXYZ(t,Lr.x,Lr.y,Lr.z);return this}applyMatrix4(e){for(let t=0,n=this.count;t<n;t++)Lr.fromBufferAttribute(this,t),Lr.applyMatrix4(e),this.setXYZ(t,Lr.x,Lr.y,Lr.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)Lr.fromBufferAttribute(this,t),Lr.applyNormalMatrix(e),this.setXYZ(t,Lr.x,Lr.y,Lr.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)Lr.fromBufferAttribute(this,t),Lr.transformDirection(e),this.setXYZ(t,Lr.x,Lr.y,Lr.z);return this}set(e,t=0){return this.array.set(e,t),this}getComponent(e,t){let n=this.array[e*this.itemSize+t];return this.normalized&&(n=ds(n,this.array)),n}setComponent(e,t,n){return this.normalized&&(n=nn(n,this.array)),this.array[e*this.itemSize+t]=n,this}getX(e){let t=this.array[e*this.itemSize];return this.normalized&&(t=ds(t,this.array)),t}setX(e,t){return this.normalized&&(t=nn(t,this.array)),this.array[e*this.itemSize]=t,this}getY(e){let t=this.array[e*this.itemSize+1];return this.normalized&&(t=ds(t,this.array)),t}setY(e,t){return this.normalized&&(t=nn(t,this.array)),this.array[e*this.itemSize+1]=t,this}getZ(e){let t=this.array[e*this.itemSize+2];return this.normalized&&(t=ds(t,this.array)),t}setZ(e,t){return this.normalized&&(t=nn(t,this.array)),this.array[e*this.itemSize+2]=t,this}getW(e){let t=this.array[e*this.itemSize+3];return this.normalized&&(t=ds(t,this.array)),t}setW(e,t){return this.normalized&&(t=nn(t,this.array)),this.array[e*this.itemSize+3]=t,this}setXY(e,t,n){return e*=this.itemSize,this.normalized&&(t=nn(t,this.array),n=nn(n,this.array)),this.array[e+0]=t,this.array[e+1]=n,this}setXYZ(e,t,n,i){return e*=this.itemSize,this.normalized&&(t=nn(t,this.array),n=nn(n,this.array),i=nn(i,this.array)),this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=i,this}setXYZW(e,t,n,i,s){return e*=this.itemSize,this.normalized&&(t=nn(t,this.array),n=nn(n,this.array),i=nn(i,this.array),s=nn(s,this.array)),this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=i,this.array[e+3]=s,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==Xp&&(e.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(e.updateRange=this.updateRange),e}}class Ok extends Hn{constructor(e,t,n){super(new Int8Array(e),t,n)}}class Fk extends Hn{constructor(e,t,n){super(new Uint8Array(e),t,n)}}class Uk extends Hn{constructor(e,t,n){super(new Uint8ClampedArray(e),t,n)}}class zk extends Hn{constructor(e,t,n){super(new Int16Array(e),t,n)}}class DS extends Hn{constructor(e,t,n){super(new Uint16Array(e),t,n)}}class Bk extends Hn{constructor(e,t,n){super(new Int32Array(e),t,n)}}class OS extends Hn{constructor(e,t,n){super(new Uint32Array(e),t,n)}}class Vk extends Hn{constructor(e,t,n){super(new Uint16Array(e),t,n),this.isFloat16BufferAttribute=!0}getX(e){let t=bp(this.array[e*this.itemSize]);return this.normalized&&(t=ds(t,this.array)),t}setX(e,t){return this.normalized&&(t=nn(t,this.array)),this.array[e*this.itemSize]=os(t),this}getY(e){let t=bp(this.array[e*this.itemSize+1]);return this.normalized&&(t=ds(t,this.array)),t}setY(e,t){return this.normalized&&(t=nn(t,this.array)),this.array[e*this.itemSize+1]=os(t),this}getZ(e){let t=bp(this.array[e*this.itemSize+2]);return this.normalized&&(t=ds(t,this.array)),t}setZ(e,t){return this.normalized&&(t=nn(t,this.array)),this.array[e*this.itemSize+2]=os(t),this}getW(e){let t=bp(this.array[e*this.itemSize+3]);return this.normalized&&(t=ds(t,this.array)),t}setW(e,t){return this.normalized&&(t=nn(t,this.array)),this.array[e*this.itemSize+3]=os(t),this}setXY(e,t,n){return e*=this.itemSize,this.normalized&&(t=nn(t,this.array),n=nn(n,this.array)),this.array[e+0]=os(t),this.array[e+1]=os(n),this}setXYZ(e,t,n,i){return e*=this.itemSize,this.normalized&&(t=nn(t,this.array),n=nn(n,this.array),i=nn(i,this.array)),this.array[e+0]=os(t),this.array[e+1]=os(n),this.array[e+2]=os(i),this}setXYZW(e,t,n,i,s){return e*=this.itemSize,this.normalized&&(t=nn(t,this.array),n=nn(n,this.array),i=nn(i,this.array),s=nn(s,this.array)),this.array[e+0]=os(t),this.array[e+1]=os(n),this.array[e+2]=os(i),this.array[e+3]=os(s),this}}class At extends Hn{constructor(e,t,n){super(new Float32Array(e),t,n)}}class Hk extends Hn{constructor(e,t,n){super(new Float64Array(e),t,n)}}let $k=0;const Gs=new Jt,l_=new Sn,vh=new X,Cs=new co,dp=new co,Qr=new X;class ln extends hl{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:$k++}),this.uuid=Ps(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(WM(e)?OS:DS)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,n=0){this.groups.push({start:e,count:t,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const n=this.attributes.normal;if(n!==void 0){const s=new rn().getNormalMatrix(e);n.applyNormalMatrix(s),n.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(e),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return Gs.makeRotationFromQuaternion(e),this.applyMatrix4(Gs),this}rotateX(e){return Gs.makeRotationX(e),this.applyMatrix4(Gs),this}rotateY(e){return Gs.makeRotationY(e),this.applyMatrix4(Gs),this}rotateZ(e){return Gs.makeRotationZ(e),this.applyMatrix4(Gs),this}translate(e,t,n){return Gs.makeTranslation(e,t,n),this.applyMatrix4(Gs),this}scale(e,t,n){return Gs.makeScale(e,t,n),this.applyMatrix4(Gs),this}lookAt(e){return l_.lookAt(e),l_.updateMatrix(),this.applyMatrix4(l_.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(vh).negate(),this.translate(vh.x,vh.y,vh.z),this}setFromPoints(e){const t=[];for(let n=0,i=e.length;n<i;n++){const s=e[n];t.push(s.x,s.y,s.z||0)}return this.setAttribute("position",new At(t,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new co);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new X(-1/0,-1/0,-1/0),new X(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let n=0,i=t.length;n<i;n++){const s=t[n];Cs.setFromBufferAttribute(s),this.morphTargetsRelative?(Qr.addVectors(this.boundingBox.min,Cs.min),this.boundingBox.expandByPoint(Qr),Qr.addVectors(this.boundingBox.max,Cs.max),this.boundingBox.expandByPoint(Qr)):(this.boundingBox.expandByPoint(Cs.min),this.boundingBox.expandByPoint(Cs.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Ia);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new X,1/0);return}if(e){const n=this.boundingSphere.center;if(Cs.setFromBufferAttribute(e),t)for(let s=0,a=t.length;s<a;s++){const o=t[s];dp.setFromBufferAttribute(o),this.morphTargetsRelative?(Qr.addVectors(Cs.min,dp.min),Cs.expandByPoint(Qr),Qr.addVectors(Cs.max,dp.max),Cs.expandByPoint(Qr)):(Cs.expandByPoint(dp.min),Cs.expandByPoint(dp.max))}Cs.getCenter(n);let i=0;for(let s=0,a=e.count;s<a;s++)Qr.fromBufferAttribute(e,s),i=Math.max(i,n.distanceToSquared(Qr));if(t)for(let s=0,a=t.length;s<a;s++){const o=t[s],u=this.morphTargetsRelative;for(let h=0,p=o.count;h<p;h++)Qr.fromBufferAttribute(o,h),u&&(vh.fromBufferAttribute(e,h),Qr.add(vh)),i=Math.max(i,n.distanceToSquared(Qr))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const n=e.array,i=t.position.array,s=t.normal.array,a=t.uv.array,o=i.length/3;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new Hn(new Float32Array(4*o),4));const u=this.getAttribute("tangent").array,h=[],p=[];for(let k=0;k<o;k++)h[k]=new X,p[k]=new X;const m=new X,y=new X,v=new X,S=new Pe,T=new Pe,E=new Pe,w=new X,C=new X;function A(k,O,Q){m.fromArray(i,k*3),y.fromArray(i,O*3),v.fromArray(i,Q*3),S.fromArray(a,k*2),T.fromArray(a,O*2),E.fromArray(a,Q*2),y.sub(m),v.sub(m),T.sub(S),E.sub(S);const le=1/(T.x*E.y-E.x*T.y);isFinite(le)&&(w.copy(y).multiplyScalar(E.y).addScaledVector(v,-T.y).multiplyScalar(le),C.copy(v).multiplyScalar(T.x).addScaledVector(y,-E.x).multiplyScalar(le),h[k].add(w),h[O].add(w),h[Q].add(w),p[k].add(C),p[O].add(C),p[Q].add(C))}let I=this.groups;I.length===0&&(I=[{start:0,count:n.length}]);for(let k=0,O=I.length;k<O;++k){const Q=I[k],le=Q.start,K=Q.count;for(let ce=le,de=le+K;ce<de;ce+=3)A(n[ce+0],n[ce+1],n[ce+2])}const F=new X,U=new X,V=new X,G=new X;function L(k){V.fromArray(s,k*3),G.copy(V);const O=h[k];F.copy(O),F.sub(V.multiplyScalar(V.dot(O))).normalize(),U.crossVectors(G,O);const le=U.dot(p[k])<0?-1:1;u[k*4]=F.x,u[k*4+1]=F.y,u[k*4+2]=F.z,u[k*4+3]=le}for(let k=0,O=I.length;k<O;++k){const Q=I[k],le=Q.start,K=Q.count;for(let ce=le,de=le+K;ce<de;ce+=3)L(n[ce+0]),L(n[ce+1]),L(n[ce+2])}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let n=this.getAttribute("normal");if(n===void 0)n=new Hn(new Float32Array(t.count*3),3),this.setAttribute("normal",n);else for(let y=0,v=n.count;y<v;y++)n.setXYZ(y,0,0,0);const i=new X,s=new X,a=new X,o=new X,u=new X,h=new X,p=new X,m=new X;if(e)for(let y=0,v=e.count;y<v;y+=3){const S=e.getX(y+0),T=e.getX(y+1),E=e.getX(y+2);i.fromBufferAttribute(t,S),s.fromBufferAttribute(t,T),a.fromBufferAttribute(t,E),p.subVectors(a,s),m.subVectors(i,s),p.cross(m),o.fromBufferAttribute(n,S),u.fromBufferAttribute(n,T),h.fromBufferAttribute(n,E),o.add(p),u.add(p),h.add(p),n.setXYZ(S,o.x,o.y,o.z),n.setXYZ(T,u.x,u.y,u.z),n.setXYZ(E,h.x,h.y,h.z)}else for(let y=0,v=t.count;y<v;y+=3)i.fromBufferAttribute(t,y+0),s.fromBufferAttribute(t,y+1),a.fromBufferAttribute(t,y+2),p.subVectors(a,s),m.subVectors(i,s),p.cross(m),n.setXYZ(y+0,p.x,p.y,p.z),n.setXYZ(y+1,p.x,p.y,p.z),n.setXYZ(y+2,p.x,p.y,p.z);this.normalizeNormals(),n.needsUpdate=!0}}normalizeNormals(){const e=this.attributes.normal;for(let t=0,n=e.count;t<n;t++)Qr.fromBufferAttribute(e,t),Qr.normalize(),e.setXYZ(t,Qr.x,Qr.y,Qr.z)}toNonIndexed(){function e(o,u){const h=o.array,p=o.itemSize,m=o.normalized,y=new h.constructor(u.length*p);let v=0,S=0;for(let T=0,E=u.length;T<E;T++){o.isInterleavedBufferAttribute?v=u[T]*o.data.stride+o.offset:v=u[T]*p;for(let w=0;w<p;w++)y[S++]=h[v++]}return new Hn(y,p,m)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new ln,n=this.index.array,i=this.attributes;for(const o in i){const u=i[o],h=e(u,n);t.setAttribute(o,h)}const s=this.morphAttributes;for(const o in s){const u=[],h=s[o];for(let p=0,m=h.length;p<m;p++){const y=h[p],v=e(y,n);u.push(v)}t.morphAttributes[o]=u}t.morphTargetsRelative=this.morphTargetsRelative;const a=this.groups;for(let o=0,u=a.length;o<u;o++){const h=a[o];t.addGroup(h.start,h.count,h.materialIndex)}return t}toJSON(){const e={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const u=this.parameters;for(const h in u)u[h]!==void 0&&(e[h]=u[h]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const n=this.attributes;for(const u in n){const h=n[u];e.data.attributes[u]=h.toJSON(e.data)}const i={};let s=!1;for(const u in this.morphAttributes){const h=this.morphAttributes[u],p=[];for(let m=0,y=h.length;m<y;m++){const v=h[m];p.push(v.toJSON(e.data))}p.length>0&&(i[u]=p,s=!0)}s&&(e.data.morphAttributes=i,e.data.morphTargetsRelative=this.morphTargetsRelative);const a=this.groups;a.length>0&&(e.data.groups=JSON.parse(JSON.stringify(a)));const o=this.boundingSphere;return o!==null&&(e.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const n=e.index;n!==null&&this.setIndex(n.clone(t));const i=e.attributes;for(const h in i){const p=i[h];this.setAttribute(h,p.clone(t))}const s=e.morphAttributes;for(const h in s){const p=[],m=s[h];for(let y=0,v=m.length;y<v;y++)p.push(m[y].clone(t));this.morphAttributes[h]=p}this.morphTargetsRelative=e.morphTargetsRelative;const a=e.groups;for(let h=0,p=a.length;h<p;h++){const m=a[h];this.addGroup(m.start,m.count,m.materialIndex)}const o=e.boundingBox;o!==null&&(this.boundingBox=o.clone());const u=e.boundingSphere;return u!==null&&(this.boundingSphere=u.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const wE=new Jt,vc=new sf,qg=new Ia,EE=new X,_h=new X,xh=new X,Sh=new X,u_=new X,Xg=new X,Kg=new Pe,Yg=new Pe,Zg=new Pe,bE=new X,TE=new X,ME=new X,Jg=new X,Qg=new X;class hi extends Sn{constructor(e=new ln,t=new Eu){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,a=i.length;s<a;s++){const o=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=s}}}}getVertexPosition(e,t){const n=this.geometry,i=n.attributes.position,s=n.morphAttributes.position,a=n.morphTargetsRelative;t.fromBufferAttribute(i,e);const o=this.morphTargetInfluences;if(s&&o){Xg.set(0,0,0);for(let u=0,h=s.length;u<h;u++){const p=o[u],m=s[u];p!==0&&(u_.fromBufferAttribute(m,e),a?Xg.addScaledVector(u_,p):Xg.addScaledVector(u_.sub(t),p))}t.add(Xg)}return t}raycast(e,t){const n=this.geometry,i=this.material,s=this.matrixWorld;i!==void 0&&(n.boundingSphere===null&&n.computeBoundingSphere(),qg.copy(n.boundingSphere),qg.applyMatrix4(s),vc.copy(e.ray).recast(e.near),!(qg.containsPoint(vc.origin)===!1&&(vc.intersectSphere(qg,EE)===null||vc.origin.distanceToSquared(EE)>(e.far-e.near)**2))&&(wE.copy(s).invert(),vc.copy(e.ray).applyMatrix4(wE),!(n.boundingBox!==null&&vc.intersectsBox(n.boundingBox)===!1)&&this._computeIntersections(e,t,vc)))}_computeIntersections(e,t,n){let i;const s=this.geometry,a=this.material,o=s.index,u=s.attributes.position,h=s.attributes.uv,p=s.attributes.uv1,m=s.attributes.normal,y=s.groups,v=s.drawRange;if(o!==null)if(Array.isArray(a))for(let S=0,T=y.length;S<T;S++){const E=y[S],w=a[E.materialIndex],C=Math.max(E.start,v.start),A=Math.min(o.count,Math.min(E.start+E.count,v.start+v.count));for(let I=C,F=A;I<F;I+=3){const U=o.getX(I),V=o.getX(I+1),G=o.getX(I+2);i=ey(this,w,e,n,h,p,m,U,V,G),i&&(i.faceIndex=Math.floor(I/3),i.face.materialIndex=E.materialIndex,t.push(i))}}else{const S=Math.max(0,v.start),T=Math.min(o.count,v.start+v.count);for(let E=S,w=T;E<w;E+=3){const C=o.getX(E),A=o.getX(E+1),I=o.getX(E+2);i=ey(this,a,e,n,h,p,m,C,A,I),i&&(i.faceIndex=Math.floor(E/3),t.push(i))}}else if(u!==void 0)if(Array.isArray(a))for(let S=0,T=y.length;S<T;S++){const E=y[S],w=a[E.materialIndex],C=Math.max(E.start,v.start),A=Math.min(u.count,Math.min(E.start+E.count,v.start+v.count));for(let I=C,F=A;I<F;I+=3){const U=I,V=I+1,G=I+2;i=ey(this,w,e,n,h,p,m,U,V,G),i&&(i.faceIndex=Math.floor(I/3),i.face.materialIndex=E.materialIndex,t.push(i))}}else{const S=Math.max(0,v.start),T=Math.min(u.count,v.start+v.count);for(let E=S,w=T;E<w;E+=3){const C=E,A=E+1,I=E+2;i=ey(this,a,e,n,h,p,m,C,A,I),i&&(i.faceIndex=Math.floor(E/3),t.push(i))}}}}function Gk(r,e,t,n,i,s,a,o){let u;if(e.side===Wi?u=n.intersectTriangle(a,s,i,!0,o):u=n.intersectTriangle(i,s,a,e.side===ll,o),u===null)return null;Qg.copy(o),Qg.applyMatrix4(r.matrixWorld);const h=t.ray.origin.distanceTo(Qg);return h<t.near||h>t.far?null:{distance:h,point:Qg.clone(),object:r}}function ey(r,e,t,n,i,s,a,o,u,h){r.getVertexPosition(o,_h),r.getVertexPosition(u,xh),r.getVertexPosition(h,Sh);const p=Gk(r,e,t,n,_h,xh,Sh,Jg);if(p){i&&(Kg.fromBufferAttribute(i,o),Yg.fromBufferAttribute(i,u),Zg.fromBufferAttribute(i,h),p.uv=fs.getInterpolation(Jg,_h,xh,Sh,Kg,Yg,Zg,new Pe)),s&&(Kg.fromBufferAttribute(s,o),Yg.fromBufferAttribute(s,u),Zg.fromBufferAttribute(s,h),p.uv1=fs.getInterpolation(Jg,_h,xh,Sh,Kg,Yg,Zg,new Pe),p.uv2=p.uv1),a&&(bE.fromBufferAttribute(a,o),TE.fromBufferAttribute(a,u),ME.fromBufferAttribute(a,h),p.normal=fs.getInterpolation(Jg,_h,xh,Sh,bE,TE,ME,new X),p.normal.dot(n.direction)>0&&p.normal.multiplyScalar(-1));const m={a:o,b:u,c:h,normal:new X,materialIndex:0};fs.getNormal(_h,xh,Sh,m.normal),p.face=m}return p}class af extends ln{constructor(e=1,t=1,n=1,i=1,s=1,a=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:n,widthSegments:i,heightSegments:s,depthSegments:a};const o=this;i=Math.floor(i),s=Math.floor(s),a=Math.floor(a);const u=[],h=[],p=[],m=[];let y=0,v=0;S("z","y","x",-1,-1,n,t,e,a,s,0),S("z","y","x",1,-1,n,t,-e,a,s,1),S("x","z","y",1,1,e,n,t,i,a,2),S("x","z","y",1,-1,e,n,-t,i,a,3),S("x","y","z",1,-1,e,t,n,i,s,4),S("x","y","z",-1,-1,e,t,-n,i,s,5),this.setIndex(u),this.setAttribute("position",new At(h,3)),this.setAttribute("normal",new At(p,3)),this.setAttribute("uv",new At(m,2));function S(T,E,w,C,A,I,F,U,V,G,L){const k=I/V,O=F/G,Q=I/2,le=F/2,K=U/2,ce=V+1,de=G+1;let me=0,Z=0;const re=new X;for(let ee=0;ee<de;ee++){const z=ee*O-le;for(let q=0;q<ce;q++){const ve=q*k-Q;re[T]=ve*C,re[E]=z*A,re[w]=K,h.push(re.x,re.y,re.z),re[T]=0,re[E]=0,re[w]=U>0?1:-1,p.push(re.x,re.y,re.z),m.push(q/V),m.push(1-ee/G),me+=1}}for(let ee=0;ee<G;ee++)for(let z=0;z<V;z++){const q=y+z+ce*ee,ve=y+z+ce*(ee+1),Ce=y+(z+1)+ce*(ee+1),ke=y+(z+1)+ce*ee;u.push(q,ve,ke),u.push(ve,Ce,ke),Z+=6}o.addGroup(v,Z,L),v+=Z,y+=me}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new af(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function Kh(r){const e={};for(const t in r){e[t]={};for(const n in r[t]){const i=r[t][n];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?i.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),e[t][n]=null):e[t][n]=i.clone():Array.isArray(i)?e[t][n]=i.slice():e[t][n]=i}}return e}function Gi(r){const e={};for(let t=0;t<r.length;t++){const n=Kh(r[t]);for(const i in n)e[i]=n[i]}return e}function Wk(r){const e=[];for(let t=0;t<r.length;t++)e.push(r[t].clone());return e}function KM(r){return r.getRenderTarget()===null?r.outputColorSpace:Nn.workingColorSpace}const YM={clone:Kh,merge:Gi};var jk=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,qk=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class io extends Ri{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=jk,this.fragmentShader=qk,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&this.setValues(e)}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=Kh(e.uniforms),this.uniformsGroups=Wk(e.uniformsGroups),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const i in this.uniforms){const a=this.uniforms[i].value;a&&a.isTexture?t.uniforms[i]={type:"t",value:a.toJSON(e).uuid}:a&&a.isColor?t.uniforms[i]={type:"c",value:a.getHex()}:a&&a.isVector2?t.uniforms[i]={type:"v2",value:a.toArray()}:a&&a.isVector3?t.uniforms[i]={type:"v3",value:a.toArray()}:a&&a.isVector4?t.uniforms[i]={type:"v4",value:a.toArray()}:a&&a.isMatrix3?t.uniforms[i]={type:"m3",value:a.toArray()}:a&&a.isMatrix4?t.uniforms[i]={type:"m4",value:a.toArray()}:t.uniforms[i]={value:a}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader,t.lights=this.lights,t.clipping=this.clipping;const n={};for(const i in this.extensions)this.extensions[i]===!0&&(n[i]=!0);return Object.keys(n).length>0&&(t.extensions=n),t}}class wm extends Sn{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new Jt,this.projectionMatrix=new Jt,this.projectionMatrixInverse=new Jt,this.coordinateSystem=Qa}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this.coordinateSystem=e.coordinateSystem,this}getWorldDirection(e){return super.getWorldDirection(e).negate()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}class Er extends wm{constructor(e=50,t=1,n=.1,i=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=Xh*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(Vc*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return Xh*2*Math.atan(Math.tan(Vc*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(e,t,n,i,s,a){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=i,this.view.width=s,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(Vc*.5*this.fov)/this.zoom,n=2*t,i=this.aspect*n,s=-.5*i;const a=this.view;if(this.view!==null&&this.view.enabled){const u=a.fullWidth,h=a.fullHeight;s+=a.offsetX*i/u,t-=a.offsetY*n/h,i*=a.width/u,n*=a.height/h}const o=this.filmOffset;o!==0&&(s+=e*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+i,t,t-n,e,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}const wh=-90,Eh=1;class ZM extends Sn{constructor(e,t,n){super(),this.type="CubeCamera",this.renderTarget=n,this.coordinateSystem=null,this.activeMipmapLevel=0;const i=new Er(wh,Eh,e,t);i.layers=this.layers,this.add(i);const s=new Er(wh,Eh,e,t);s.layers=this.layers,this.add(s);const a=new Er(wh,Eh,e,t);a.layers=this.layers,this.add(a);const o=new Er(wh,Eh,e,t);o.layers=this.layers,this.add(o);const u=new Er(wh,Eh,e,t);u.layers=this.layers,this.add(u);const h=new Er(wh,Eh,e,t);h.layers=this.layers,this.add(h)}updateCoordinateSystem(){const e=this.coordinateSystem,t=this.children.concat(),[n,i,s,a,o,u]=t;for(const h of t)this.remove(h);if(e===Qa)n.up.set(0,1,0),n.lookAt(1,0,0),i.up.set(0,1,0),i.lookAt(-1,0,0),s.up.set(0,0,-1),s.lookAt(0,1,0),a.up.set(0,0,1),a.lookAt(0,-1,0),o.up.set(0,1,0),o.lookAt(0,0,1),u.up.set(0,1,0),u.lookAt(0,0,-1);else if(e===Kp)n.up.set(0,-1,0),n.lookAt(-1,0,0),i.up.set(0,-1,0),i.lookAt(1,0,0),s.up.set(0,0,1),s.lookAt(0,1,0),a.up.set(0,0,-1),a.lookAt(0,-1,0),o.up.set(0,-1,0),o.lookAt(0,0,1),u.up.set(0,-1,0),u.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+e);for(const h of t)this.add(h),h.updateMatrixWorld()}update(e,t){this.parent===null&&this.updateMatrixWorld();const{renderTarget:n,activeMipmapLevel:i}=this;this.coordinateSystem!==e.coordinateSystem&&(this.coordinateSystem=e.coordinateSystem,this.updateCoordinateSystem());const[s,a,o,u,h,p]=this.children,m=e.getRenderTarget(),y=e.getActiveCubeFace(),v=e.getActiveMipmapLevel(),S=e.xr.enabled;e.xr.enabled=!1;const T=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,e.setRenderTarget(n,0,i),e.render(t,s),e.setRenderTarget(n,1,i),e.render(t,a),e.setRenderTarget(n,2,i),e.render(t,o),e.setRenderTarget(n,3,i),e.render(t,u),e.setRenderTarget(n,4,i),e.render(t,h),n.texture.generateMipmaps=T,e.setRenderTarget(n,5,i),e.render(t,p),e.setRenderTarget(m,y,v),e.xr.enabled=S,n.texture.needsPMREMUpdate=!0}}class Em extends br{constructor(e,t,n,i,s,a,o,u,h,p){e=e!==void 0?e:[],t=t!==void 0?t:ul,super(e,t,n,i,s,a,o,u,h,p),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}class JM extends Ca{constructor(e=1,t={}){super(e,e,t),this.isWebGLCubeRenderTarget=!0;const n={width:e,height:e,depth:1},i=[n,n,n,n,n,n];t.encoding!==void 0&&(Pp("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."),t.colorSpace=t.encoding===cu?Hr:Rs),this.texture=new Em(i,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=t.generateMipmaps!==void 0?t.generateMipmaps:!1,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:wr}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.colorSpace=t.colorSpace,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},i=new af(5,5,5),s=new io({name:"CubemapFromEquirect",uniforms:Kh(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:Wi,blending:sl});s.uniforms.tEquirect.value=t;const a=new hi(i,s),o=t.minFilter;return t.minFilter===pu&&(t.minFilter=wr),new ZM(1,10,this).update(e,a),t.minFilter=o,a.geometry.dispose(),a.material.dispose(),this}clear(e,t,n,i){const s=e.getRenderTarget();for(let a=0;a<6;a++)e.setRenderTarget(this,a),e.clear(t,n,i);e.setRenderTarget(s)}}const c_=new X,Xk=new X,Kk=new rn;class Jo{constructor(e=new X(1,0,0),t=0){this.isPlane=!0,this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,n,i){return this.normal.set(e,t,n),this.constant=i,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,n){const i=c_.subVectors(n,t).cross(Xk.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(i,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(e).addScaledVector(this.normal,-this.distanceToPoint(e))}intersectLine(e,t){const n=e.delta(c_),i=this.normal.dot(n);if(i===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const s=-(e.start.dot(this.normal)+this.constant)/i;return s<0||s>1?null:t.copy(e.start).addScaledVector(n,s)}intersectsLine(e){const t=this.distanceToPoint(e.start),n=this.distanceToPoint(e.end);return t<0&&n>0||n<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const n=t||Kk.getNormalMatrix(e),i=this.coplanarPoint(c_).applyMatrix4(e),s=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(s),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}const _c=new Ia,ty=new X;class A0{constructor(e=new Jo,t=new Jo,n=new Jo,i=new Jo,s=new Jo,a=new Jo){this.planes=[e,t,n,i,s,a]}set(e,t,n,i,s,a){const o=this.planes;return o[0].copy(e),o[1].copy(t),o[2].copy(n),o[3].copy(i),o[4].copy(s),o[5].copy(a),this}copy(e){const t=this.planes;for(let n=0;n<6;n++)t[n].copy(e.planes[n]);return this}setFromProjectionMatrix(e,t=Qa){const n=this.planes,i=e.elements,s=i[0],a=i[1],o=i[2],u=i[3],h=i[4],p=i[5],m=i[6],y=i[7],v=i[8],S=i[9],T=i[10],E=i[11],w=i[12],C=i[13],A=i[14],I=i[15];if(n[0].setComponents(u-s,y-h,E-v,I-w).normalize(),n[1].setComponents(u+s,y+h,E+v,I+w).normalize(),n[2].setComponents(u+a,y+p,E+S,I+C).normalize(),n[3].setComponents(u-a,y-p,E-S,I-C).normalize(),n[4].setComponents(u-o,y-m,E-T,I-A).normalize(),t===Qa)n[5].setComponents(u+o,y+m,E+T,I+A).normalize();else if(t===Kp)n[5].setComponents(o,m,T,A).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+t);return this}intersectsObject(e){if(e.boundingSphere!==void 0)e.boundingSphere===null&&e.computeBoundingSphere(),_c.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);else{const t=e.geometry;t.boundingSphere===null&&t.computeBoundingSphere(),_c.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)}return this.intersectsSphere(_c)}intersectsSprite(e){return _c.center.set(0,0,0),_c.radius=.7071067811865476,_c.applyMatrix4(e.matrixWorld),this.intersectsSphere(_c)}intersectsSphere(e){const t=this.planes,n=e.center,i=-e.radius;for(let s=0;s<6;s++)if(t[s].distanceToPoint(n)<i)return!1;return!0}intersectsBox(e){const t=this.planes;for(let n=0;n<6;n++){const i=t[n];if(ty.x=i.normal.x>0?e.max.x:e.min.x,ty.y=i.normal.y>0?e.max.y:e.min.y,ty.z=i.normal.z>0?e.max.z:e.min.z,i.distanceToPoint(ty)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let n=0;n<6;n++)if(t[n].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function QM(){let r=null,e=!1,t=null,n=null;function i(s,a){t(s,a),n=r.requestAnimationFrame(i)}return{start:function(){e!==!0&&t!==null&&(n=r.requestAnimationFrame(i),e=!0)},stop:function(){r.cancelAnimationFrame(n),e=!1},setAnimationLoop:function(s){t=s},setContext:function(s){r=s}}}function Yk(r,e){const t=e.isWebGL2,n=new WeakMap;function i(h,p){const m=h.array,y=h.usage,v=r.createBuffer();r.bindBuffer(p,v),r.bufferData(p,m,y),h.onUploadCallback();let S;if(m instanceof Float32Array)S=r.FLOAT;else if(m instanceof Uint16Array)if(h.isFloat16BufferAttribute)if(t)S=r.HALF_FLOAT;else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");else S=r.UNSIGNED_SHORT;else if(m instanceof Int16Array)S=r.SHORT;else if(m instanceof Uint32Array)S=r.UNSIGNED_INT;else if(m instanceof Int32Array)S=r.INT;else if(m instanceof Int8Array)S=r.BYTE;else if(m instanceof Uint8Array)S=r.UNSIGNED_BYTE;else if(m instanceof Uint8ClampedArray)S=r.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+m);return{buffer:v,type:S,bytesPerElement:m.BYTES_PER_ELEMENT,version:h.version}}function s(h,p,m){const y=p.array,v=p.updateRange;r.bindBuffer(m,h),v.count===-1?r.bufferSubData(m,0,y):(t?r.bufferSubData(m,v.offset*y.BYTES_PER_ELEMENT,y,v.offset,v.count):r.bufferSubData(m,v.offset*y.BYTES_PER_ELEMENT,y.subarray(v.offset,v.offset+v.count)),v.count=-1),p.onUploadCallback()}function a(h){return h.isInterleavedBufferAttribute&&(h=h.data),n.get(h)}function o(h){h.isInterleavedBufferAttribute&&(h=h.data);const p=n.get(h);p&&(r.deleteBuffer(p.buffer),n.delete(h))}function u(h,p){if(h.isGLBufferAttribute){const y=n.get(h);(!y||y.version<h.version)&&n.set(h,{buffer:h.buffer,type:h.type,bytesPerElement:h.elementSize,version:h.version});return}h.isInterleavedBufferAttribute&&(h=h.data);const m=n.get(h);m===void 0?n.set(h,i(h,p)):m.version<h.version&&(s(m.buffer,h,p),m.version=h.version)}return{get:a,remove:o,update:u}}class bm extends ln{constructor(e=1,t=1,n=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:n,heightSegments:i};const s=e/2,a=t/2,o=Math.floor(n),u=Math.floor(i),h=o+1,p=u+1,m=e/o,y=t/u,v=[],S=[],T=[],E=[];for(let w=0;w<p;w++){const C=w*y-a;for(let A=0;A<h;A++){const I=A*m-s;S.push(I,-C,0),T.push(0,0,1),E.push(A/o),E.push(1-w/u)}}for(let w=0;w<u;w++)for(let C=0;C<o;C++){const A=C+h*w,I=C+h*(w+1),F=C+1+h*(w+1),U=C+1+h*w;v.push(A,I,U),v.push(I,F,U)}this.setIndex(v),this.setAttribute("position",new At(S,3)),this.setAttribute("normal",new At(T,3)),this.setAttribute("uv",new At(E,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new bm(e.width,e.height,e.widthSegments,e.heightSegments)}}var Zk=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,Jk=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,Qk=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,eD=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,tD=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,nD=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,rD=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,iD=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,sD=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,aD=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,oD=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,lD=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,uD=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,cD=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,fD=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,hD=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,dD=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,pD=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,mD=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,gD=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,yD=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,vD=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,_D=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,xD=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,SD=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,wD=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,ED=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,bD=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,TD="gl_FragColor = linearToOutputTexel( gl_FragColor );",MD=`
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`,AD=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,ND=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,CD=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,RD=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,ID=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,PD=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,LD=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,kD=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,DD=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,OD=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,FD=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,UD=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,zD=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,BD=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,VD=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,HD=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,$D=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,GD=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,WD=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,jD=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,qD=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	anisotropyV /= material.anisotropy;
	material.anisotropy = saturate( material.anisotropy );
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;
#endif`,XD=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,KD=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,YD=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,ZD=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,JD=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,QD=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,eO=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,tO=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,nO=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,rO=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,iO=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,sO=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,aO=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,oO=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,lO=`#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,uO=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,cO=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,fO=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,hO=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,dO=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,pO=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,mO=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,gO=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,yO=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,vO=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,_O=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,xO=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,SO=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,wO=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,EO=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,bO=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,TO=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,MO=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,AO=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,NO=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,CO=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,RO=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,IO=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,PO=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,LO=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,kO=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,DO=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,OO=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,FO=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,UO=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,zO=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,BO=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,VO=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,HO=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,$O=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,GO=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,WO=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,jO=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,qO=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const XO=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,KO=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,YO=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,ZO=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,JO=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,QO=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,eF=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,tF=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,nF=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,rF=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,iF=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,sF=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,aF=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,oF=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,lF=`#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,uF=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,cF=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fF=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,hF=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,dF=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,pF=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,mF=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,gF=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,yF=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vF=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,_F=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,xF=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,SF=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,wF=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,EF=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,bF=`#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,TF=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,MF=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,AF=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,tn={alphahash_fragment:Zk,alphahash_pars_fragment:Jk,alphamap_fragment:Qk,alphamap_pars_fragment:eD,alphatest_fragment:tD,alphatest_pars_fragment:nD,aomap_fragment:rD,aomap_pars_fragment:iD,begin_vertex:sD,beginnormal_vertex:aD,bsdfs:oD,iridescence_fragment:lD,bumpmap_pars_fragment:uD,clipping_planes_fragment:cD,clipping_planes_pars_fragment:fD,clipping_planes_pars_vertex:hD,clipping_planes_vertex:dD,color_fragment:pD,color_pars_fragment:mD,color_pars_vertex:gD,color_vertex:yD,common:vD,cube_uv_reflection_fragment:_D,defaultnormal_vertex:xD,displacementmap_pars_vertex:SD,displacementmap_vertex:wD,emissivemap_fragment:ED,emissivemap_pars_fragment:bD,colorspace_fragment:TD,colorspace_pars_fragment:MD,envmap_fragment:AD,envmap_common_pars_fragment:ND,envmap_pars_fragment:CD,envmap_pars_vertex:RD,envmap_physical_pars_fragment:HD,envmap_vertex:ID,fog_vertex:PD,fog_pars_vertex:LD,fog_fragment:kD,fog_pars_fragment:DD,gradientmap_pars_fragment:OD,lightmap_fragment:FD,lightmap_pars_fragment:UD,lights_lambert_fragment:zD,lights_lambert_pars_fragment:BD,lights_pars_begin:VD,lights_toon_fragment:$D,lights_toon_pars_fragment:GD,lights_phong_fragment:WD,lights_phong_pars_fragment:jD,lights_physical_fragment:qD,lights_physical_pars_fragment:XD,lights_fragment_begin:KD,lights_fragment_maps:YD,lights_fragment_end:ZD,logdepthbuf_fragment:JD,logdepthbuf_pars_fragment:QD,logdepthbuf_pars_vertex:eO,logdepthbuf_vertex:tO,map_fragment:nO,map_pars_fragment:rO,map_particle_fragment:iO,map_particle_pars_fragment:sO,metalnessmap_fragment:aO,metalnessmap_pars_fragment:oO,morphcolor_vertex:lO,morphnormal_vertex:uO,morphtarget_pars_vertex:cO,morphtarget_vertex:fO,normal_fragment_begin:hO,normal_fragment_maps:dO,normal_pars_fragment:pO,normal_pars_vertex:mO,normal_vertex:gO,normalmap_pars_fragment:yO,clearcoat_normal_fragment_begin:vO,clearcoat_normal_fragment_maps:_O,clearcoat_pars_fragment:xO,iridescence_pars_fragment:SO,opaque_fragment:wO,packing:EO,premultiplied_alpha_fragment:bO,project_vertex:TO,dithering_fragment:MO,dithering_pars_fragment:AO,roughnessmap_fragment:NO,roughnessmap_pars_fragment:CO,shadowmap_pars_fragment:RO,shadowmap_pars_vertex:IO,shadowmap_vertex:PO,shadowmask_pars_fragment:LO,skinbase_vertex:kO,skinning_pars_vertex:DO,skinning_vertex:OO,skinnormal_vertex:FO,specularmap_fragment:UO,specularmap_pars_fragment:zO,tonemapping_fragment:BO,tonemapping_pars_fragment:VO,transmission_fragment:HO,transmission_pars_fragment:$O,uv_pars_fragment:GO,uv_pars_vertex:WO,uv_vertex:jO,worldpos_vertex:qO,background_vert:XO,background_frag:KO,backgroundCube_vert:YO,backgroundCube_frag:ZO,cube_vert:JO,cube_frag:QO,depth_vert:eF,depth_frag:tF,distanceRGBA_vert:nF,distanceRGBA_frag:rF,equirect_vert:iF,equirect_frag:sF,linedashed_vert:aF,linedashed_frag:oF,meshbasic_vert:lF,meshbasic_frag:uF,meshlambert_vert:cF,meshlambert_frag:fF,meshmatcap_vert:hF,meshmatcap_frag:dF,meshnormal_vert:pF,meshnormal_frag:mF,meshphong_vert:gF,meshphong_frag:yF,meshphysical_vert:vF,meshphysical_frag:_F,meshtoon_vert:xF,meshtoon_frag:SF,points_vert:wF,points_frag:EF,shadow_vert:bF,shadow_frag:TF,sprite_vert:MF,sprite_frag:AF},it={common:{diffuse:{value:new yt(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new rn},alphaMap:{value:null},alphaMapTransform:{value:new rn},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new rn}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new rn}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new rn}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new rn},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new rn},normalScale:{value:new Pe(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new rn},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new rn}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new rn}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new rn}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new yt(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new yt(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new rn},alphaTest:{value:0},uvTransform:{value:new rn}},sprite:{diffuse:{value:new yt(16777215)},opacity:{value:1},center:{value:new Pe(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new rn},alphaMap:{value:null},alphaMapTransform:{value:new rn},alphaTest:{value:0}}},ba={basic:{uniforms:Gi([it.common,it.specularmap,it.envmap,it.aomap,it.lightmap,it.fog]),vertexShader:tn.meshbasic_vert,fragmentShader:tn.meshbasic_frag},lambert:{uniforms:Gi([it.common,it.specularmap,it.envmap,it.aomap,it.lightmap,it.emissivemap,it.bumpmap,it.normalmap,it.displacementmap,it.fog,it.lights,{emissive:{value:new yt(0)}}]),vertexShader:tn.meshlambert_vert,fragmentShader:tn.meshlambert_frag},phong:{uniforms:Gi([it.common,it.specularmap,it.envmap,it.aomap,it.lightmap,it.emissivemap,it.bumpmap,it.normalmap,it.displacementmap,it.fog,it.lights,{emissive:{value:new yt(0)},specular:{value:new yt(1118481)},shininess:{value:30}}]),vertexShader:tn.meshphong_vert,fragmentShader:tn.meshphong_frag},standard:{uniforms:Gi([it.common,it.envmap,it.aomap,it.lightmap,it.emissivemap,it.bumpmap,it.normalmap,it.displacementmap,it.roughnessmap,it.metalnessmap,it.fog,it.lights,{emissive:{value:new yt(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:tn.meshphysical_vert,fragmentShader:tn.meshphysical_frag},toon:{uniforms:Gi([it.common,it.aomap,it.lightmap,it.emissivemap,it.bumpmap,it.normalmap,it.displacementmap,it.gradientmap,it.fog,it.lights,{emissive:{value:new yt(0)}}]),vertexShader:tn.meshtoon_vert,fragmentShader:tn.meshtoon_frag},matcap:{uniforms:Gi([it.common,it.bumpmap,it.normalmap,it.displacementmap,it.fog,{matcap:{value:null}}]),vertexShader:tn.meshmatcap_vert,fragmentShader:tn.meshmatcap_frag},points:{uniforms:Gi([it.points,it.fog]),vertexShader:tn.points_vert,fragmentShader:tn.points_frag},dashed:{uniforms:Gi([it.common,it.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:tn.linedashed_vert,fragmentShader:tn.linedashed_frag},depth:{uniforms:Gi([it.common,it.displacementmap]),vertexShader:tn.depth_vert,fragmentShader:tn.depth_frag},normal:{uniforms:Gi([it.common,it.bumpmap,it.normalmap,it.displacementmap,{opacity:{value:1}}]),vertexShader:tn.meshnormal_vert,fragmentShader:tn.meshnormal_frag},sprite:{uniforms:Gi([it.sprite,it.fog]),vertexShader:tn.sprite_vert,fragmentShader:tn.sprite_frag},background:{uniforms:{uvTransform:{value:new rn},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:tn.background_vert,fragmentShader:tn.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1}},vertexShader:tn.backgroundCube_vert,fragmentShader:tn.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:tn.cube_vert,fragmentShader:tn.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:tn.equirect_vert,fragmentShader:tn.equirect_frag},distanceRGBA:{uniforms:Gi([it.common,it.displacementmap,{referencePosition:{value:new X},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:tn.distanceRGBA_vert,fragmentShader:tn.distanceRGBA_frag},shadow:{uniforms:Gi([it.lights,it.fog,{color:{value:new yt(0)},opacity:{value:1}}]),vertexShader:tn.shadow_vert,fragmentShader:tn.shadow_frag}};ba.physical={uniforms:Gi([ba.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new rn},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new rn},clearcoatNormalScale:{value:new Pe(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new rn},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new rn},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new rn},sheen:{value:0},sheenColor:{value:new yt(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new rn},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new rn},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new rn},transmissionSamplerSize:{value:new Pe},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new rn},attenuationDistance:{value:0},attenuationColor:{value:new yt(0)},specularColor:{value:new yt(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new rn},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new rn},anisotropyVector:{value:new Pe},anisotropyMap:{value:null},anisotropyMapTransform:{value:new rn}}]),vertexShader:tn.meshphysical_vert,fragmentShader:tn.meshphysical_frag};const ny={r:0,b:0,g:0};function NF(r,e,t,n,i,s,a){const o=new yt(0);let u=s===!0?0:1,h,p,m=null,y=0,v=null;function S(E,w){let C=!1,A=w.isScene===!0?w.background:null;A&&A.isTexture&&(A=(w.backgroundBlurriness>0?t:e).get(A)),A===null?T(o,u):A&&A.isColor&&(T(A,1),C=!0);const I=r.xr.getEnvironmentBlendMode();I==="additive"?n.buffers.color.setClear(0,0,0,1,a):I==="alpha-blend"&&n.buffers.color.setClear(0,0,0,0,a),(r.autoClear||C)&&r.clear(r.autoClearColor,r.autoClearDepth,r.autoClearStencil),A&&(A.isCubeTexture||A.mapping===ad)?(p===void 0&&(p=new hi(new af(1,1,1),new io({name:"BackgroundCubeMaterial",uniforms:Kh(ba.backgroundCube.uniforms),vertexShader:ba.backgroundCube.vertexShader,fragmentShader:ba.backgroundCube.fragmentShader,side:Wi,depthTest:!1,depthWrite:!1,fog:!1})),p.geometry.deleteAttribute("normal"),p.geometry.deleteAttribute("uv"),p.onBeforeRender=function(F,U,V){this.matrixWorld.copyPosition(V.matrixWorld)},Object.defineProperty(p.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(p)),p.material.uniforms.envMap.value=A,p.material.uniforms.flipEnvMap.value=A.isCubeTexture&&A.isRenderTargetTexture===!1?-1:1,p.material.uniforms.backgroundBlurriness.value=w.backgroundBlurriness,p.material.uniforms.backgroundIntensity.value=w.backgroundIntensity,p.material.toneMapped=Nn.getTransfer(A.colorSpace)!==qn,(m!==A||y!==A.version||v!==r.toneMapping)&&(p.material.needsUpdate=!0,m=A,y=A.version,v=r.toneMapping),p.layers.enableAll(),E.unshift(p,p.geometry,p.material,0,0,null)):A&&A.isTexture&&(h===void 0&&(h=new hi(new bm(2,2),new io({name:"BackgroundMaterial",uniforms:Kh(ba.background.uniforms),vertexShader:ba.background.vertexShader,fragmentShader:ba.background.fragmentShader,side:ll,depthTest:!1,depthWrite:!1,fog:!1})),h.geometry.deleteAttribute("normal"),Object.defineProperty(h.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(h)),h.material.uniforms.t2D.value=A,h.material.uniforms.backgroundIntensity.value=w.backgroundIntensity,h.material.toneMapped=Nn.getTransfer(A.colorSpace)!==qn,A.matrixAutoUpdate===!0&&A.updateMatrix(),h.material.uniforms.uvTransform.value.copy(A.matrix),(m!==A||y!==A.version||v!==r.toneMapping)&&(h.material.needsUpdate=!0,m=A,y=A.version,v=r.toneMapping),h.layers.enableAll(),E.unshift(h,h.geometry,h.material,0,0,null))}function T(E,w){E.getRGB(ny,KM(r)),n.buffers.color.setClear(ny.r,ny.g,ny.b,w,a)}return{getClearColor:function(){return o},setClearColor:function(E,w=1){o.set(E),u=w,T(o,u)},getClearAlpha:function(){return u},setClearAlpha:function(E){u=E,T(o,u)},render:S}}function CF(r,e,t,n){const i=r.getParameter(r.MAX_VERTEX_ATTRIBS),s=n.isWebGL2?null:e.get("OES_vertex_array_object"),a=n.isWebGL2||s!==null,o={},u=E(null);let h=u,p=!1;function m(K,ce,de,me,Z){let re=!1;if(a){const ee=T(me,de,ce);h!==ee&&(h=ee,v(h.object)),re=w(K,me,de,Z),re&&C(K,me,de,Z)}else{const ee=ce.wireframe===!0;(h.geometry!==me.id||h.program!==de.id||h.wireframe!==ee)&&(h.geometry=me.id,h.program=de.id,h.wireframe=ee,re=!0)}Z!==null&&t.update(Z,r.ELEMENT_ARRAY_BUFFER),(re||p)&&(p=!1,G(K,ce,de,me),Z!==null&&r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,t.get(Z).buffer))}function y(){return n.isWebGL2?r.createVertexArray():s.createVertexArrayOES()}function v(K){return n.isWebGL2?r.bindVertexArray(K):s.bindVertexArrayOES(K)}function S(K){return n.isWebGL2?r.deleteVertexArray(K):s.deleteVertexArrayOES(K)}function T(K,ce,de){const me=de.wireframe===!0;let Z=o[K.id];Z===void 0&&(Z={},o[K.id]=Z);let re=Z[ce.id];re===void 0&&(re={},Z[ce.id]=re);let ee=re[me];return ee===void 0&&(ee=E(y()),re[me]=ee),ee}function E(K){const ce=[],de=[],me=[];for(let Z=0;Z<i;Z++)ce[Z]=0,de[Z]=0,me[Z]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:ce,enabledAttributes:de,attributeDivisors:me,object:K,attributes:{},index:null}}function w(K,ce,de,me){const Z=h.attributes,re=ce.attributes;let ee=0;const z=de.getAttributes();for(const q in z)if(z[q].location>=0){const Ce=Z[q];let ke=re[q];if(ke===void 0&&(q==="instanceMatrix"&&K.instanceMatrix&&(ke=K.instanceMatrix),q==="instanceColor"&&K.instanceColor&&(ke=K.instanceColor)),Ce===void 0||Ce.attribute!==ke||ke&&Ce.data!==ke.data)return!0;ee++}return h.attributesNum!==ee||h.index!==me}function C(K,ce,de,me){const Z={},re=ce.attributes;let ee=0;const z=de.getAttributes();for(const q in z)if(z[q].location>=0){let Ce=re[q];Ce===void 0&&(q==="instanceMatrix"&&K.instanceMatrix&&(Ce=K.instanceMatrix),q==="instanceColor"&&K.instanceColor&&(Ce=K.instanceColor));const ke={};ke.attribute=Ce,Ce&&Ce.data&&(ke.data=Ce.data),Z[q]=ke,ee++}h.attributes=Z,h.attributesNum=ee,h.index=me}function A(){const K=h.newAttributes;for(let ce=0,de=K.length;ce<de;ce++)K[ce]=0}function I(K){F(K,0)}function F(K,ce){const de=h.newAttributes,me=h.enabledAttributes,Z=h.attributeDivisors;de[K]=1,me[K]===0&&(r.enableVertexAttribArray(K),me[K]=1),Z[K]!==ce&&((n.isWebGL2?r:e.get("ANGLE_instanced_arrays"))[n.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](K,ce),Z[K]=ce)}function U(){const K=h.newAttributes,ce=h.enabledAttributes;for(let de=0,me=ce.length;de<me;de++)ce[de]!==K[de]&&(r.disableVertexAttribArray(de),ce[de]=0)}function V(K,ce,de,me,Z,re,ee){ee===!0?r.vertexAttribIPointer(K,ce,de,Z,re):r.vertexAttribPointer(K,ce,de,me,Z,re)}function G(K,ce,de,me){if(n.isWebGL2===!1&&(K.isInstancedMesh||me.isInstancedBufferGeometry)&&e.get("ANGLE_instanced_arrays")===null)return;A();const Z=me.attributes,re=de.getAttributes(),ee=ce.defaultAttributeValues;for(const z in re){const q=re[z];if(q.location>=0){let ve=Z[z];if(ve===void 0&&(z==="instanceMatrix"&&K.instanceMatrix&&(ve=K.instanceMatrix),z==="instanceColor"&&K.instanceColor&&(ve=K.instanceColor)),ve!==void 0){const Ce=ve.normalized,ke=ve.itemSize,We=t.get(ve);if(We===void 0)continue;const tt=We.buffer,nt=We.type,ut=We.bytesPerElement,kt=n.isWebGL2===!0&&(nt===r.INT||nt===r.UNSIGNED_INT||ve.gpuType===bS);if(ve.isInterleavedBufferAttribute){const vt=ve.data,se=vt.stride,Ve=ve.offset;if(vt.isInstancedInterleavedBuffer){for(let Ie=0;Ie<q.locationSize;Ie++)F(q.location+Ie,vt.meshPerAttribute);K.isInstancedMesh!==!0&&me._maxInstanceCount===void 0&&(me._maxInstanceCount=vt.meshPerAttribute*vt.count)}else for(let Ie=0;Ie<q.locationSize;Ie++)I(q.location+Ie);r.bindBuffer(r.ARRAY_BUFFER,tt);for(let Ie=0;Ie<q.locationSize;Ie++)V(q.location+Ie,ke/q.locationSize,nt,Ce,se*ut,(Ve+ke/q.locationSize*Ie)*ut,kt)}else{if(ve.isInstancedBufferAttribute){for(let vt=0;vt<q.locationSize;vt++)F(q.location+vt,ve.meshPerAttribute);K.isInstancedMesh!==!0&&me._maxInstanceCount===void 0&&(me._maxInstanceCount=ve.meshPerAttribute*ve.count)}else for(let vt=0;vt<q.locationSize;vt++)I(q.location+vt);r.bindBuffer(r.ARRAY_BUFFER,tt);for(let vt=0;vt<q.locationSize;vt++)V(q.location+vt,ke/q.locationSize,nt,Ce,ke*ut,ke/q.locationSize*vt*ut,kt)}}else if(ee!==void 0){const Ce=ee[z];if(Ce!==void 0)switch(Ce.length){case 2:r.vertexAttrib2fv(q.location,Ce);break;case 3:r.vertexAttrib3fv(q.location,Ce);break;case 4:r.vertexAttrib4fv(q.location,Ce);break;default:r.vertexAttrib1fv(q.location,Ce)}}}}U()}function L(){Q();for(const K in o){const ce=o[K];for(const de in ce){const me=ce[de];for(const Z in me)S(me[Z].object),delete me[Z];delete ce[de]}delete o[K]}}function k(K){if(o[K.id]===void 0)return;const ce=o[K.id];for(const de in ce){const me=ce[de];for(const Z in me)S(me[Z].object),delete me[Z];delete ce[de]}delete o[K.id]}function O(K){for(const ce in o){const de=o[ce];if(de[K.id]===void 0)continue;const me=de[K.id];for(const Z in me)S(me[Z].object),delete me[Z];delete de[K.id]}}function Q(){le(),p=!0,h!==u&&(h=u,v(h.object))}function le(){u.geometry=null,u.program=null,u.wireframe=!1}return{setup:m,reset:Q,resetDefaultState:le,dispose:L,releaseStatesOfGeometry:k,releaseStatesOfProgram:O,initAttributes:A,enableAttribute:I,disableUnusedAttributes:U}}function RF(r,e,t,n){const i=n.isWebGL2;let s;function a(h){s=h}function o(h,p){r.drawArrays(s,h,p),t.update(p,s,1)}function u(h,p,m){if(m===0)return;let y,v;if(i)y=r,v="drawArraysInstanced";else if(y=e.get("ANGLE_instanced_arrays"),v="drawArraysInstancedANGLE",y===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}y[v](s,h,p,m),t.update(p,s,m)}this.setMode=a,this.render=o,this.renderInstances=u}function IF(r,e,t){let n;function i(){if(n!==void 0)return n;if(e.has("EXT_texture_filter_anisotropic")===!0){const V=e.get("EXT_texture_filter_anisotropic");n=r.getParameter(V.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else n=0;return n}function s(V){if(V==="highp"){if(r.getShaderPrecisionFormat(r.VERTEX_SHADER,r.HIGH_FLOAT).precision>0&&r.getShaderPrecisionFormat(r.FRAGMENT_SHADER,r.HIGH_FLOAT).precision>0)return"highp";V="mediump"}return V==="mediump"&&r.getShaderPrecisionFormat(r.VERTEX_SHADER,r.MEDIUM_FLOAT).precision>0&&r.getShaderPrecisionFormat(r.FRAGMENT_SHADER,r.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}const a=typeof WebGL2RenderingContext<"u"&&r.constructor.name==="WebGL2RenderingContext";let o=t.precision!==void 0?t.precision:"highp";const u=s(o);u!==o&&(console.warn("THREE.WebGLRenderer:",o,"not supported, using",u,"instead."),o=u);const h=a||e.has("WEBGL_draw_buffers"),p=t.logarithmicDepthBuffer===!0,m=r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS),y=r.getParameter(r.MAX_VERTEX_TEXTURE_IMAGE_UNITS),v=r.getParameter(r.MAX_TEXTURE_SIZE),S=r.getParameter(r.MAX_CUBE_MAP_TEXTURE_SIZE),T=r.getParameter(r.MAX_VERTEX_ATTRIBS),E=r.getParameter(r.MAX_VERTEX_UNIFORM_VECTORS),w=r.getParameter(r.MAX_VARYING_VECTORS),C=r.getParameter(r.MAX_FRAGMENT_UNIFORM_VECTORS),A=y>0,I=a||e.has("OES_texture_float"),F=A&&I,U=a?r.getParameter(r.MAX_SAMPLES):0;return{isWebGL2:a,drawBuffers:h,getMaxAnisotropy:i,getMaxPrecision:s,precision:o,logarithmicDepthBuffer:p,maxTextures:m,maxVertexTextures:y,maxTextureSize:v,maxCubemapSize:S,maxAttributes:T,maxVertexUniforms:E,maxVaryings:w,maxFragmentUniforms:C,vertexTextures:A,floatFragmentTextures:I,floatVertexTextures:F,maxSamples:U}}function PF(r){const e=this;let t=null,n=0,i=!1,s=!1;const a=new Jo,o=new rn,u={value:null,needsUpdate:!1};this.uniform=u,this.numPlanes=0,this.numIntersection=0,this.init=function(m,y){const v=m.length!==0||y||n!==0||i;return i=y,n=m.length,v},this.beginShadows=function(){s=!0,p(null)},this.endShadows=function(){s=!1},this.setGlobalState=function(m,y){t=p(m,y,0)},this.setState=function(m,y,v){const S=m.clippingPlanes,T=m.clipIntersection,E=m.clipShadows,w=r.get(m);if(!i||S===null||S.length===0||s&&!E)s?p(null):h();else{const C=s?0:n,A=C*4;let I=w.clippingState||null;u.value=I,I=p(S,y,A,v);for(let F=0;F!==A;++F)I[F]=t[F];w.clippingState=I,this.numIntersection=T?this.numPlanes:0,this.numPlanes+=C}};function h(){u.value!==t&&(u.value=t,u.needsUpdate=n>0),e.numPlanes=n,e.numIntersection=0}function p(m,y,v,S){const T=m!==null?m.length:0;let E=null;if(T!==0){if(E=u.value,S!==!0||E===null){const w=v+T*4,C=y.matrixWorldInverse;o.getNormalMatrix(C),(E===null||E.length<w)&&(E=new Float32Array(w));for(let A=0,I=v;A!==T;++A,I+=4)a.copy(m[A]).applyMatrix4(C,o),a.normal.toArray(E,I),E[I+3]=a.constant}u.value=E,u.needsUpdate=!0}return e.numPlanes=T,e.numIntersection=0,E}}function LF(r){let e=new WeakMap;function t(a,o){return o===Up?a.mapping=ul:o===zp&&(a.mapping=du),a}function n(a){if(a&&a.isTexture&&a.isRenderTargetTexture===!1){const o=a.mapping;if(o===Up||o===zp)if(e.has(a)){const u=e.get(a).texture;return t(u,a.mapping)}else{const u=a.image;if(u&&u.height>0){const h=new JM(u.height/2);return h.fromEquirectangularTexture(r,a),e.set(a,h),a.addEventListener("dispose",i),t(h.texture,a.mapping)}else return null}}return a}function i(a){const o=a.target;o.removeEventListener("dispose",i);const u=e.get(o);u!==void 0&&(e.delete(o),u.dispose())}function s(){e=new WeakMap}return{get:n,dispose:s}}class fu extends wm{constructor(e=-1,t=1,n=1,i=-1,s=.1,a=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=n,this.bottom=i,this.near=s,this.far=a,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,n,i,s,a){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=i,this.view.width=s,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let s=n-e,a=n+e,o=i+t,u=i-t;if(this.view!==null&&this.view.enabled){const h=(this.right-this.left)/this.view.fullWidth/this.zoom,p=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=h*this.view.offsetX,a=s+h*this.view.width,o-=p*this.view.offsetY,u=o-p*this.view.height}this.projectionMatrix.makeOrthographic(s,a,o,u,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}const Fh=4,AE=[.125,.215,.35,.446,.526,.582],Ic=20,f_=new fu,NE=new yt;let h_=null,d_=0,p_=0;const Cc=(1+Math.sqrt(5))/2,bh=1/Cc,CE=[new X(1,1,1),new X(-1,1,1),new X(1,1,-1),new X(-1,1,-1),new X(0,Cc,bh),new X(0,Cc,-bh),new X(bh,0,Cc),new X(-bh,0,Cc),new X(Cc,bh,0),new X(-Cc,bh,0)];class Px{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,n=.1,i=100){h_=this._renderer.getRenderTarget(),d_=this._renderer.getActiveCubeFace(),p_=this._renderer.getActiveMipmapLevel(),this._setSize(256);const s=this._allocateTargets();return s.depthBuffer=!0,this._sceneToCubeUV(e,n,i,s),t>0&&this._blur(s,0,0,t),this._applyPMREM(s),this._cleanup(s),s}fromEquirectangular(e,t=null){return this._fromTexture(e,t)}fromCubemap(e,t=null){return this._fromTexture(e,t)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=PE(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=IE(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(h_,d_,p_),e.scissorTest=!1,ry(e,0,0,e.width,e.height)}_fromTexture(e,t){e.mapping===ul||e.mapping===du?this._setSize(e.image.length===0?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),h_=this._renderer.getRenderTarget(),d_=this._renderer.getActiveCubeFace(),p_=this._renderer.getActiveMipmapLevel();const n=t||this._allocateTargets();return this._textureToCubeUV(e,n),this._applyPMREM(n),this._cleanup(n),n}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,n={magFilter:wr,minFilter:wr,generateMipmaps:!1,type:qh,format:hs,colorSpace:ro,depthBuffer:!1},i=RE(e,t,n);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==e||this._pingPongRenderTarget.height!==t){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=RE(e,t,n);const{_lodMax:s}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=kF(s)),this._blurMaterial=DF(s,e,t)}return i}_compileMaterial(e){const t=new hi(this._lodPlanes[0],e);this._renderer.compile(t,f_)}_sceneToCubeUV(e,t,n,i){const o=new Er(90,1,t,n),u=[1,-1,1,1,1,1],h=[1,1,1,-1,-1,-1],p=this._renderer,m=p.autoClear,y=p.toneMapping;p.getClearColor(NE),p.toneMapping=eo,p.autoClear=!1;const v=new Eu({name:"PMREM.Background",side:Wi,depthWrite:!1,depthTest:!1}),S=new hi(new af,v);let T=!1;const E=e.background;E?E.isColor&&(v.color.copy(E),e.background=null,T=!0):(v.color.copy(NE),T=!0);for(let w=0;w<6;w++){const C=w%3;C===0?(o.up.set(0,u[w],0),o.lookAt(h[w],0,0)):C===1?(o.up.set(0,0,u[w]),o.lookAt(0,h[w],0)):(o.up.set(0,u[w],0),o.lookAt(0,0,h[w]));const A=this._cubeSize;ry(i,C*A,w>2?A:0,A,A),p.setRenderTarget(i),T&&p.render(S,o),p.render(e,o)}S.geometry.dispose(),S.material.dispose(),p.toneMapping=y,p.autoClear=m,e.background=E}_textureToCubeUV(e,t){const n=this._renderer,i=e.mapping===ul||e.mapping===du;i?(this._cubemapMaterial===null&&(this._cubemapMaterial=PE()),this._cubemapMaterial.uniforms.flipEnvMap.value=e.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=IE());const s=i?this._cubemapMaterial:this._equirectMaterial,a=new hi(this._lodPlanes[0],s),o=s.uniforms;o.envMap.value=e;const u=this._cubeSize;ry(t,0,0,3*u,2*u),n.setRenderTarget(t),n.render(a,f_)}_applyPMREM(e){const t=this._renderer,n=t.autoClear;t.autoClear=!1;for(let i=1;i<this._lodPlanes.length;i++){const s=Math.sqrt(this._sigmas[i]*this._sigmas[i]-this._sigmas[i-1]*this._sigmas[i-1]),a=CE[(i-1)%CE.length];this._blur(e,i-1,i,s,a)}t.autoClear=n}_blur(e,t,n,i,s){const a=this._pingPongRenderTarget;this._halfBlur(e,a,t,n,i,"latitudinal",s),this._halfBlur(a,e,n,n,i,"longitudinal",s)}_halfBlur(e,t,n,i,s,a,o){const u=this._renderer,h=this._blurMaterial;a!=="latitudinal"&&a!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const p=3,m=new hi(this._lodPlanes[i],h),y=h.uniforms,v=this._sizeLods[n]-1,S=isFinite(s)?Math.PI/(2*v):2*Math.PI/(2*Ic-1),T=s/S,E=isFinite(s)?1+Math.floor(p*T):Ic;E>Ic&&console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${E} samples when the maximum is set to ${Ic}`);const w=[];let C=0;for(let V=0;V<Ic;++V){const G=V/T,L=Math.exp(-G*G/2);w.push(L),V===0?C+=L:V<E&&(C+=2*L)}for(let V=0;V<w.length;V++)w[V]=w[V]/C;y.envMap.value=e.texture,y.samples.value=E,y.weights.value=w,y.latitudinal.value=a==="latitudinal",o&&(y.poleAxis.value=o);const{_lodMax:A}=this;y.dTheta.value=S,y.mipInt.value=A-n;const I=this._sizeLods[i],F=3*I*(i>A-Fh?i-A+Fh:0),U=4*(this._cubeSize-I);ry(t,F,U,3*I,2*I),u.setRenderTarget(t),u.render(m,f_)}}function kF(r){const e=[],t=[],n=[];let i=r;const s=r-Fh+1+AE.length;for(let a=0;a<s;a++){const o=Math.pow(2,i);t.push(o);let u=1/o;a>r-Fh?u=AE[a-r+Fh-1]:a===0&&(u=0),n.push(u);const h=1/(o-2),p=-h,m=1+h,y=[p,p,m,p,m,m,p,p,m,m,p,m],v=6,S=6,T=3,E=2,w=1,C=new Float32Array(T*S*v),A=new Float32Array(E*S*v),I=new Float32Array(w*S*v);for(let U=0;U<v;U++){const V=U%3*2/3-1,G=U>2?0:-1,L=[V,G,0,V+2/3,G,0,V+2/3,G+1,0,V,G,0,V+2/3,G+1,0,V,G+1,0];C.set(L,T*S*U),A.set(y,E*S*U);const k=[U,U,U,U,U,U];I.set(k,w*S*U)}const F=new ln;F.setAttribute("position",new Hn(C,T)),F.setAttribute("uv",new Hn(A,E)),F.setAttribute("faceIndex",new Hn(I,w)),e.push(F),i>Fh&&i--}return{lodPlanes:e,sizeLods:t,sigmas:n}}function RE(r,e,t){const n=new Ca(r,e,t);return n.texture.mapping=ad,n.texture.name="PMREM.cubeUv",n.scissorTest=!0,n}function ry(r,e,t,n,i){r.viewport.set(e,t,n,i),r.scissor.set(e,t,n,i)}function DF(r,e,t){const n=new Float32Array(Ic),i=new X(0,1,0);return new io({name:"SphericalGaussianBlur",defines:{n:Ic,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/t,CUBEUV_MAX_MIP:`${r}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:n},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:i}},vertexShader:FS(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:sl,depthTest:!1,depthWrite:!1})}function IE(){return new io({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:FS(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:sl,depthTest:!1,depthWrite:!1})}function PE(){return new io({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:FS(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:sl,depthTest:!1,depthWrite:!1})}function FS(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function OF(r){let e=new WeakMap,t=null;function n(o){if(o&&o.isTexture){const u=o.mapping,h=u===Up||u===zp,p=u===ul||u===du;if(h||p)if(o.isRenderTargetTexture&&o.needsPMREMUpdate===!0){o.needsPMREMUpdate=!1;let m=e.get(o);return t===null&&(t=new Px(r)),m=h?t.fromEquirectangular(o,m):t.fromCubemap(o,m),e.set(o,m),m.texture}else{if(e.has(o))return e.get(o).texture;{const m=o.image;if(h&&m&&m.height>0||p&&m&&i(m)){t===null&&(t=new Px(r));const y=h?t.fromEquirectangular(o):t.fromCubemap(o);return e.set(o,y),o.addEventListener("dispose",s),y.texture}else return null}}}return o}function i(o){let u=0;const h=6;for(let p=0;p<h;p++)o[p]!==void 0&&u++;return u===h}function s(o){const u=o.target;u.removeEventListener("dispose",s);const h=e.get(u);h!==void 0&&(e.delete(u),h.dispose())}function a(){e=new WeakMap,t!==null&&(t.dispose(),t=null)}return{get:n,dispose:a}}function FF(r){const e={};function t(n){if(e[n]!==void 0)return e[n];let i;switch(n){case"WEBGL_depth_texture":i=r.getExtension("WEBGL_depth_texture")||r.getExtension("MOZ_WEBGL_depth_texture")||r.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=r.getExtension("EXT_texture_filter_anisotropic")||r.getExtension("MOZ_EXT_texture_filter_anisotropic")||r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=r.getExtension("WEBGL_compressed_texture_s3tc")||r.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=r.getExtension("WEBGL_compressed_texture_pvrtc")||r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=r.getExtension(n)}return e[n]=i,i}return{has:function(n){return t(n)!==null},init:function(n){n.isWebGL2?t("EXT_color_buffer_float"):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture")},get:function(n){const i=t(n);return i===null&&console.warn("THREE.WebGLRenderer: "+n+" extension not supported."),i}}}function UF(r,e,t,n){const i={},s=new WeakMap;function a(m){const y=m.target;y.index!==null&&e.remove(y.index);for(const S in y.attributes)e.remove(y.attributes[S]);for(const S in y.morphAttributes){const T=y.morphAttributes[S];for(let E=0,w=T.length;E<w;E++)e.remove(T[E])}y.removeEventListener("dispose",a),delete i[y.id];const v=s.get(y);v&&(e.remove(v),s.delete(y)),n.releaseStatesOfGeometry(y),y.isInstancedBufferGeometry===!0&&delete y._maxInstanceCount,t.memory.geometries--}function o(m,y){return i[y.id]===!0||(y.addEventListener("dispose",a),i[y.id]=!0,t.memory.geometries++),y}function u(m){const y=m.attributes;for(const S in y)e.update(y[S],r.ARRAY_BUFFER);const v=m.morphAttributes;for(const S in v){const T=v[S];for(let E=0,w=T.length;E<w;E++)e.update(T[E],r.ARRAY_BUFFER)}}function h(m){const y=[],v=m.index,S=m.attributes.position;let T=0;if(v!==null){const C=v.array;T=v.version;for(let A=0,I=C.length;A<I;A+=3){const F=C[A+0],U=C[A+1],V=C[A+2];y.push(F,U,U,V,V,F)}}else if(S!==void 0){const C=S.array;T=S.version;for(let A=0,I=C.length/3-1;A<I;A+=3){const F=A+0,U=A+1,V=A+2;y.push(F,U,U,V,V,F)}}else return;const E=new(WM(y)?OS:DS)(y,1);E.version=T;const w=s.get(m);w&&e.remove(w),s.set(m,E)}function p(m){const y=s.get(m);if(y){const v=m.index;v!==null&&y.version<v.version&&h(m)}else h(m);return s.get(m)}return{get:o,update:u,getWireframeAttribute:p}}function zF(r,e,t,n){const i=n.isWebGL2;let s;function a(y){s=y}let o,u;function h(y){o=y.type,u=y.bytesPerElement}function p(y,v){r.drawElements(s,v,o,y*u),t.update(v,s,1)}function m(y,v,S){if(S===0)return;let T,E;if(i)T=r,E="drawElementsInstanced";else if(T=e.get("ANGLE_instanced_arrays"),E="drawElementsInstancedANGLE",T===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}T[E](s,v,o,y*u,S),t.update(v,s,S)}this.setMode=a,this.setIndex=h,this.render=p,this.renderInstances=m}function BF(r){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function n(s,a,o){switch(t.calls++,a){case r.TRIANGLES:t.triangles+=o*(s/3);break;case r.LINES:t.lines+=o*(s/2);break;case r.LINE_STRIP:t.lines+=o*(s-1);break;case r.LINE_LOOP:t.lines+=o*s;break;case r.POINTS:t.points+=o*s;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",a);break}}function i(){t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:i,update:n}}function VF(r,e){return r[0]-e[0]}function HF(r,e){return Math.abs(e[1])-Math.abs(r[1])}function $F(r,e,t){const n={},i=new Float32Array(8),s=new WeakMap,a=new Cn,o=[];for(let h=0;h<8;h++)o[h]=[h,0];function u(h,p,m){const y=h.morphTargetInfluences;if(e.isWebGL2===!0){const S=p.morphAttributes.position||p.morphAttributes.normal||p.morphAttributes.color,T=S!==void 0?S.length:0;let E=s.get(p);if(E===void 0||E.count!==T){let ce=function(){le.dispose(),s.delete(p),p.removeEventListener("dispose",ce)};var v=ce;E!==void 0&&E.texture.dispose();const A=p.morphAttributes.position!==void 0,I=p.morphAttributes.normal!==void 0,F=p.morphAttributes.color!==void 0,U=p.morphAttributes.position||[],V=p.morphAttributes.normal||[],G=p.morphAttributes.color||[];let L=0;A===!0&&(L=1),I===!0&&(L=2),F===!0&&(L=3);let k=p.attributes.position.count*L,O=1;k>e.maxTextureSize&&(O=Math.ceil(k/e.maxTextureSize),k=e.maxTextureSize);const Q=new Float32Array(k*O*4*T),le=new M0(Q,k,O,T);le.type=Ja,le.needsUpdate=!0;const K=L*4;for(let de=0;de<T;de++){const me=U[de],Z=V[de],re=G[de],ee=k*O*4*de;for(let z=0;z<me.count;z++){const q=z*K;A===!0&&(a.fromBufferAttribute(me,z),Q[ee+q+0]=a.x,Q[ee+q+1]=a.y,Q[ee+q+2]=a.z,Q[ee+q+3]=0),I===!0&&(a.fromBufferAttribute(Z,z),Q[ee+q+4]=a.x,Q[ee+q+5]=a.y,Q[ee+q+6]=a.z,Q[ee+q+7]=0),F===!0&&(a.fromBufferAttribute(re,z),Q[ee+q+8]=a.x,Q[ee+q+9]=a.y,Q[ee+q+10]=a.z,Q[ee+q+11]=re.itemSize===4?a.w:1)}}E={count:T,texture:le,size:new Pe(k,O)},s.set(p,E),p.addEventListener("dispose",ce)}let w=0;for(let A=0;A<y.length;A++)w+=y[A];const C=p.morphTargetsRelative?1:1-w;m.getUniforms().setValue(r,"morphTargetBaseInfluence",C),m.getUniforms().setValue(r,"morphTargetInfluences",y),m.getUniforms().setValue(r,"morphTargetsTexture",E.texture,t),m.getUniforms().setValue(r,"morphTargetsTextureSize",E.size)}else{const S=y===void 0?0:y.length;let T=n[p.id];if(T===void 0||T.length!==S){T=[];for(let I=0;I<S;I++)T[I]=[I,0];n[p.id]=T}for(let I=0;I<S;I++){const F=T[I];F[0]=I,F[1]=y[I]}T.sort(HF);for(let I=0;I<8;I++)I<S&&T[I][1]?(o[I][0]=T[I][0],o[I][1]=T[I][1]):(o[I][0]=Number.MAX_SAFE_INTEGER,o[I][1]=0);o.sort(VF);const E=p.morphAttributes.position,w=p.morphAttributes.normal;let C=0;for(let I=0;I<8;I++){const F=o[I],U=F[0],V=F[1];U!==Number.MAX_SAFE_INTEGER&&V?(E&&p.getAttribute("morphTarget"+I)!==E[U]&&p.setAttribute("morphTarget"+I,E[U]),w&&p.getAttribute("morphNormal"+I)!==w[U]&&p.setAttribute("morphNormal"+I,w[U]),i[I]=V,C+=V):(E&&p.hasAttribute("morphTarget"+I)===!0&&p.deleteAttribute("morphTarget"+I),w&&p.hasAttribute("morphNormal"+I)===!0&&p.deleteAttribute("morphNormal"+I),i[I]=0)}const A=p.morphTargetsRelative?1:1-C;m.getUniforms().setValue(r,"morphTargetBaseInfluence",A),m.getUniforms().setValue(r,"morphTargetInfluences",i)}}return{update:u}}function GF(r,e,t,n){let i=new WeakMap;function s(u){const h=n.render.frame,p=u.geometry,m=e.get(u,p);if(i.get(m)!==h&&(e.update(m),i.set(m,h)),u.isInstancedMesh&&(u.hasEventListener("dispose",o)===!1&&u.addEventListener("dispose",o),i.get(u)!==h&&(t.update(u.instanceMatrix,r.ARRAY_BUFFER),u.instanceColor!==null&&t.update(u.instanceColor,r.ARRAY_BUFFER),i.set(u,h))),u.isSkinnedMesh){const y=u.skeleton;i.get(y)!==h&&(y.update(),i.set(y,h))}return m}function a(){i=new WeakMap}function o(u){const h=u.target;h.removeEventListener("dispose",o),t.remove(h.instanceMatrix),h.instanceColor!==null&&t.remove(h.instanceColor)}return{update:s,dispose:a}}const eA=new br,tA=new M0,nA=new kS,rA=new Em,LE=[],kE=[],DE=new Float32Array(16),OE=new Float32Array(9),FE=new Float32Array(4);function od(r,e,t){const n=r[0];if(n<=0||n>0)return r;const i=e*t;let s=LE[i];if(s===void 0&&(s=new Float32Array(i),LE[i]=s),e!==0){n.toArray(s,0);for(let a=1,o=0;a!==e;++a)o+=t,r[a].toArray(s,o)}return s}function Wr(r,e){if(r.length!==e.length)return!1;for(let t=0,n=r.length;t<n;t++)if(r[t]!==e[t])return!1;return!0}function jr(r,e){for(let t=0,n=e.length;t<n;t++)r[t]=e[t]}function N0(r,e){let t=kE[e];t===void 0&&(t=new Int32Array(e),kE[e]=t);for(let n=0;n!==e;++n)t[n]=r.allocateTextureUnit();return t}function WF(r,e){const t=this.cache;t[0]!==e&&(r.uniform1f(this.addr,e),t[0]=e)}function jF(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(r.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Wr(t,e))return;r.uniform2fv(this.addr,e),jr(t,e)}}function qF(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(r.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(r.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(Wr(t,e))return;r.uniform3fv(this.addr,e),jr(t,e)}}function XF(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(r.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Wr(t,e))return;r.uniform4fv(this.addr,e),jr(t,e)}}function KF(r,e){const t=this.cache,n=e.elements;if(n===void 0){if(Wr(t,e))return;r.uniformMatrix2fv(this.addr,!1,e),jr(t,e)}else{if(Wr(t,n))return;FE.set(n),r.uniformMatrix2fv(this.addr,!1,FE),jr(t,n)}}function YF(r,e){const t=this.cache,n=e.elements;if(n===void 0){if(Wr(t,e))return;r.uniformMatrix3fv(this.addr,!1,e),jr(t,e)}else{if(Wr(t,n))return;OE.set(n),r.uniformMatrix3fv(this.addr,!1,OE),jr(t,n)}}function ZF(r,e){const t=this.cache,n=e.elements;if(n===void 0){if(Wr(t,e))return;r.uniformMatrix4fv(this.addr,!1,e),jr(t,e)}else{if(Wr(t,n))return;DE.set(n),r.uniformMatrix4fv(this.addr,!1,DE),jr(t,n)}}function JF(r,e){const t=this.cache;t[0]!==e&&(r.uniform1i(this.addr,e),t[0]=e)}function QF(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(r.uniform2i(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Wr(t,e))return;r.uniform2iv(this.addr,e),jr(t,e)}}function eU(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(r.uniform3i(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(Wr(t,e))return;r.uniform3iv(this.addr,e),jr(t,e)}}function tU(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(r.uniform4i(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Wr(t,e))return;r.uniform4iv(this.addr,e),jr(t,e)}}function nU(r,e){const t=this.cache;t[0]!==e&&(r.uniform1ui(this.addr,e),t[0]=e)}function rU(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(r.uniform2ui(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Wr(t,e))return;r.uniform2uiv(this.addr,e),jr(t,e)}}function iU(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(r.uniform3ui(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(Wr(t,e))return;r.uniform3uiv(this.addr,e),jr(t,e)}}function sU(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(r.uniform4ui(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Wr(t,e))return;r.uniform4uiv(this.addr,e),jr(t,e)}}function aU(r,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(r.uniform1i(this.addr,i),n[0]=i),t.setTexture2D(e||eA,i)}function oU(r,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(r.uniform1i(this.addr,i),n[0]=i),t.setTexture3D(e||nA,i)}function lU(r,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(r.uniform1i(this.addr,i),n[0]=i),t.setTextureCube(e||rA,i)}function uU(r,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(r.uniform1i(this.addr,i),n[0]=i),t.setTexture2DArray(e||tA,i)}function cU(r){switch(r){case 5126:return WF;case 35664:return jF;case 35665:return qF;case 35666:return XF;case 35674:return KF;case 35675:return YF;case 35676:return ZF;case 5124:case 35670:return JF;case 35667:case 35671:return QF;case 35668:case 35672:return eU;case 35669:case 35673:return tU;case 5125:return nU;case 36294:return rU;case 36295:return iU;case 36296:return sU;case 35678:case 36198:case 36298:case 36306:case 35682:return aU;case 35679:case 36299:case 36307:return oU;case 35680:case 36300:case 36308:case 36293:return lU;case 36289:case 36303:case 36311:case 36292:return uU}}function fU(r,e){r.uniform1fv(this.addr,e)}function hU(r,e){const t=od(e,this.size,2);r.uniform2fv(this.addr,t)}function dU(r,e){const t=od(e,this.size,3);r.uniform3fv(this.addr,t)}function pU(r,e){const t=od(e,this.size,4);r.uniform4fv(this.addr,t)}function mU(r,e){const t=od(e,this.size,4);r.uniformMatrix2fv(this.addr,!1,t)}function gU(r,e){const t=od(e,this.size,9);r.uniformMatrix3fv(this.addr,!1,t)}function yU(r,e){const t=od(e,this.size,16);r.uniformMatrix4fv(this.addr,!1,t)}function vU(r,e){r.uniform1iv(this.addr,e)}function _U(r,e){r.uniform2iv(this.addr,e)}function xU(r,e){r.uniform3iv(this.addr,e)}function SU(r,e){r.uniform4iv(this.addr,e)}function wU(r,e){r.uniform1uiv(this.addr,e)}function EU(r,e){r.uniform2uiv(this.addr,e)}function bU(r,e){r.uniform3uiv(this.addr,e)}function TU(r,e){r.uniform4uiv(this.addr,e)}function MU(r,e,t){const n=this.cache,i=e.length,s=N0(t,i);Wr(n,s)||(r.uniform1iv(this.addr,s),jr(n,s));for(let a=0;a!==i;++a)t.setTexture2D(e[a]||eA,s[a])}function AU(r,e,t){const n=this.cache,i=e.length,s=N0(t,i);Wr(n,s)||(r.uniform1iv(this.addr,s),jr(n,s));for(let a=0;a!==i;++a)t.setTexture3D(e[a]||nA,s[a])}function NU(r,e,t){const n=this.cache,i=e.length,s=N0(t,i);Wr(n,s)||(r.uniform1iv(this.addr,s),jr(n,s));for(let a=0;a!==i;++a)t.setTextureCube(e[a]||rA,s[a])}function CU(r,e,t){const n=this.cache,i=e.length,s=N0(t,i);Wr(n,s)||(r.uniform1iv(this.addr,s),jr(n,s));for(let a=0;a!==i;++a)t.setTexture2DArray(e[a]||tA,s[a])}function RU(r){switch(r){case 5126:return fU;case 35664:return hU;case 35665:return dU;case 35666:return pU;case 35674:return mU;case 35675:return gU;case 35676:return yU;case 5124:case 35670:return vU;case 35667:case 35671:return _U;case 35668:case 35672:return xU;case 35669:case 35673:return SU;case 5125:return wU;case 36294:return EU;case 36295:return bU;case 36296:return TU;case 35678:case 36198:case 36298:case 36306:case 35682:return MU;case 35679:case 36299:case 36307:return AU;case 35680:case 36300:case 36308:case 36293:return NU;case 36289:case 36303:case 36311:case 36292:return CU}}class IU{constructor(e,t,n){this.id=e,this.addr=n,this.cache=[],this.setValue=cU(t.type)}}class PU{constructor(e,t,n){this.id=e,this.addr=n,this.cache=[],this.size=t.size,this.setValue=RU(t.type)}}class LU{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,t,n){const i=this.seq;for(let s=0,a=i.length;s!==a;++s){const o=i[s];o.setValue(e,t[o.id],n)}}}const m_=/(\w+)(\])?(\[|\.)?/g;function UE(r,e){r.seq.push(e),r.map[e.id]=e}function kU(r,e,t){const n=r.name,i=n.length;for(m_.lastIndex=0;;){const s=m_.exec(n),a=m_.lastIndex;let o=s[1];const u=s[2]==="]",h=s[3];if(u&&(o=o|0),h===void 0||h==="["&&a+2===i){UE(t,h===void 0?new IU(o,r,e):new PU(o,r,e));break}else{let m=t.map[o];m===void 0&&(m=new LU(o),UE(t,m)),t=m}}}class Uy{constructor(e,t){this.seq=[],this.map={};const n=e.getProgramParameter(t,e.ACTIVE_UNIFORMS);for(let i=0;i<n;++i){const s=e.getActiveUniform(t,i),a=e.getUniformLocation(t,s.name);kU(s,a,this)}}setValue(e,t,n,i){const s=this.map[t];s!==void 0&&s.setValue(e,n,i)}setOptional(e,t,n){const i=t[n];i!==void 0&&this.setValue(e,n,i)}static upload(e,t,n,i){for(let s=0,a=t.length;s!==a;++s){const o=t[s],u=n[o.id];u.needsUpdate!==!1&&o.setValue(e,u.value,i)}}static seqWithValue(e,t){const n=[];for(let i=0,s=e.length;i!==s;++i){const a=e[i];a.id in t&&n.push(a)}return n}}function zE(r,e,t){const n=r.createShader(e);return r.shaderSource(n,t),r.compileShader(n),n}const DU=37297;let OU=0;function FU(r,e){const t=r.split(`
`),n=[],i=Math.max(e-6,0),s=Math.min(e+6,t.length);for(let a=i;a<s;a++){const o=a+1;n.push(`${o===e?">":" "} ${o}: ${t[a]}`)}return n.join(`
`)}function UU(r){const e=Nn.getPrimaries(Nn.workingColorSpace),t=Nn.getPrimaries(r);let n;switch(e===t?n="":e===qp&&t===jp?n="LinearDisplayP3ToLinearSRGB":e===jp&&t===qp&&(n="LinearSRGBToLinearDisplayP3"),r){case ro:case xm:return[n,"LinearTransferOETF"];case Hr:case T0:return[n,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space:",r),[n,"LinearTransferOETF"]}}function BE(r,e,t){const n=r.getShaderParameter(e,r.COMPILE_STATUS),i=r.getShaderInfoLog(e).trim();if(n&&i==="")return"";const s=/ERROR: 0:(\d+)/.exec(i);if(s){const a=parseInt(s[1]);return t.toUpperCase()+`

`+i+`

`+FU(r.getShaderSource(e),a)}else return i}function zU(r,e){const t=UU(e);return`vec4 ${r}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`}function BU(r,e){let t;switch(e){case gM:t="Linear";break;case yM:t="Reinhard";break;case vM:t="OptimizedCineon";break;case wS:t="ACESFilmic";break;case _M:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+r+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function VU(r){return[r.extensionDerivatives||r.envMapCubeUVHeight||r.bumpMap||r.normalMapTangentSpace||r.clearcoatNormalMap||r.flatShading||r.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(r.extensionFragDepth||r.logarithmicDepthBuffer)&&r.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",r.extensionDrawBuffers&&r.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(r.extensionShaderTextureLOD||r.envMap||r.transmission)&&r.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Tp).join(`
`)}function HU(r){const e=[];for(const t in r){const n=r[t];n!==!1&&e.push("#define "+t+" "+n)}return e.join(`
`)}function $U(r,e){const t={},n=r.getProgramParameter(e,r.ACTIVE_ATTRIBUTES);for(let i=0;i<n;i++){const s=r.getActiveAttrib(e,i),a=s.name;let o=1;s.type===r.FLOAT_MAT2&&(o=2),s.type===r.FLOAT_MAT3&&(o=3),s.type===r.FLOAT_MAT4&&(o=4),t[a]={type:s.type,location:r.getAttribLocation(e,a),locationSize:o}}return t}function Tp(r){return r!==""}function VE(r,e){const t=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return r.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,t).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function HE(r,e){return r.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const GU=/^[ \t]*#include +<([\w\d./]+)>/gm;function Lx(r){return r.replace(GU,jU)}const WU=new Map([["encodings_fragment","colorspace_fragment"],["encodings_pars_fragment","colorspace_pars_fragment"],["output_fragment","opaque_fragment"]]);function jU(r,e){let t=tn[e];if(t===void 0){const n=WU.get(e);if(n!==void 0)t=tn[n],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',e,n);else throw new Error("Can not resolve #include <"+e+">")}return Lx(t)}const qU=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function $E(r){return r.replace(qU,XU)}function XU(r,e,t,n){let i="";for(let s=parseInt(e);s<parseInt(t);s++)i+=n.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return i}function GE(r){let e="precision "+r.precision+` float;
precision `+r.precision+" int;";return r.precision==="highp"?e+=`
#define HIGH_PRECISION`:r.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:r.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function KU(r){let e="SHADOWMAP_TYPE_BASIC";return r.shadowMapType===S0?e="SHADOWMAP_TYPE_PCF":r.shadowMapType===Cp?e="SHADOWMAP_TYPE_PCF_SOFT":r.shadowMapType===Ea&&(e="SHADOWMAP_TYPE_VSM"),e}function YU(r){let e="ENVMAP_TYPE_CUBE";if(r.envMap)switch(r.envMapMode){case ul:case du:e="ENVMAP_TYPE_CUBE";break;case ad:e="ENVMAP_TYPE_CUBE_UV";break}return e}function ZU(r){let e="ENVMAP_MODE_REFLECTION";if(r.envMap)switch(r.envMapMode){case du:e="ENVMAP_MODE_REFRACTION";break}return e}function JU(r){let e="ENVMAP_BLENDING_NONE";if(r.envMap)switch(r.combine){case _m:e="ENVMAP_BLENDING_MULTIPLY";break;case pM:e="ENVMAP_BLENDING_MIX";break;case mM:e="ENVMAP_BLENDING_ADD";break}return e}function QU(r){const e=r.envMapCubeUVHeight;if(e===null)return null;const t=Math.log2(e)-2,n=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,t),7*16)),texelHeight:n,maxMip:t}}function ez(r,e,t,n){const i=r.getContext(),s=t.defines;let a=t.vertexShader,o=t.fragmentShader;const u=KU(t),h=YU(t),p=ZU(t),m=JU(t),y=QU(t),v=t.isWebGL2?"":VU(t),S=HU(s),T=i.createProgram();let E,w,C=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(E=["#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,S].filter(Tp).join(`
`),E.length>0&&(E+=`
`),w=[v,"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,S].filter(Tp).join(`
`),w.length>0&&(w+=`
`)):(E=[GE(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,S,t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+p:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.displacementMap?"#define USE_DISPLACEMENTMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaHash?"#define USE_ALPHAHASH":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.mapUv?"#define MAP_UV "+t.mapUv:"",t.alphaMapUv?"#define ALPHAMAP_UV "+t.alphaMapUv:"",t.lightMapUv?"#define LIGHTMAP_UV "+t.lightMapUv:"",t.aoMapUv?"#define AOMAP_UV "+t.aoMapUv:"",t.emissiveMapUv?"#define EMISSIVEMAP_UV "+t.emissiveMapUv:"",t.bumpMapUv?"#define BUMPMAP_UV "+t.bumpMapUv:"",t.normalMapUv?"#define NORMALMAP_UV "+t.normalMapUv:"",t.displacementMapUv?"#define DISPLACEMENTMAP_UV "+t.displacementMapUv:"",t.metalnessMapUv?"#define METALNESSMAP_UV "+t.metalnessMapUv:"",t.roughnessMapUv?"#define ROUGHNESSMAP_UV "+t.roughnessMapUv:"",t.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+t.anisotropyMapUv:"",t.clearcoatMapUv?"#define CLEARCOATMAP_UV "+t.clearcoatMapUv:"",t.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+t.clearcoatNormalMapUv:"",t.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+t.clearcoatRoughnessMapUv:"",t.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+t.iridescenceMapUv:"",t.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+t.iridescenceThicknessMapUv:"",t.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+t.sheenColorMapUv:"",t.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+t.sheenRoughnessMapUv:"",t.specularMapUv?"#define SPECULARMAP_UV "+t.specularMapUv:"",t.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+t.specularColorMapUv:"",t.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+t.specularIntensityMapUv:"",t.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+t.transmissionMapUv:"",t.thicknessMapUv?"#define THICKNESSMAP_UV "+t.thicknessMapUv:"",t.vertexTangents&&t.flatShading===!1?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.morphColors&&t.isWebGL2?"#define USE_MORPHCOLORS":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+t.morphTextureStride:"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+u:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.numLightProbes>0?"#define USE_LIGHT_PROBES":"",t.useLegacyLights?"#define LEGACY_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Tp).join(`
`),w=[v,GE(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,S,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+h:"",t.envMap?"#define "+p:"",t.envMap?"#define "+m:"",y?"#define CUBEUV_TEXEL_WIDTH "+y.texelWidth:"",y?"#define CUBEUV_TEXEL_HEIGHT "+y.texelHeight:"",y?"#define CUBEUV_MAX_MIP "+y.maxMip+".0":"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescence?"#define USE_IRIDESCENCE":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.alphaHash?"#define USE_ALPHAHASH":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.vertexTangents&&t.flatShading===!1?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+u:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.numLightProbes>0?"#define USE_LIGHT_PROBES":"",t.useLegacyLights?"#define LEGACY_LIGHTS":"",t.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==eo?"#define TONE_MAPPING":"",t.toneMapping!==eo?tn.tonemapping_pars_fragment:"",t.toneMapping!==eo?BU("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.opaque?"#define OPAQUE":"",tn.colorspace_pars_fragment,zU("linearToOutputTexel",t.outputColorSpace),t.useDepthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(Tp).join(`
`)),a=Lx(a),a=VE(a,t),a=HE(a,t),o=Lx(o),o=VE(o,t),o=HE(o,t),a=$E(a),o=$E(o),t.isWebGL2&&t.isRawShaderMaterial!==!0&&(C=`#version 300 es
`,E=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+E,w=["precision mediump sampler2DArray;","#define varying in",t.glslVersion===Rx?"":"layout(location = 0) out highp vec4 pc_fragColor;",t.glslVersion===Rx?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+w);const A=C+E+a,I=C+w+o,F=zE(i,i.VERTEX_SHADER,A),U=zE(i,i.FRAGMENT_SHADER,I);i.attachShader(T,F),i.attachShader(T,U),t.index0AttributeName!==void 0?i.bindAttribLocation(T,0,t.index0AttributeName):t.morphTargets===!0&&i.bindAttribLocation(T,0,"position"),i.linkProgram(T);function V(O){if(r.debug.checkShaderErrors){const Q=i.getProgramInfoLog(T).trim(),le=i.getShaderInfoLog(F).trim(),K=i.getShaderInfoLog(U).trim();let ce=!0,de=!0;if(i.getProgramParameter(T,i.LINK_STATUS)===!1)if(ce=!1,typeof r.debug.onShaderError=="function")r.debug.onShaderError(i,T,F,U);else{const me=BE(i,F,"vertex"),Z=BE(i,U,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(T,i.VALIDATE_STATUS)+`

Program Info Log: `+Q+`
`+me+`
`+Z)}else Q!==""?console.warn("THREE.WebGLProgram: Program Info Log:",Q):(le===""||K==="")&&(de=!1);de&&(O.diagnostics={runnable:ce,programLog:Q,vertexShader:{log:le,prefix:E},fragmentShader:{log:K,prefix:w}})}i.deleteShader(F),i.deleteShader(U),G=new Uy(i,T),L=$U(i,T)}let G;this.getUniforms=function(){return G===void 0&&V(this),G};let L;this.getAttributes=function(){return L===void 0&&V(this),L};let k=t.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return k===!1&&(k=i.getProgramParameter(T,DU)),k},this.destroy=function(){n.releaseStatesOfProgram(this),i.deleteProgram(T),this.program=void 0},this.type=t.shaderType,this.name=t.shaderName,this.id=OU++,this.cacheKey=e,this.usedTimes=1,this.program=T,this.vertexShader=F,this.fragmentShader=U,this}let tz=0;class nz{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const t=e.vertexShader,n=e.fragmentShader,i=this._getShaderStage(t),s=this._getShaderStage(n),a=this._getShaderCacheForMaterial(e);return a.has(i)===!1&&(a.add(i),i.usedTimes++),a.has(s)===!1&&(a.add(s),s.usedTimes++),this}remove(e){const t=this.materialCache.get(e);for(const n of t)n.usedTimes--,n.usedTimes===0&&this.shaderCache.delete(n.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const t=this.materialCache;let n=t.get(e);return n===void 0&&(n=new Set,t.set(e,n)),n}_getShaderStage(e){const t=this.shaderCache;let n=t.get(e);return n===void 0&&(n=new rz(e),t.set(e,n)),n}}class rz{constructor(e){this.id=tz++,this.code=e,this.usedTimes=0}}function iz(r,e,t,n,i,s,a){const o=new Hc,u=new nz,h=[],p=i.isWebGL2,m=i.logarithmicDepthBuffer,y=i.vertexTextures;let v=i.precision;const S={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function T(L){return L===0?"uv":`uv${L}`}function E(L,k,O,Q,le){const K=Q.fog,ce=le.geometry,de=L.isMeshStandardMaterial?Q.environment:null,me=(L.isMeshStandardMaterial?t:e).get(L.envMap||de),Z=me&&me.mapping===ad?me.image.height:null,re=S[L.type];L.precision!==null&&(v=i.getMaxPrecision(L.precision),v!==L.precision&&console.warn("THREE.WebGLProgram.getParameters:",L.precision,"not supported, using",v,"instead."));const ee=ce.morphAttributes.position||ce.morphAttributes.normal||ce.morphAttributes.color,z=ee!==void 0?ee.length:0;let q=0;ce.morphAttributes.position!==void 0&&(q=1),ce.morphAttributes.normal!==void 0&&(q=2),ce.morphAttributes.color!==void 0&&(q=3);let ve,Ce,ke,We;if(re){const yn=ba[re];ve=yn.vertexShader,Ce=yn.fragmentShader}else ve=L.vertexShader,Ce=L.fragmentShader,u.update(L),ke=u.getVertexShaderID(L),We=u.getFragmentShaderID(L);const tt=r.getRenderTarget(),nt=le.isInstancedMesh===!0,ut=!!L.map,kt=!!L.matcap,vt=!!me,se=!!L.aoMap,Ve=!!L.lightMap,Ie=!!L.bumpMap,je=!!L.normalMap,De=!!L.displacementMap,bt=!!L.emissiveMap,at=!!L.metalnessMap,dt=!!L.roughnessMap,Pt=L.anisotropy>0,Gt=L.clearcoat>0,wn=L.iridescence>0,J=L.sheen>0,$=L.transmission>0,Se=Pt&&!!L.anisotropyMap,qe=Gt&&!!L.clearcoatMap,Oe=Gt&&!!L.clearcoatNormalMap,He=Gt&&!!L.clearcoatRoughnessMap,St=wn&&!!L.iridescenceMap,Ke=wn&&!!L.iridescenceThicknessMap,rt=J&&!!L.sheenColorMap,zt=J&&!!L.sheenRoughnessMap,un=!!L.specularMap,Xe=!!L.specularColorMap,fn=!!L.specularIntensityMap,ae=$&&!!L.transmissionMap,Ne=$&&!!L.thicknessMap,ze=!!L.gradientMap,Fe=!!L.alphaMap,Ct=L.alphaTest>0,ue=!!L.alphaHash,Qe=!!L.extensions,Ze=!!ce.attributes.uv1,Re=!!ce.attributes.uv2,$e=!!ce.attributes.uv3;let Et=eo;return L.toneMapped&&(tt===null||tt.isXRRenderTarget===!0)&&(Et=r.toneMapping),{isWebGL2:p,shaderID:re,shaderType:L.type,shaderName:L.name,vertexShader:ve,fragmentShader:Ce,defines:L.defines,customVertexShaderID:ke,customFragmentShaderID:We,isRawShaderMaterial:L.isRawShaderMaterial===!0,glslVersion:L.glslVersion,precision:v,instancing:nt,instancingColor:nt&&le.instanceColor!==null,supportsVertexTextures:y,outputColorSpace:tt===null?r.outputColorSpace:tt.isXRRenderTarget===!0?tt.texture.colorSpace:ro,map:ut,matcap:kt,envMap:vt,envMapMode:vt&&me.mapping,envMapCubeUVHeight:Z,aoMap:se,lightMap:Ve,bumpMap:Ie,normalMap:je,displacementMap:y&&De,emissiveMap:bt,normalMapObjectSpace:je&&L.normalMapType===DM,normalMapTangentSpace:je&&L.normalMapType===wu,metalnessMap:at,roughnessMap:dt,anisotropy:Pt,anisotropyMap:Se,clearcoat:Gt,clearcoatMap:qe,clearcoatNormalMap:Oe,clearcoatRoughnessMap:He,iridescence:wn,iridescenceMap:St,iridescenceThicknessMap:Ke,sheen:J,sheenColorMap:rt,sheenRoughnessMap:zt,specularMap:un,specularColorMap:Xe,specularIntensityMap:fn,transmission:$,transmissionMap:ae,thicknessMap:Ne,gradientMap:ze,opaque:L.transparent===!1&&L.blending===Bc,alphaMap:Fe,alphaTest:Ct,alphaHash:ue,combine:L.combine,mapUv:ut&&T(L.map.channel),aoMapUv:se&&T(L.aoMap.channel),lightMapUv:Ve&&T(L.lightMap.channel),bumpMapUv:Ie&&T(L.bumpMap.channel),normalMapUv:je&&T(L.normalMap.channel),displacementMapUv:De&&T(L.displacementMap.channel),emissiveMapUv:bt&&T(L.emissiveMap.channel),metalnessMapUv:at&&T(L.metalnessMap.channel),roughnessMapUv:dt&&T(L.roughnessMap.channel),anisotropyMapUv:Se&&T(L.anisotropyMap.channel),clearcoatMapUv:qe&&T(L.clearcoatMap.channel),clearcoatNormalMapUv:Oe&&T(L.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:He&&T(L.clearcoatRoughnessMap.channel),iridescenceMapUv:St&&T(L.iridescenceMap.channel),iridescenceThicknessMapUv:Ke&&T(L.iridescenceThicknessMap.channel),sheenColorMapUv:rt&&T(L.sheenColorMap.channel),sheenRoughnessMapUv:zt&&T(L.sheenRoughnessMap.channel),specularMapUv:un&&T(L.specularMap.channel),specularColorMapUv:Xe&&T(L.specularColorMap.channel),specularIntensityMapUv:fn&&T(L.specularIntensityMap.channel),transmissionMapUv:ae&&T(L.transmissionMap.channel),thicknessMapUv:Ne&&T(L.thicknessMap.channel),alphaMapUv:Fe&&T(L.alphaMap.channel),vertexTangents:!!ce.attributes.tangent&&(je||Pt),vertexColors:L.vertexColors,vertexAlphas:L.vertexColors===!0&&!!ce.attributes.color&&ce.attributes.color.itemSize===4,vertexUv1s:Ze,vertexUv2s:Re,vertexUv3s:$e,pointsUvs:le.isPoints===!0&&!!ce.attributes.uv&&(ut||Fe),fog:!!K,useFog:L.fog===!0,fogExp2:K&&K.isFogExp2,flatShading:L.flatShading===!0,sizeAttenuation:L.sizeAttenuation===!0,logarithmicDepthBuffer:m,skinning:le.isSkinnedMesh===!0,morphTargets:ce.morphAttributes.position!==void 0,morphNormals:ce.morphAttributes.normal!==void 0,morphColors:ce.morphAttributes.color!==void 0,morphTargetsCount:z,morphTextureStride:q,numDirLights:k.directional.length,numPointLights:k.point.length,numSpotLights:k.spot.length,numSpotLightMaps:k.spotLightMap.length,numRectAreaLights:k.rectArea.length,numHemiLights:k.hemi.length,numDirLightShadows:k.directionalShadowMap.length,numPointLightShadows:k.pointShadowMap.length,numSpotLightShadows:k.spotShadowMap.length,numSpotLightShadowsWithMaps:k.numSpotLightShadowsWithMaps,numLightProbes:k.numLightProbes,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,dithering:L.dithering,shadowMapEnabled:r.shadowMap.enabled&&O.length>0,shadowMapType:r.shadowMap.type,toneMapping:Et,useLegacyLights:r._useLegacyLights,decodeVideoTexture:ut&&L.map.isVideoTexture===!0&&Nn.getTransfer(L.map.colorSpace)===qn,premultipliedAlpha:L.premultipliedAlpha,doubleSided:L.side===Za,flipSided:L.side===Wi,useDepthPacking:L.depthPacking>=0,depthPacking:L.depthPacking||0,index0AttributeName:L.index0AttributeName,extensionDerivatives:Qe&&L.extensions.derivatives===!0,extensionFragDepth:Qe&&L.extensions.fragDepth===!0,extensionDrawBuffers:Qe&&L.extensions.drawBuffers===!0,extensionShaderTextureLOD:Qe&&L.extensions.shaderTextureLOD===!0,rendererExtensionFragDepth:p||n.has("EXT_frag_depth"),rendererExtensionDrawBuffers:p||n.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:p||n.has("EXT_shader_texture_lod"),rendererExtensionParallelShaderCompile:n.has("KHR_parallel_shader_compile"),customProgramCacheKey:L.customProgramCacheKey()}}function w(L){const k=[];if(L.shaderID?k.push(L.shaderID):(k.push(L.customVertexShaderID),k.push(L.customFragmentShaderID)),L.defines!==void 0)for(const O in L.defines)k.push(O),k.push(L.defines[O]);return L.isRawShaderMaterial===!1&&(C(k,L),A(k,L),k.push(r.outputColorSpace)),k.push(L.customProgramCacheKey),k.join()}function C(L,k){L.push(k.precision),L.push(k.outputColorSpace),L.push(k.envMapMode),L.push(k.envMapCubeUVHeight),L.push(k.mapUv),L.push(k.alphaMapUv),L.push(k.lightMapUv),L.push(k.aoMapUv),L.push(k.bumpMapUv),L.push(k.normalMapUv),L.push(k.displacementMapUv),L.push(k.emissiveMapUv),L.push(k.metalnessMapUv),L.push(k.roughnessMapUv),L.push(k.anisotropyMapUv),L.push(k.clearcoatMapUv),L.push(k.clearcoatNormalMapUv),L.push(k.clearcoatRoughnessMapUv),L.push(k.iridescenceMapUv),L.push(k.iridescenceThicknessMapUv),L.push(k.sheenColorMapUv),L.push(k.sheenRoughnessMapUv),L.push(k.specularMapUv),L.push(k.specularColorMapUv),L.push(k.specularIntensityMapUv),L.push(k.transmissionMapUv),L.push(k.thicknessMapUv),L.push(k.combine),L.push(k.fogExp2),L.push(k.sizeAttenuation),L.push(k.morphTargetsCount),L.push(k.morphAttributeCount),L.push(k.numDirLights),L.push(k.numPointLights),L.push(k.numSpotLights),L.push(k.numSpotLightMaps),L.push(k.numHemiLights),L.push(k.numRectAreaLights),L.push(k.numDirLightShadows),L.push(k.numPointLightShadows),L.push(k.numSpotLightShadows),L.push(k.numSpotLightShadowsWithMaps),L.push(k.numLightProbes),L.push(k.shadowMapType),L.push(k.toneMapping),L.push(k.numClippingPlanes),L.push(k.numClipIntersection),L.push(k.depthPacking)}function A(L,k){o.disableAll(),k.isWebGL2&&o.enable(0),k.supportsVertexTextures&&o.enable(1),k.instancing&&o.enable(2),k.instancingColor&&o.enable(3),k.matcap&&o.enable(4),k.envMap&&o.enable(5),k.normalMapObjectSpace&&o.enable(6),k.normalMapTangentSpace&&o.enable(7),k.clearcoat&&o.enable(8),k.iridescence&&o.enable(9),k.alphaTest&&o.enable(10),k.vertexColors&&o.enable(11),k.vertexAlphas&&o.enable(12),k.vertexUv1s&&o.enable(13),k.vertexUv2s&&o.enable(14),k.vertexUv3s&&o.enable(15),k.vertexTangents&&o.enable(16),k.anisotropy&&o.enable(17),k.alphaHash&&o.enable(18),L.push(o.mask),o.disableAll(),k.fog&&o.enable(0),k.useFog&&o.enable(1),k.flatShading&&o.enable(2),k.logarithmicDepthBuffer&&o.enable(3),k.skinning&&o.enable(4),k.morphTargets&&o.enable(5),k.morphNormals&&o.enable(6),k.morphColors&&o.enable(7),k.premultipliedAlpha&&o.enable(8),k.shadowMapEnabled&&o.enable(9),k.useLegacyLights&&o.enable(10),k.doubleSided&&o.enable(11),k.flipSided&&o.enable(12),k.useDepthPacking&&o.enable(13),k.dithering&&o.enable(14),k.transmission&&o.enable(15),k.sheen&&o.enable(16),k.opaque&&o.enable(17),k.pointsUvs&&o.enable(18),k.decodeVideoTexture&&o.enable(19),L.push(o.mask)}function I(L){const k=S[L.type];let O;if(k){const Q=ba[k];O=YM.clone(Q.uniforms)}else O=L.uniforms;return O}function F(L,k){let O;for(let Q=0,le=h.length;Q<le;Q++){const K=h[Q];if(K.cacheKey===k){O=K,++O.usedTimes;break}}return O===void 0&&(O=new ez(r,k,L,s),h.push(O)),O}function U(L){if(--L.usedTimes===0){const k=h.indexOf(L);h[k]=h[h.length-1],h.pop(),L.destroy()}}function V(L){u.remove(L)}function G(){u.dispose()}return{getParameters:E,getProgramCacheKey:w,getUniforms:I,acquireProgram:F,releaseProgram:U,releaseShaderCache:V,programs:h,dispose:G}}function sz(){let r=new WeakMap;function e(s){let a=r.get(s);return a===void 0&&(a={},r.set(s,a)),a}function t(s){r.delete(s)}function n(s,a,o){r.get(s)[a]=o}function i(){r=new WeakMap}return{get:e,remove:t,update:n,dispose:i}}function az(r,e){return r.groupOrder!==e.groupOrder?r.groupOrder-e.groupOrder:r.renderOrder!==e.renderOrder?r.renderOrder-e.renderOrder:r.material.id!==e.material.id?r.material.id-e.material.id:r.z!==e.z?r.z-e.z:r.id-e.id}function WE(r,e){return r.groupOrder!==e.groupOrder?r.groupOrder-e.groupOrder:r.renderOrder!==e.renderOrder?r.renderOrder-e.renderOrder:r.z!==e.z?e.z-r.z:r.id-e.id}function jE(){const r=[];let e=0;const t=[],n=[],i=[];function s(){e=0,t.length=0,n.length=0,i.length=0}function a(m,y,v,S,T,E){let w=r[e];return w===void 0?(w={id:m.id,object:m,geometry:y,material:v,groupOrder:S,renderOrder:m.renderOrder,z:T,group:E},r[e]=w):(w.id=m.id,w.object=m,w.geometry=y,w.material=v,w.groupOrder=S,w.renderOrder=m.renderOrder,w.z=T,w.group=E),e++,w}function o(m,y,v,S,T,E){const w=a(m,y,v,S,T,E);v.transmission>0?n.push(w):v.transparent===!0?i.push(w):t.push(w)}function u(m,y,v,S,T,E){const w=a(m,y,v,S,T,E);v.transmission>0?n.unshift(w):v.transparent===!0?i.unshift(w):t.unshift(w)}function h(m,y){t.length>1&&t.sort(m||az),n.length>1&&n.sort(y||WE),i.length>1&&i.sort(y||WE)}function p(){for(let m=e,y=r.length;m<y;m++){const v=r[m];if(v.id===null)break;v.id=null,v.object=null,v.geometry=null,v.material=null,v.group=null}}return{opaque:t,transmissive:n,transparent:i,init:s,push:o,unshift:u,finish:p,sort:h}}function oz(){let r=new WeakMap;function e(n,i){const s=r.get(n);let a;return s===void 0?(a=new jE,r.set(n,[a])):i>=s.length?(a=new jE,s.push(a)):a=s[i],a}function t(){r=new WeakMap}return{get:e,dispose:t}}function lz(){const r={};return{get:function(e){if(r[e.id]!==void 0)return r[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new X,color:new yt};break;case"SpotLight":t={position:new X,direction:new X,color:new yt,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new X,color:new yt,distance:0,decay:0};break;case"HemisphereLight":t={direction:new X,skyColor:new yt,groundColor:new yt};break;case"RectAreaLight":t={color:new yt,position:new X,halfWidth:new X,halfHeight:new X};break}return r[e.id]=t,t}}}function uz(){const r={};return{get:function(e){if(r[e.id]!==void 0)return r[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Pe};break;case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Pe};break;case"PointLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Pe,shadowCameraNear:1,shadowCameraFar:1e3};break}return r[e.id]=t,t}}}let cz=0;function fz(r,e){return(e.castShadow?2:0)-(r.castShadow?2:0)+(e.map?1:0)-(r.map?1:0)}function hz(r,e){const t=new lz,n=uz(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let p=0;p<9;p++)i.probe.push(new X);const s=new X,a=new Jt,o=new Jt;function u(p,m){let y=0,v=0,S=0;for(let Q=0;Q<9;Q++)i.probe[Q].set(0,0,0);let T=0,E=0,w=0,C=0,A=0,I=0,F=0,U=0,V=0,G=0,L=0;p.sort(fz);const k=m===!0?Math.PI:1;for(let Q=0,le=p.length;Q<le;Q++){const K=p[Q],ce=K.color,de=K.intensity,me=K.distance,Z=K.shadow&&K.shadow.map?K.shadow.map.texture:null;if(K.isAmbientLight)y+=ce.r*de*k,v+=ce.g*de*k,S+=ce.b*de*k;else if(K.isLightProbe){for(let re=0;re<9;re++)i.probe[re].addScaledVector(K.sh.coefficients[re],de);L++}else if(K.isDirectionalLight){const re=t.get(K);if(re.color.copy(K.color).multiplyScalar(K.intensity*k),K.castShadow){const ee=K.shadow,z=n.get(K);z.shadowBias=ee.bias,z.shadowNormalBias=ee.normalBias,z.shadowRadius=ee.radius,z.shadowMapSize=ee.mapSize,i.directionalShadow[T]=z,i.directionalShadowMap[T]=Z,i.directionalShadowMatrix[T]=K.shadow.matrix,I++}i.directional[T]=re,T++}else if(K.isSpotLight){const re=t.get(K);re.position.setFromMatrixPosition(K.matrixWorld),re.color.copy(ce).multiplyScalar(de*k),re.distance=me,re.coneCos=Math.cos(K.angle),re.penumbraCos=Math.cos(K.angle*(1-K.penumbra)),re.decay=K.decay,i.spot[w]=re;const ee=K.shadow;if(K.map&&(i.spotLightMap[V]=K.map,V++,ee.updateMatrices(K),K.castShadow&&G++),i.spotLightMatrix[w]=ee.matrix,K.castShadow){const z=n.get(K);z.shadowBias=ee.bias,z.shadowNormalBias=ee.normalBias,z.shadowRadius=ee.radius,z.shadowMapSize=ee.mapSize,i.spotShadow[w]=z,i.spotShadowMap[w]=Z,U++}w++}else if(K.isRectAreaLight){const re=t.get(K);re.color.copy(ce).multiplyScalar(de),re.halfWidth.set(K.width*.5,0,0),re.halfHeight.set(0,K.height*.5,0),i.rectArea[C]=re,C++}else if(K.isPointLight){const re=t.get(K);if(re.color.copy(K.color).multiplyScalar(K.intensity*k),re.distance=K.distance,re.decay=K.decay,K.castShadow){const ee=K.shadow,z=n.get(K);z.shadowBias=ee.bias,z.shadowNormalBias=ee.normalBias,z.shadowRadius=ee.radius,z.shadowMapSize=ee.mapSize,z.shadowCameraNear=ee.camera.near,z.shadowCameraFar=ee.camera.far,i.pointShadow[E]=z,i.pointShadowMap[E]=Z,i.pointShadowMatrix[E]=K.shadow.matrix,F++}i.point[E]=re,E++}else if(K.isHemisphereLight){const re=t.get(K);re.skyColor.copy(K.color).multiplyScalar(de*k),re.groundColor.copy(K.groundColor).multiplyScalar(de*k),i.hemi[A]=re,A++}}C>0&&(e.isWebGL2||r.has("OES_texture_float_linear")===!0?(i.rectAreaLTC1=it.LTC_FLOAT_1,i.rectAreaLTC2=it.LTC_FLOAT_2):r.has("OES_texture_half_float_linear")===!0?(i.rectAreaLTC1=it.LTC_HALF_1,i.rectAreaLTC2=it.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),i.ambient[0]=y,i.ambient[1]=v,i.ambient[2]=S;const O=i.hash;(O.directionalLength!==T||O.pointLength!==E||O.spotLength!==w||O.rectAreaLength!==C||O.hemiLength!==A||O.numDirectionalShadows!==I||O.numPointShadows!==F||O.numSpotShadows!==U||O.numSpotMaps!==V||O.numLightProbes!==L)&&(i.directional.length=T,i.spot.length=w,i.rectArea.length=C,i.point.length=E,i.hemi.length=A,i.directionalShadow.length=I,i.directionalShadowMap.length=I,i.pointShadow.length=F,i.pointShadowMap.length=F,i.spotShadow.length=U,i.spotShadowMap.length=U,i.directionalShadowMatrix.length=I,i.pointShadowMatrix.length=F,i.spotLightMatrix.length=U+V-G,i.spotLightMap.length=V,i.numSpotLightShadowsWithMaps=G,i.numLightProbes=L,O.directionalLength=T,O.pointLength=E,O.spotLength=w,O.rectAreaLength=C,O.hemiLength=A,O.numDirectionalShadows=I,O.numPointShadows=F,O.numSpotShadows=U,O.numSpotMaps=V,O.numLightProbes=L,i.version=cz++)}function h(p,m){let y=0,v=0,S=0,T=0,E=0;const w=m.matrixWorldInverse;for(let C=0,A=p.length;C<A;C++){const I=p[C];if(I.isDirectionalLight){const F=i.directional[y];F.direction.setFromMatrixPosition(I.matrixWorld),s.setFromMatrixPosition(I.target.matrixWorld),F.direction.sub(s),F.direction.transformDirection(w),y++}else if(I.isSpotLight){const F=i.spot[S];F.position.setFromMatrixPosition(I.matrixWorld),F.position.applyMatrix4(w),F.direction.setFromMatrixPosition(I.matrixWorld),s.setFromMatrixPosition(I.target.matrixWorld),F.direction.sub(s),F.direction.transformDirection(w),S++}else if(I.isRectAreaLight){const F=i.rectArea[T];F.position.setFromMatrixPosition(I.matrixWorld),F.position.applyMatrix4(w),o.identity(),a.copy(I.matrixWorld),a.premultiply(w),o.extractRotation(a),F.halfWidth.set(I.width*.5,0,0),F.halfHeight.set(0,I.height*.5,0),F.halfWidth.applyMatrix4(o),F.halfHeight.applyMatrix4(o),T++}else if(I.isPointLight){const F=i.point[v];F.position.setFromMatrixPosition(I.matrixWorld),F.position.applyMatrix4(w),v++}else if(I.isHemisphereLight){const F=i.hemi[E];F.direction.setFromMatrixPosition(I.matrixWorld),F.direction.transformDirection(w),E++}}}return{setup:u,setupView:h,state:i}}function qE(r,e){const t=new hz(r,e),n=[],i=[];function s(){n.length=0,i.length=0}function a(m){n.push(m)}function o(m){i.push(m)}function u(m){t.setup(n,m)}function h(m){t.setupView(n,m)}return{init:s,state:{lightsArray:n,shadowsArray:i,lights:t},setupLights:u,setupLightsView:h,pushLight:a,pushShadow:o}}function dz(r,e){let t=new WeakMap;function n(s,a=0){const o=t.get(s);let u;return o===void 0?(u=new qE(r,e),t.set(s,[u])):a>=o.length?(u=new qE(r,e),o.push(u)):u=o[a],u}function i(){t=new WeakMap}return{get:n,dispose:i}}class US extends Ri{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=LM,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}class zS extends Ri{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}const pz=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,mz=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function gz(r,e,t){let n=new A0;const i=new Pe,s=new Pe,a=new Cn,o=new US({depthPacking:kM}),u=new zS,h={},p=t.maxTextureSize,m={[ll]:Wi,[Wi]:ll,[Za]:Za},y=new io({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Pe},radius:{value:4}},vertexShader:pz,fragmentShader:mz}),v=y.clone();v.defines.HORIZONTAL_PASS=1;const S=new ln;S.setAttribute("position",new Hn(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const T=new hi(S,y),E=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=S0;let w=this.type;this.render=function(F,U,V){if(E.enabled===!1||E.autoUpdate===!1&&E.needsUpdate===!1||F.length===0)return;const G=r.getRenderTarget(),L=r.getActiveCubeFace(),k=r.getActiveMipmapLevel(),O=r.state;O.setBlending(sl),O.buffers.color.setClear(1,1,1,1),O.buffers.depth.setTest(!0),O.setScissorTest(!1);const Q=w!==Ea&&this.type===Ea,le=w===Ea&&this.type!==Ea;for(let K=0,ce=F.length;K<ce;K++){const de=F[K],me=de.shadow;if(me===void 0){console.warn("THREE.WebGLShadowMap:",de,"has no shadow.");continue}if(me.autoUpdate===!1&&me.needsUpdate===!1)continue;i.copy(me.mapSize);const Z=me.getFrameExtents();if(i.multiply(Z),s.copy(me.mapSize),(i.x>p||i.y>p)&&(i.x>p&&(s.x=Math.floor(p/Z.x),i.x=s.x*Z.x,me.mapSize.x=s.x),i.y>p&&(s.y=Math.floor(p/Z.y),i.y=s.y*Z.y,me.mapSize.y=s.y)),me.map===null||Q===!0||le===!0){const ee=this.type!==Ea?{minFilter:Sr,magFilter:Sr}:{};me.map!==null&&me.map.dispose(),me.map=new Ca(i.x,i.y,ee),me.map.texture.name=de.name+".shadowMap",me.camera.updateProjectionMatrix()}r.setRenderTarget(me.map),r.clear();const re=me.getViewportCount();for(let ee=0;ee<re;ee++){const z=me.getViewport(ee);a.set(s.x*z.x,s.y*z.y,s.x*z.z,s.y*z.w),O.viewport(a),me.updateMatrices(de,ee),n=me.getFrustum(),I(U,V,me.camera,de,this.type)}me.isPointLightShadow!==!0&&this.type===Ea&&C(me,V),me.needsUpdate=!1}w=this.type,E.needsUpdate=!1,r.setRenderTarget(G,L,k)};function C(F,U){const V=e.update(T);y.defines.VSM_SAMPLES!==F.blurSamples&&(y.defines.VSM_SAMPLES=F.blurSamples,v.defines.VSM_SAMPLES=F.blurSamples,y.needsUpdate=!0,v.needsUpdate=!0),F.mapPass===null&&(F.mapPass=new Ca(i.x,i.y)),y.uniforms.shadow_pass.value=F.map.texture,y.uniforms.resolution.value=F.mapSize,y.uniforms.radius.value=F.radius,r.setRenderTarget(F.mapPass),r.clear(),r.renderBufferDirect(U,null,V,y,T,null),v.uniforms.shadow_pass.value=F.mapPass.texture,v.uniforms.resolution.value=F.mapSize,v.uniforms.radius.value=F.radius,r.setRenderTarget(F.map),r.clear(),r.renderBufferDirect(U,null,V,v,T,null)}function A(F,U,V,G){let L=null;const k=V.isPointLight===!0?F.customDistanceMaterial:F.customDepthMaterial;if(k!==void 0)L=k;else if(L=V.isPointLight===!0?u:o,r.localClippingEnabled&&U.clipShadows===!0&&Array.isArray(U.clippingPlanes)&&U.clippingPlanes.length!==0||U.displacementMap&&U.displacementScale!==0||U.alphaMap&&U.alphaTest>0||U.map&&U.alphaTest>0){const O=L.uuid,Q=U.uuid;let le=h[O];le===void 0&&(le={},h[O]=le);let K=le[Q];K===void 0&&(K=L.clone(),le[Q]=K),L=K}if(L.visible=U.visible,L.wireframe=U.wireframe,G===Ea?L.side=U.shadowSide!==null?U.shadowSide:U.side:L.side=U.shadowSide!==null?U.shadowSide:m[U.side],L.alphaMap=U.alphaMap,L.alphaTest=U.alphaTest,L.map=U.map,L.clipShadows=U.clipShadows,L.clippingPlanes=U.clippingPlanes,L.clipIntersection=U.clipIntersection,L.displacementMap=U.displacementMap,L.displacementScale=U.displacementScale,L.displacementBias=U.displacementBias,L.wireframeLinewidth=U.wireframeLinewidth,L.linewidth=U.linewidth,V.isPointLight===!0&&L.isMeshDistanceMaterial===!0){const O=r.properties.get(L);O.light=V}return L}function I(F,U,V,G,L){if(F.visible===!1)return;if(F.layers.test(U.layers)&&(F.isMesh||F.isLine||F.isPoints)&&(F.castShadow||F.receiveShadow&&L===Ea)&&(!F.frustumCulled||n.intersectsObject(F))){F.modelViewMatrix.multiplyMatrices(V.matrixWorldInverse,F.matrixWorld);const Q=e.update(F),le=F.material;if(Array.isArray(le)){const K=Q.groups;for(let ce=0,de=K.length;ce<de;ce++){const me=K[ce],Z=le[me.materialIndex];if(Z&&Z.visible){const re=A(F,Z,G,L);r.renderBufferDirect(V,null,Q,re,F,me)}}}else if(le.visible){const K=A(F,le,G,L);r.renderBufferDirect(V,null,Q,K,F,null)}}const O=F.children;for(let Q=0,le=O.length;Q<le;Q++)I(O[Q],U,V,G,L)}}function yz(r,e,t){const n=t.isWebGL2;function i(){let ue=!1;const Qe=new Cn;let Ze=null;const Re=new Cn(0,0,0,0);return{setMask:function($e){Ze!==$e&&!ue&&(r.colorMask($e,$e,$e,$e),Ze=$e)},setLocked:function($e){ue=$e},setClear:function($e,Et,Yt,yn,Zn){Zn===!0&&($e*=yn,Et*=yn,Yt*=yn),Qe.set($e,Et,Yt,yn),Re.equals(Qe)===!1&&(r.clearColor($e,Et,Yt,yn),Re.copy(Qe))},reset:function(){ue=!1,Ze=null,Re.set(-1,0,0,0)}}}function s(){let ue=!1,Qe=null,Ze=null,Re=null;return{setTest:function($e){$e?ut(r.DEPTH_TEST):kt(r.DEPTH_TEST)},setMask:function($e){Qe!==$e&&!ue&&(r.depthMask($e),Qe=$e)},setFunc:function($e){if(Ze!==$e){switch($e){case oM:r.depthFunc(r.NEVER);break;case lM:r.depthFunc(r.ALWAYS);break;case uM:r.depthFunc(r.LESS);break;case Fp:r.depthFunc(r.LEQUAL);break;case cM:r.depthFunc(r.EQUAL);break;case fM:r.depthFunc(r.GEQUAL);break;case hM:r.depthFunc(r.GREATER);break;case dM:r.depthFunc(r.NOTEQUAL);break;default:r.depthFunc(r.LEQUAL)}Ze=$e}},setLocked:function($e){ue=$e},setClear:function($e){Re!==$e&&(r.clearDepth($e),Re=$e)},reset:function(){ue=!1,Qe=null,Ze=null,Re=null}}}function a(){let ue=!1,Qe=null,Ze=null,Re=null,$e=null,Et=null,Yt=null,yn=null,Zn=null;return{setTest:function(an){ue||(an?ut(r.STENCIL_TEST):kt(r.STENCIL_TEST))},setMask:function(an){Qe!==an&&!ue&&(r.stencilMask(an),Qe=an)},setFunc:function(an,gr,qr){(Ze!==an||Re!==gr||$e!==qr)&&(r.stencilFunc(an,gr,qr),Ze=an,Re=gr,$e=qr)},setOp:function(an,gr,qr){(Et!==an||Yt!==gr||yn!==qr)&&(r.stencilOp(an,gr,qr),Et=an,Yt=gr,yn=qr)},setLocked:function(an){ue=an},setClear:function(an){Zn!==an&&(r.clearStencil(an),Zn=an)},reset:function(){ue=!1,Qe=null,Ze=null,Re=null,$e=null,Et=null,Yt=null,yn=null,Zn=null}}}const o=new i,u=new s,h=new a,p=new WeakMap,m=new WeakMap;let y={},v={},S=new WeakMap,T=[],E=null,w=!1,C=null,A=null,I=null,F=null,U=null,V=null,G=null,L=new yt(0,0,0),k=0,O=!1,Q=null,le=null,K=null,ce=null,de=null;const me=r.getParameter(r.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let Z=!1,re=0;const ee=r.getParameter(r.VERSION);ee.indexOf("WebGL")!==-1?(re=parseFloat(/^WebGL (\d)/.exec(ee)[1]),Z=re>=1):ee.indexOf("OpenGL ES")!==-1&&(re=parseFloat(/^OpenGL ES (\d)/.exec(ee)[1]),Z=re>=2);let z=null,q={};const ve=r.getParameter(r.SCISSOR_BOX),Ce=r.getParameter(r.VIEWPORT),ke=new Cn().fromArray(ve),We=new Cn().fromArray(Ce);function tt(ue,Qe,Ze,Re){const $e=new Uint8Array(4),Et=r.createTexture();r.bindTexture(ue,Et),r.texParameteri(ue,r.TEXTURE_MIN_FILTER,r.NEAREST),r.texParameteri(ue,r.TEXTURE_MAG_FILTER,r.NEAREST);for(let Yt=0;Yt<Ze;Yt++)n&&(ue===r.TEXTURE_3D||ue===r.TEXTURE_2D_ARRAY)?r.texImage3D(Qe,0,r.RGBA,1,1,Re,0,r.RGBA,r.UNSIGNED_BYTE,$e):r.texImage2D(Qe+Yt,0,r.RGBA,1,1,0,r.RGBA,r.UNSIGNED_BYTE,$e);return Et}const nt={};nt[r.TEXTURE_2D]=tt(r.TEXTURE_2D,r.TEXTURE_2D,1),nt[r.TEXTURE_CUBE_MAP]=tt(r.TEXTURE_CUBE_MAP,r.TEXTURE_CUBE_MAP_POSITIVE_X,6),n&&(nt[r.TEXTURE_2D_ARRAY]=tt(r.TEXTURE_2D_ARRAY,r.TEXTURE_2D_ARRAY,1,1),nt[r.TEXTURE_3D]=tt(r.TEXTURE_3D,r.TEXTURE_3D,1,1)),o.setClear(0,0,0,1),u.setClear(1),h.setClear(0),ut(r.DEPTH_TEST),u.setFunc(Fp),at(!1),dt(Z_),ut(r.CULL_FACE),De(sl);function ut(ue){y[ue]!==!0&&(r.enable(ue),y[ue]=!0)}function kt(ue){y[ue]!==!1&&(r.disable(ue),y[ue]=!1)}function vt(ue,Qe){return v[ue]!==Qe?(r.bindFramebuffer(ue,Qe),v[ue]=Qe,n&&(ue===r.DRAW_FRAMEBUFFER&&(v[r.FRAMEBUFFER]=Qe),ue===r.FRAMEBUFFER&&(v[r.DRAW_FRAMEBUFFER]=Qe)),!0):!1}function se(ue,Qe){let Ze=T,Re=!1;if(ue)if(Ze=S.get(Qe),Ze===void 0&&(Ze=[],S.set(Qe,Ze)),ue.isWebGLMultipleRenderTargets){const $e=ue.texture;if(Ze.length!==$e.length||Ze[0]!==r.COLOR_ATTACHMENT0){for(let Et=0,Yt=$e.length;Et<Yt;Et++)Ze[Et]=r.COLOR_ATTACHMENT0+Et;Ze.length=$e.length,Re=!0}}else Ze[0]!==r.COLOR_ATTACHMENT0&&(Ze[0]=r.COLOR_ATTACHMENT0,Re=!0);else Ze[0]!==r.BACK&&(Ze[0]=r.BACK,Re=!0);Re&&(t.isWebGL2?r.drawBuffers(Ze):e.get("WEBGL_draw_buffers").drawBuffersWEBGL(Ze))}function Ve(ue){return E!==ue?(r.useProgram(ue),E=ue,!0):!1}const Ie={[nu]:r.FUNC_ADD,[jT]:r.FUNC_SUBTRACT,[qT]:r.FUNC_REVERSE_SUBTRACT};if(n)Ie[tx]=r.MIN,Ie[nx]=r.MAX;else{const ue=e.get("EXT_blend_minmax");ue!==null&&(Ie[tx]=ue.MIN_EXT,Ie[nx]=ue.MAX_EXT)}const je={[XT]:r.ZERO,[KT]:r.ONE,[YT]:r.SRC_COLOR,[Zy]:r.SRC_ALPHA,[nM]:r.SRC_ALPHA_SATURATE,[eM]:r.DST_COLOR,[JT]:r.DST_ALPHA,[ZT]:r.ONE_MINUS_SRC_COLOR,[Jy]:r.ONE_MINUS_SRC_ALPHA,[tM]:r.ONE_MINUS_DST_COLOR,[QT]:r.ONE_MINUS_DST_ALPHA,[rM]:r.CONSTANT_COLOR,[iM]:r.ONE_MINUS_CONSTANT_COLOR,[sM]:r.CONSTANT_ALPHA,[aM]:r.ONE_MINUS_CONSTANT_ALPHA};function De(ue,Qe,Ze,Re,$e,Et,Yt,yn,Zn,an){if(ue===sl){w===!0&&(kt(r.BLEND),w=!1);return}if(w===!1&&(ut(r.BLEND),w=!0),ue!==WT){if(ue!==C||an!==O){if((A!==nu||U!==nu)&&(r.blendEquation(r.FUNC_ADD),A=nu,U=nu),an)switch(ue){case Bc:r.blendFuncSeparate(r.ONE,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA);break;case J_:r.blendFunc(r.ONE,r.ONE);break;case Q_:r.blendFuncSeparate(r.ZERO,r.ONE_MINUS_SRC_COLOR,r.ZERO,r.ONE);break;case ex:r.blendFuncSeparate(r.ZERO,r.SRC_COLOR,r.ZERO,r.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",ue);break}else switch(ue){case Bc:r.blendFuncSeparate(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA);break;case J_:r.blendFunc(r.SRC_ALPHA,r.ONE);break;case Q_:r.blendFuncSeparate(r.ZERO,r.ONE_MINUS_SRC_COLOR,r.ZERO,r.ONE);break;case ex:r.blendFunc(r.ZERO,r.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",ue);break}I=null,F=null,V=null,G=null,L.set(0,0,0),k=0,C=ue,O=an}return}$e=$e||Qe,Et=Et||Ze,Yt=Yt||Re,(Qe!==A||$e!==U)&&(r.blendEquationSeparate(Ie[Qe],Ie[$e]),A=Qe,U=$e),(Ze!==I||Re!==F||Et!==V||Yt!==G)&&(r.blendFuncSeparate(je[Ze],je[Re],je[Et],je[Yt]),I=Ze,F=Re,V=Et,G=Yt),(yn.equals(L)===!1||Zn!==k)&&(r.blendColor(yn.r,yn.g,yn.b,Zn),L.copy(yn),k=Zn),C=ue,O=!1}function bt(ue,Qe){ue.side===Za?kt(r.CULL_FACE):ut(r.CULL_FACE);let Ze=ue.side===Wi;Qe&&(Ze=!Ze),at(Ze),ue.blending===Bc&&ue.transparent===!1?De(sl):De(ue.blending,ue.blendEquation,ue.blendSrc,ue.blendDst,ue.blendEquationAlpha,ue.blendSrcAlpha,ue.blendDstAlpha,ue.blendColor,ue.blendAlpha,ue.premultipliedAlpha),u.setFunc(ue.depthFunc),u.setTest(ue.depthTest),u.setMask(ue.depthWrite),o.setMask(ue.colorWrite);const Re=ue.stencilWrite;h.setTest(Re),Re&&(h.setMask(ue.stencilWriteMask),h.setFunc(ue.stencilFunc,ue.stencilRef,ue.stencilFuncMask),h.setOp(ue.stencilFail,ue.stencilZFail,ue.stencilZPass)),Gt(ue.polygonOffset,ue.polygonOffsetFactor,ue.polygonOffsetUnits),ue.alphaToCoverage===!0?ut(r.SAMPLE_ALPHA_TO_COVERAGE):kt(r.SAMPLE_ALPHA_TO_COVERAGE)}function at(ue){Q!==ue&&(ue?r.frontFace(r.CW):r.frontFace(r.CCW),Q=ue)}function dt(ue){ue!==HT?(ut(r.CULL_FACE),ue!==le&&(ue===Z_?r.cullFace(r.BACK):ue===$T?r.cullFace(r.FRONT):r.cullFace(r.FRONT_AND_BACK))):kt(r.CULL_FACE),le=ue}function Pt(ue){ue!==K&&(Z&&r.lineWidth(ue),K=ue)}function Gt(ue,Qe,Ze){ue?(ut(r.POLYGON_OFFSET_FILL),(ce!==Qe||de!==Ze)&&(r.polygonOffset(Qe,Ze),ce=Qe,de=Ze)):kt(r.POLYGON_OFFSET_FILL)}function wn(ue){ue?ut(r.SCISSOR_TEST):kt(r.SCISSOR_TEST)}function J(ue){ue===void 0&&(ue=r.TEXTURE0+me-1),z!==ue&&(r.activeTexture(ue),z=ue)}function $(ue,Qe,Ze){Ze===void 0&&(z===null?Ze=r.TEXTURE0+me-1:Ze=z);let Re=q[Ze];Re===void 0&&(Re={type:void 0,texture:void 0},q[Ze]=Re),(Re.type!==ue||Re.texture!==Qe)&&(z!==Ze&&(r.activeTexture(Ze),z=Ze),r.bindTexture(ue,Qe||nt[ue]),Re.type=ue,Re.texture=Qe)}function Se(){const ue=q[z];ue!==void 0&&ue.type!==void 0&&(r.bindTexture(ue.type,null),ue.type=void 0,ue.texture=void 0)}function qe(){try{r.compressedTexImage2D.apply(r,arguments)}catch(ue){console.error("THREE.WebGLState:",ue)}}function Oe(){try{r.compressedTexImage3D.apply(r,arguments)}catch(ue){console.error("THREE.WebGLState:",ue)}}function He(){try{r.texSubImage2D.apply(r,arguments)}catch(ue){console.error("THREE.WebGLState:",ue)}}function St(){try{r.texSubImage3D.apply(r,arguments)}catch(ue){console.error("THREE.WebGLState:",ue)}}function Ke(){try{r.compressedTexSubImage2D.apply(r,arguments)}catch(ue){console.error("THREE.WebGLState:",ue)}}function rt(){try{r.compressedTexSubImage3D.apply(r,arguments)}catch(ue){console.error("THREE.WebGLState:",ue)}}function zt(){try{r.texStorage2D.apply(r,arguments)}catch(ue){console.error("THREE.WebGLState:",ue)}}function un(){try{r.texStorage3D.apply(r,arguments)}catch(ue){console.error("THREE.WebGLState:",ue)}}function Xe(){try{r.texImage2D.apply(r,arguments)}catch(ue){console.error("THREE.WebGLState:",ue)}}function fn(){try{r.texImage3D.apply(r,arguments)}catch(ue){console.error("THREE.WebGLState:",ue)}}function ae(ue){ke.equals(ue)===!1&&(r.scissor(ue.x,ue.y,ue.z,ue.w),ke.copy(ue))}function Ne(ue){We.equals(ue)===!1&&(r.viewport(ue.x,ue.y,ue.z,ue.w),We.copy(ue))}function ze(ue,Qe){let Ze=m.get(Qe);Ze===void 0&&(Ze=new WeakMap,m.set(Qe,Ze));let Re=Ze.get(ue);Re===void 0&&(Re=r.getUniformBlockIndex(Qe,ue.name),Ze.set(ue,Re))}function Fe(ue,Qe){const Re=m.get(Qe).get(ue);p.get(Qe)!==Re&&(r.uniformBlockBinding(Qe,Re,ue.__bindingPointIndex),p.set(Qe,Re))}function Ct(){r.disable(r.BLEND),r.disable(r.CULL_FACE),r.disable(r.DEPTH_TEST),r.disable(r.POLYGON_OFFSET_FILL),r.disable(r.SCISSOR_TEST),r.disable(r.STENCIL_TEST),r.disable(r.SAMPLE_ALPHA_TO_COVERAGE),r.blendEquation(r.FUNC_ADD),r.blendFunc(r.ONE,r.ZERO),r.blendFuncSeparate(r.ONE,r.ZERO,r.ONE,r.ZERO),r.blendColor(0,0,0,0),r.colorMask(!0,!0,!0,!0),r.clearColor(0,0,0,0),r.depthMask(!0),r.depthFunc(r.LESS),r.clearDepth(1),r.stencilMask(4294967295),r.stencilFunc(r.ALWAYS,0,4294967295),r.stencilOp(r.KEEP,r.KEEP,r.KEEP),r.clearStencil(0),r.cullFace(r.BACK),r.frontFace(r.CCW),r.polygonOffset(0,0),r.activeTexture(r.TEXTURE0),r.bindFramebuffer(r.FRAMEBUFFER,null),n===!0&&(r.bindFramebuffer(r.DRAW_FRAMEBUFFER,null),r.bindFramebuffer(r.READ_FRAMEBUFFER,null)),r.useProgram(null),r.lineWidth(1),r.scissor(0,0,r.canvas.width,r.canvas.height),r.viewport(0,0,r.canvas.width,r.canvas.height),y={},z=null,q={},v={},S=new WeakMap,T=[],E=null,w=!1,C=null,A=null,I=null,F=null,U=null,V=null,G=null,L=new yt(0,0,0),k=0,O=!1,Q=null,le=null,K=null,ce=null,de=null,ke.set(0,0,r.canvas.width,r.canvas.height),We.set(0,0,r.canvas.width,r.canvas.height),o.reset(),u.reset(),h.reset()}return{buffers:{color:o,depth:u,stencil:h},enable:ut,disable:kt,bindFramebuffer:vt,drawBuffers:se,useProgram:Ve,setBlending:De,setMaterial:bt,setFlipSided:at,setCullFace:dt,setLineWidth:Pt,setPolygonOffset:Gt,setScissorTest:wn,activeTexture:J,bindTexture:$,unbindTexture:Se,compressedTexImage2D:qe,compressedTexImage3D:Oe,texImage2D:Xe,texImage3D:fn,updateUBOMapping:ze,uniformBlockBinding:Fe,texStorage2D:zt,texStorage3D:un,texSubImage2D:He,texSubImage3D:St,compressedTexSubImage2D:Ke,compressedTexSubImage3D:rt,scissor:ae,viewport:Ne,reset:Ct}}function vz(r,e,t,n,i,s,a){const o=i.isWebGL2,u=i.maxTextures,h=i.maxCubemapSize,p=i.maxTextureSize,m=i.maxSamples,y=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,v=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),S=new WeakMap;let T;const E=new WeakMap;let w=!1;try{w=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function C(J,$){return w?new OffscreenCanvas(J,$):Yp("canvas")}function A(J,$,Se,qe){let Oe=1;if((J.width>qe||J.height>qe)&&(Oe=qe/Math.max(J.width,J.height)),Oe<1||$===!0)if(typeof HTMLImageElement<"u"&&J instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&J instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&J instanceof ImageBitmap){const He=$?t0:Math.floor,St=He(Oe*J.width),Ke=He(Oe*J.height);T===void 0&&(T=C(St,Ke));const rt=Se?C(St,Ke):T;return rt.width=St,rt.height=Ke,rt.getContext("2d").drawImage(J,0,0,St,Ke),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+J.width+"x"+J.height+") to ("+St+"x"+Ke+")."),rt}else return"data"in J&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+J.width+"x"+J.height+")."),J;return J}function I(J){return Ix(J.width)&&Ix(J.height)}function F(J){return o?!1:J.wrapS!==Mi||J.wrapT!==Mi||J.minFilter!==Sr&&J.minFilter!==wr}function U(J,$){return J.generateMipmaps&&$&&J.minFilter!==Sr&&J.minFilter!==wr}function V(J){r.generateMipmap(J)}function G(J,$,Se,qe,Oe=!1){if(o===!1)return $;if(J!==null){if(r[J]!==void 0)return r[J];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+J+"'")}let He=$;if($===r.RED&&(Se===r.FLOAT&&(He=r.R32F),Se===r.HALF_FLOAT&&(He=r.R16F),Se===r.UNSIGNED_BYTE&&(He=r.R8)),$===r.RED_INTEGER&&(Se===r.UNSIGNED_BYTE&&(He=r.R8UI),Se===r.UNSIGNED_SHORT&&(He=r.R16UI),Se===r.UNSIGNED_INT&&(He=r.R32UI),Se===r.BYTE&&(He=r.R8I),Se===r.SHORT&&(He=r.R16I),Se===r.INT&&(He=r.R32I)),$===r.RG&&(Se===r.FLOAT&&(He=r.RG32F),Se===r.HALF_FLOAT&&(He=r.RG16F),Se===r.UNSIGNED_BYTE&&(He=r.RG8)),$===r.RGBA){const St=Oe?Wp:Nn.getTransfer(qe);Se===r.FLOAT&&(He=r.RGBA32F),Se===r.HALF_FLOAT&&(He=r.RGBA16F),Se===r.UNSIGNED_BYTE&&(He=St===qn?r.SRGB8_ALPHA8:r.RGBA8),Se===r.UNSIGNED_SHORT_4_4_4_4&&(He=r.RGBA4),Se===r.UNSIGNED_SHORT_5_5_5_1&&(He=r.RGB5_A1)}return(He===r.R16F||He===r.R32F||He===r.RG16F||He===r.RG32F||He===r.RGBA16F||He===r.RGBA32F)&&e.get("EXT_color_buffer_float"),He}function L(J,$,Se){return U(J,Se)===!0||J.isFramebufferTexture&&J.minFilter!==Sr&&J.minFilter!==wr?Math.log2(Math.max($.width,$.height))+1:J.mipmaps!==void 0&&J.mipmaps.length>0?J.mipmaps.length:J.isCompressedTexture&&Array.isArray(J.image)?$.mipmaps.length:1}function k(J){return J===Sr||J===Qy||J===Rp?r.NEAREST:r.LINEAR}function O(J){const $=J.target;$.removeEventListener("dispose",O),le($),$.isVideoTexture&&S.delete($)}function Q(J){const $=J.target;$.removeEventListener("dispose",Q),ce($)}function le(J){const $=n.get(J);if($.__webglInit===void 0)return;const Se=J.source,qe=E.get(Se);if(qe){const Oe=qe[$.__cacheKey];Oe.usedTimes--,Oe.usedTimes===0&&K(J),Object.keys(qe).length===0&&E.delete(Se)}n.remove(J)}function K(J){const $=n.get(J);r.deleteTexture($.__webglTexture);const Se=J.source,qe=E.get(Se);delete qe[$.__cacheKey],a.memory.textures--}function ce(J){const $=J.texture,Se=n.get(J),qe=n.get($);if(qe.__webglTexture!==void 0&&(r.deleteTexture(qe.__webglTexture),a.memory.textures--),J.depthTexture&&J.depthTexture.dispose(),J.isWebGLCubeRenderTarget)for(let Oe=0;Oe<6;Oe++){if(Array.isArray(Se.__webglFramebuffer[Oe]))for(let He=0;He<Se.__webglFramebuffer[Oe].length;He++)r.deleteFramebuffer(Se.__webglFramebuffer[Oe][He]);else r.deleteFramebuffer(Se.__webglFramebuffer[Oe]);Se.__webglDepthbuffer&&r.deleteRenderbuffer(Se.__webglDepthbuffer[Oe])}else{if(Array.isArray(Se.__webglFramebuffer))for(let Oe=0;Oe<Se.__webglFramebuffer.length;Oe++)r.deleteFramebuffer(Se.__webglFramebuffer[Oe]);else r.deleteFramebuffer(Se.__webglFramebuffer);if(Se.__webglDepthbuffer&&r.deleteRenderbuffer(Se.__webglDepthbuffer),Se.__webglMultisampledFramebuffer&&r.deleteFramebuffer(Se.__webglMultisampledFramebuffer),Se.__webglColorRenderbuffer)for(let Oe=0;Oe<Se.__webglColorRenderbuffer.length;Oe++)Se.__webglColorRenderbuffer[Oe]&&r.deleteRenderbuffer(Se.__webglColorRenderbuffer[Oe]);Se.__webglDepthRenderbuffer&&r.deleteRenderbuffer(Se.__webglDepthRenderbuffer)}if(J.isWebGLMultipleRenderTargets)for(let Oe=0,He=$.length;Oe<He;Oe++){const St=n.get($[Oe]);St.__webglTexture&&(r.deleteTexture(St.__webglTexture),a.memory.textures--),n.remove($[Oe])}n.remove($),n.remove(J)}let de=0;function me(){de=0}function Z(){const J=de;return J>=u&&console.warn("THREE.WebGLTextures: Trying to use "+J+" texture units while this GPU supports only "+u),de+=1,J}function re(J){const $=[];return $.push(J.wrapS),$.push(J.wrapT),$.push(J.wrapR||0),$.push(J.magFilter),$.push(J.minFilter),$.push(J.anisotropy),$.push(J.internalFormat),$.push(J.format),$.push(J.type),$.push(J.generateMipmaps),$.push(J.premultiplyAlpha),$.push(J.flipY),$.push(J.unpackAlignment),$.push(J.colorSpace),$.join()}function ee(J,$){const Se=n.get(J);if(J.isVideoTexture&&Gt(J),J.isRenderTargetTexture===!1&&J.version>0&&Se.__version!==J.version){const qe=J.image;if(qe===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(qe.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{ut(Se,J,$);return}}t.bindTexture(r.TEXTURE_2D,Se.__webglTexture,r.TEXTURE0+$)}function z(J,$){const Se=n.get(J);if(J.version>0&&Se.__version!==J.version){ut(Se,J,$);return}t.bindTexture(r.TEXTURE_2D_ARRAY,Se.__webglTexture,r.TEXTURE0+$)}function q(J,$){const Se=n.get(J);if(J.version>0&&Se.__version!==J.version){ut(Se,J,$);return}t.bindTexture(r.TEXTURE_3D,Se.__webglTexture,r.TEXTURE0+$)}function ve(J,$){const Se=n.get(J);if(J.version>0&&Se.__version!==J.version){kt(Se,J,$);return}t.bindTexture(r.TEXTURE_CUBE_MAP,Se.__webglTexture,r.TEXTURE0+$)}const Ce={[Bp]:r.REPEAT,[Mi]:r.CLAMP_TO_EDGE,[Vp]:r.MIRRORED_REPEAT},ke={[Sr]:r.NEAREST,[Qy]:r.NEAREST_MIPMAP_NEAREST,[Rp]:r.NEAREST_MIPMAP_LINEAR,[wr]:r.LINEAR,[ES]:r.LINEAR_MIPMAP_NEAREST,[pu]:r.LINEAR_MIPMAP_LINEAR},We={[OM]:r.NEVER,[$M]:r.ALWAYS,[FM]:r.LESS,[zM]:r.LEQUAL,[UM]:r.EQUAL,[HM]:r.GEQUAL,[BM]:r.GREATER,[VM]:r.NOTEQUAL};function tt(J,$,Se){if(Se?(r.texParameteri(J,r.TEXTURE_WRAP_S,Ce[$.wrapS]),r.texParameteri(J,r.TEXTURE_WRAP_T,Ce[$.wrapT]),(J===r.TEXTURE_3D||J===r.TEXTURE_2D_ARRAY)&&r.texParameteri(J,r.TEXTURE_WRAP_R,Ce[$.wrapR]),r.texParameteri(J,r.TEXTURE_MAG_FILTER,ke[$.magFilter]),r.texParameteri(J,r.TEXTURE_MIN_FILTER,ke[$.minFilter])):(r.texParameteri(J,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(J,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE),(J===r.TEXTURE_3D||J===r.TEXTURE_2D_ARRAY)&&r.texParameteri(J,r.TEXTURE_WRAP_R,r.CLAMP_TO_EDGE),($.wrapS!==Mi||$.wrapT!==Mi)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),r.texParameteri(J,r.TEXTURE_MAG_FILTER,k($.magFilter)),r.texParameteri(J,r.TEXTURE_MIN_FILTER,k($.minFilter)),$.minFilter!==Sr&&$.minFilter!==wr&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),$.compareFunction&&(r.texParameteri(J,r.TEXTURE_COMPARE_MODE,r.COMPARE_REF_TO_TEXTURE),r.texParameteri(J,r.TEXTURE_COMPARE_FUNC,We[$.compareFunction])),e.has("EXT_texture_filter_anisotropic")===!0){const qe=e.get("EXT_texture_filter_anisotropic");if($.magFilter===Sr||$.minFilter!==Rp&&$.minFilter!==pu||$.type===Ja&&e.has("OES_texture_float_linear")===!1||o===!1&&$.type===qh&&e.has("OES_texture_half_float_linear")===!1)return;($.anisotropy>1||n.get($).__currentAnisotropy)&&(r.texParameterf(J,qe.TEXTURE_MAX_ANISOTROPY_EXT,Math.min($.anisotropy,i.getMaxAnisotropy())),n.get($).__currentAnisotropy=$.anisotropy)}}function nt(J,$){let Se=!1;J.__webglInit===void 0&&(J.__webglInit=!0,$.addEventListener("dispose",O));const qe=$.source;let Oe=E.get(qe);Oe===void 0&&(Oe={},E.set(qe,Oe));const He=re($);if(He!==J.__cacheKey){Oe[He]===void 0&&(Oe[He]={texture:r.createTexture(),usedTimes:0},a.memory.textures++,Se=!0),Oe[He].usedTimes++;const St=Oe[J.__cacheKey];St!==void 0&&(Oe[J.__cacheKey].usedTimes--,St.usedTimes===0&&K($)),J.__cacheKey=He,J.__webglTexture=Oe[He].texture}return Se}function ut(J,$,Se){let qe=r.TEXTURE_2D;($.isDataArrayTexture||$.isCompressedArrayTexture)&&(qe=r.TEXTURE_2D_ARRAY),$.isData3DTexture&&(qe=r.TEXTURE_3D);const Oe=nt(J,$),He=$.source;t.bindTexture(qe,J.__webglTexture,r.TEXTURE0+Se);const St=n.get(He);if(He.version!==St.__version||Oe===!0){t.activeTexture(r.TEXTURE0+Se);const Ke=Nn.getPrimaries(Nn.workingColorSpace),rt=$.colorSpace===Rs?null:Nn.getPrimaries($.colorSpace),zt=$.colorSpace===Rs||Ke===rt?r.NONE:r.BROWSER_DEFAULT_WEBGL;r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL,$.flipY),r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL,$.premultiplyAlpha),r.pixelStorei(r.UNPACK_ALIGNMENT,$.unpackAlignment),r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL,zt);const un=F($)&&I($.image)===!1;let Xe=A($.image,un,!1,p);Xe=wn($,Xe);const fn=I(Xe)||o,ae=s.convert($.format,$.colorSpace);let Ne=s.convert($.type),ze=G($.internalFormat,ae,Ne,$.colorSpace,$.isVideoTexture);tt(qe,$,fn);let Fe;const Ct=$.mipmaps,ue=o&&$.isVideoTexture!==!0,Qe=St.__version===void 0||Oe===!0,Ze=L($,Xe,fn);if($.isDepthTexture)ze=r.DEPTH_COMPONENT,o?$.type===Ja?ze=r.DEPTH_COMPONENT32F:$.type===il?ze=r.DEPTH_COMPONENT24:$.type===lu?ze=r.DEPTH24_STENCIL8:ze=r.DEPTH_COMPONENT16:$.type===Ja&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),$.format===uu&&ze===r.DEPTH_COMPONENT&&$.type!==E0&&$.type!==il&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),$.type=il,Ne=s.convert($.type)),$.format===qc&&ze===r.DEPTH_COMPONENT&&(ze=r.DEPTH_STENCIL,$.type!==lu&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),$.type=lu,Ne=s.convert($.type))),Qe&&(ue?t.texStorage2D(r.TEXTURE_2D,1,ze,Xe.width,Xe.height):t.texImage2D(r.TEXTURE_2D,0,ze,Xe.width,Xe.height,0,ae,Ne,null));else if($.isDataTexture)if(Ct.length>0&&fn){ue&&Qe&&t.texStorage2D(r.TEXTURE_2D,Ze,ze,Ct[0].width,Ct[0].height);for(let Re=0,$e=Ct.length;Re<$e;Re++)Fe=Ct[Re],ue?t.texSubImage2D(r.TEXTURE_2D,Re,0,0,Fe.width,Fe.height,ae,Ne,Fe.data):t.texImage2D(r.TEXTURE_2D,Re,ze,Fe.width,Fe.height,0,ae,Ne,Fe.data);$.generateMipmaps=!1}else ue?(Qe&&t.texStorage2D(r.TEXTURE_2D,Ze,ze,Xe.width,Xe.height),t.texSubImage2D(r.TEXTURE_2D,0,0,0,Xe.width,Xe.height,ae,Ne,Xe.data)):t.texImage2D(r.TEXTURE_2D,0,ze,Xe.width,Xe.height,0,ae,Ne,Xe.data);else if($.isCompressedTexture)if($.isCompressedArrayTexture){ue&&Qe&&t.texStorage3D(r.TEXTURE_2D_ARRAY,Ze,ze,Ct[0].width,Ct[0].height,Xe.depth);for(let Re=0,$e=Ct.length;Re<$e;Re++)Fe=Ct[Re],$.format!==hs?ae!==null?ue?t.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY,Re,0,0,0,Fe.width,Fe.height,Xe.depth,ae,Fe.data,0,0):t.compressedTexImage3D(r.TEXTURE_2D_ARRAY,Re,ze,Fe.width,Fe.height,Xe.depth,0,Fe.data,0,0):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):ue?t.texSubImage3D(r.TEXTURE_2D_ARRAY,Re,0,0,0,Fe.width,Fe.height,Xe.depth,ae,Ne,Fe.data):t.texImage3D(r.TEXTURE_2D_ARRAY,Re,ze,Fe.width,Fe.height,Xe.depth,0,ae,Ne,Fe.data)}else{ue&&Qe&&t.texStorage2D(r.TEXTURE_2D,Ze,ze,Ct[0].width,Ct[0].height);for(let Re=0,$e=Ct.length;Re<$e;Re++)Fe=Ct[Re],$.format!==hs?ae!==null?ue?t.compressedTexSubImage2D(r.TEXTURE_2D,Re,0,0,Fe.width,Fe.height,ae,Fe.data):t.compressedTexImage2D(r.TEXTURE_2D,Re,ze,Fe.width,Fe.height,0,Fe.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):ue?t.texSubImage2D(r.TEXTURE_2D,Re,0,0,Fe.width,Fe.height,ae,Ne,Fe.data):t.texImage2D(r.TEXTURE_2D,Re,ze,Fe.width,Fe.height,0,ae,Ne,Fe.data)}else if($.isDataArrayTexture)ue?(Qe&&t.texStorage3D(r.TEXTURE_2D_ARRAY,Ze,ze,Xe.width,Xe.height,Xe.depth),t.texSubImage3D(r.TEXTURE_2D_ARRAY,0,0,0,0,Xe.width,Xe.height,Xe.depth,ae,Ne,Xe.data)):t.texImage3D(r.TEXTURE_2D_ARRAY,0,ze,Xe.width,Xe.height,Xe.depth,0,ae,Ne,Xe.data);else if($.isData3DTexture)ue?(Qe&&t.texStorage3D(r.TEXTURE_3D,Ze,ze,Xe.width,Xe.height,Xe.depth),t.texSubImage3D(r.TEXTURE_3D,0,0,0,0,Xe.width,Xe.height,Xe.depth,ae,Ne,Xe.data)):t.texImage3D(r.TEXTURE_3D,0,ze,Xe.width,Xe.height,Xe.depth,0,ae,Ne,Xe.data);else if($.isFramebufferTexture){if(Qe)if(ue)t.texStorage2D(r.TEXTURE_2D,Ze,ze,Xe.width,Xe.height);else{let Re=Xe.width,$e=Xe.height;for(let Et=0;Et<Ze;Et++)t.texImage2D(r.TEXTURE_2D,Et,ze,Re,$e,0,ae,Ne,null),Re>>=1,$e>>=1}}else if(Ct.length>0&&fn){ue&&Qe&&t.texStorage2D(r.TEXTURE_2D,Ze,ze,Ct[0].width,Ct[0].height);for(let Re=0,$e=Ct.length;Re<$e;Re++)Fe=Ct[Re],ue?t.texSubImage2D(r.TEXTURE_2D,Re,0,0,ae,Ne,Fe):t.texImage2D(r.TEXTURE_2D,Re,ze,ae,Ne,Fe);$.generateMipmaps=!1}else ue?(Qe&&t.texStorage2D(r.TEXTURE_2D,Ze,ze,Xe.width,Xe.height),t.texSubImage2D(r.TEXTURE_2D,0,0,0,ae,Ne,Xe)):t.texImage2D(r.TEXTURE_2D,0,ze,ae,Ne,Xe);U($,fn)&&V(qe),St.__version=He.version,$.onUpdate&&$.onUpdate($)}J.__version=$.version}function kt(J,$,Se){if($.image.length!==6)return;const qe=nt(J,$),Oe=$.source;t.bindTexture(r.TEXTURE_CUBE_MAP,J.__webglTexture,r.TEXTURE0+Se);const He=n.get(Oe);if(Oe.version!==He.__version||qe===!0){t.activeTexture(r.TEXTURE0+Se);const St=Nn.getPrimaries(Nn.workingColorSpace),Ke=$.colorSpace===Rs?null:Nn.getPrimaries($.colorSpace),rt=$.colorSpace===Rs||St===Ke?r.NONE:r.BROWSER_DEFAULT_WEBGL;r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL,$.flipY),r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL,$.premultiplyAlpha),r.pixelStorei(r.UNPACK_ALIGNMENT,$.unpackAlignment),r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL,rt);const zt=$.isCompressedTexture||$.image[0].isCompressedTexture,un=$.image[0]&&$.image[0].isDataTexture,Xe=[];for(let Re=0;Re<6;Re++)!zt&&!un?Xe[Re]=A($.image[Re],!1,!0,h):Xe[Re]=un?$.image[Re].image:$.image[Re],Xe[Re]=wn($,Xe[Re]);const fn=Xe[0],ae=I(fn)||o,Ne=s.convert($.format,$.colorSpace),ze=s.convert($.type),Fe=G($.internalFormat,Ne,ze,$.colorSpace),Ct=o&&$.isVideoTexture!==!0,ue=He.__version===void 0||qe===!0;let Qe=L($,fn,ae);tt(r.TEXTURE_CUBE_MAP,$,ae);let Ze;if(zt){Ct&&ue&&t.texStorage2D(r.TEXTURE_CUBE_MAP,Qe,Fe,fn.width,fn.height);for(let Re=0;Re<6;Re++){Ze=Xe[Re].mipmaps;for(let $e=0;$e<Ze.length;$e++){const Et=Ze[$e];$.format!==hs?Ne!==null?Ct?t.compressedTexSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+Re,$e,0,0,Et.width,Et.height,Ne,Et.data):t.compressedTexImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+Re,$e,Fe,Et.width,Et.height,0,Et.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):Ct?t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+Re,$e,0,0,Et.width,Et.height,Ne,ze,Et.data):t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+Re,$e,Fe,Et.width,Et.height,0,Ne,ze,Et.data)}}}else{Ze=$.mipmaps,Ct&&ue&&(Ze.length>0&&Qe++,t.texStorage2D(r.TEXTURE_CUBE_MAP,Qe,Fe,Xe[0].width,Xe[0].height));for(let Re=0;Re<6;Re++)if(un){Ct?t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+Re,0,0,0,Xe[Re].width,Xe[Re].height,Ne,ze,Xe[Re].data):t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+Re,0,Fe,Xe[Re].width,Xe[Re].height,0,Ne,ze,Xe[Re].data);for(let $e=0;$e<Ze.length;$e++){const Yt=Ze[$e].image[Re].image;Ct?t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+Re,$e+1,0,0,Yt.width,Yt.height,Ne,ze,Yt.data):t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+Re,$e+1,Fe,Yt.width,Yt.height,0,Ne,ze,Yt.data)}}else{Ct?t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+Re,0,0,0,Ne,ze,Xe[Re]):t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+Re,0,Fe,Ne,ze,Xe[Re]);for(let $e=0;$e<Ze.length;$e++){const Et=Ze[$e];Ct?t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+Re,$e+1,0,0,Ne,ze,Et.image[Re]):t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+Re,$e+1,Fe,Ne,ze,Et.image[Re])}}}U($,ae)&&V(r.TEXTURE_CUBE_MAP),He.__version=Oe.version,$.onUpdate&&$.onUpdate($)}J.__version=$.version}function vt(J,$,Se,qe,Oe,He){const St=s.convert(Se.format,Se.colorSpace),Ke=s.convert(Se.type),rt=G(Se.internalFormat,St,Ke,Se.colorSpace);if(!n.get($).__hasExternalTextures){const un=Math.max(1,$.width>>He),Xe=Math.max(1,$.height>>He);Oe===r.TEXTURE_3D||Oe===r.TEXTURE_2D_ARRAY?t.texImage3D(Oe,He,rt,un,Xe,$.depth,0,St,Ke,null):t.texImage2D(Oe,He,rt,un,Xe,0,St,Ke,null)}t.bindFramebuffer(r.FRAMEBUFFER,J),Pt($)?y.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER,qe,Oe,n.get(Se).__webglTexture,0,dt($)):(Oe===r.TEXTURE_2D||Oe>=r.TEXTURE_CUBE_MAP_POSITIVE_X&&Oe<=r.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&r.framebufferTexture2D(r.FRAMEBUFFER,qe,Oe,n.get(Se).__webglTexture,He),t.bindFramebuffer(r.FRAMEBUFFER,null)}function se(J,$,Se){if(r.bindRenderbuffer(r.RENDERBUFFER,J),$.depthBuffer&&!$.stencilBuffer){let qe=o===!0?r.DEPTH_COMPONENT24:r.DEPTH_COMPONENT16;if(Se||Pt($)){const Oe=$.depthTexture;Oe&&Oe.isDepthTexture&&(Oe.type===Ja?qe=r.DEPTH_COMPONENT32F:Oe.type===il&&(qe=r.DEPTH_COMPONENT24));const He=dt($);Pt($)?y.renderbufferStorageMultisampleEXT(r.RENDERBUFFER,He,qe,$.width,$.height):r.renderbufferStorageMultisample(r.RENDERBUFFER,He,qe,$.width,$.height)}else r.renderbufferStorage(r.RENDERBUFFER,qe,$.width,$.height);r.framebufferRenderbuffer(r.FRAMEBUFFER,r.DEPTH_ATTACHMENT,r.RENDERBUFFER,J)}else if($.depthBuffer&&$.stencilBuffer){const qe=dt($);Se&&Pt($)===!1?r.renderbufferStorageMultisample(r.RENDERBUFFER,qe,r.DEPTH24_STENCIL8,$.width,$.height):Pt($)?y.renderbufferStorageMultisampleEXT(r.RENDERBUFFER,qe,r.DEPTH24_STENCIL8,$.width,$.height):r.renderbufferStorage(r.RENDERBUFFER,r.DEPTH_STENCIL,$.width,$.height),r.framebufferRenderbuffer(r.FRAMEBUFFER,r.DEPTH_STENCIL_ATTACHMENT,r.RENDERBUFFER,J)}else{const qe=$.isWebGLMultipleRenderTargets===!0?$.texture:[$.texture];for(let Oe=0;Oe<qe.length;Oe++){const He=qe[Oe],St=s.convert(He.format,He.colorSpace),Ke=s.convert(He.type),rt=G(He.internalFormat,St,Ke,He.colorSpace),zt=dt($);Se&&Pt($)===!1?r.renderbufferStorageMultisample(r.RENDERBUFFER,zt,rt,$.width,$.height):Pt($)?y.renderbufferStorageMultisampleEXT(r.RENDERBUFFER,zt,rt,$.width,$.height):r.renderbufferStorage(r.RENDERBUFFER,rt,$.width,$.height)}}r.bindRenderbuffer(r.RENDERBUFFER,null)}function Ve(J,$){if($&&$.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(r.FRAMEBUFFER,J),!($.depthTexture&&$.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!n.get($.depthTexture).__webglTexture||$.depthTexture.image.width!==$.width||$.depthTexture.image.height!==$.height)&&($.depthTexture.image.width=$.width,$.depthTexture.image.height=$.height,$.depthTexture.needsUpdate=!0),ee($.depthTexture,0);const qe=n.get($.depthTexture).__webglTexture,Oe=dt($);if($.depthTexture.format===uu)Pt($)?y.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER,r.DEPTH_ATTACHMENT,r.TEXTURE_2D,qe,0,Oe):r.framebufferTexture2D(r.FRAMEBUFFER,r.DEPTH_ATTACHMENT,r.TEXTURE_2D,qe,0);else if($.depthTexture.format===qc)Pt($)?y.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER,r.DEPTH_STENCIL_ATTACHMENT,r.TEXTURE_2D,qe,0,Oe):r.framebufferTexture2D(r.FRAMEBUFFER,r.DEPTH_STENCIL_ATTACHMENT,r.TEXTURE_2D,qe,0);else throw new Error("Unknown depthTexture format")}function Ie(J){const $=n.get(J),Se=J.isWebGLCubeRenderTarget===!0;if(J.depthTexture&&!$.__autoAllocateDepthBuffer){if(Se)throw new Error("target.depthTexture not supported in Cube render targets");Ve($.__webglFramebuffer,J)}else if(Se){$.__webglDepthbuffer=[];for(let qe=0;qe<6;qe++)t.bindFramebuffer(r.FRAMEBUFFER,$.__webglFramebuffer[qe]),$.__webglDepthbuffer[qe]=r.createRenderbuffer(),se($.__webglDepthbuffer[qe],J,!1)}else t.bindFramebuffer(r.FRAMEBUFFER,$.__webglFramebuffer),$.__webglDepthbuffer=r.createRenderbuffer(),se($.__webglDepthbuffer,J,!1);t.bindFramebuffer(r.FRAMEBUFFER,null)}function je(J,$,Se){const qe=n.get(J);$!==void 0&&vt(qe.__webglFramebuffer,J,J.texture,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,0),Se!==void 0&&Ie(J)}function De(J){const $=J.texture,Se=n.get(J),qe=n.get($);J.addEventListener("dispose",Q),J.isWebGLMultipleRenderTargets!==!0&&(qe.__webglTexture===void 0&&(qe.__webglTexture=r.createTexture()),qe.__version=$.version,a.memory.textures++);const Oe=J.isWebGLCubeRenderTarget===!0,He=J.isWebGLMultipleRenderTargets===!0,St=I(J)||o;if(Oe){Se.__webglFramebuffer=[];for(let Ke=0;Ke<6;Ke++)if(o&&$.mipmaps&&$.mipmaps.length>0){Se.__webglFramebuffer[Ke]=[];for(let rt=0;rt<$.mipmaps.length;rt++)Se.__webglFramebuffer[Ke][rt]=r.createFramebuffer()}else Se.__webglFramebuffer[Ke]=r.createFramebuffer()}else{if(o&&$.mipmaps&&$.mipmaps.length>0){Se.__webglFramebuffer=[];for(let Ke=0;Ke<$.mipmaps.length;Ke++)Se.__webglFramebuffer[Ke]=r.createFramebuffer()}else Se.__webglFramebuffer=r.createFramebuffer();if(He)if(i.drawBuffers){const Ke=J.texture;for(let rt=0,zt=Ke.length;rt<zt;rt++){const un=n.get(Ke[rt]);un.__webglTexture===void 0&&(un.__webglTexture=r.createTexture(),a.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(o&&J.samples>0&&Pt(J)===!1){const Ke=He?$:[$];Se.__webglMultisampledFramebuffer=r.createFramebuffer(),Se.__webglColorRenderbuffer=[],t.bindFramebuffer(r.FRAMEBUFFER,Se.__webglMultisampledFramebuffer);for(let rt=0;rt<Ke.length;rt++){const zt=Ke[rt];Se.__webglColorRenderbuffer[rt]=r.createRenderbuffer(),r.bindRenderbuffer(r.RENDERBUFFER,Se.__webglColorRenderbuffer[rt]);const un=s.convert(zt.format,zt.colorSpace),Xe=s.convert(zt.type),fn=G(zt.internalFormat,un,Xe,zt.colorSpace,J.isXRRenderTarget===!0),ae=dt(J);r.renderbufferStorageMultisample(r.RENDERBUFFER,ae,fn,J.width,J.height),r.framebufferRenderbuffer(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0+rt,r.RENDERBUFFER,Se.__webglColorRenderbuffer[rt])}r.bindRenderbuffer(r.RENDERBUFFER,null),J.depthBuffer&&(Se.__webglDepthRenderbuffer=r.createRenderbuffer(),se(Se.__webglDepthRenderbuffer,J,!0)),t.bindFramebuffer(r.FRAMEBUFFER,null)}}if(Oe){t.bindTexture(r.TEXTURE_CUBE_MAP,qe.__webglTexture),tt(r.TEXTURE_CUBE_MAP,$,St);for(let Ke=0;Ke<6;Ke++)if(o&&$.mipmaps&&$.mipmaps.length>0)for(let rt=0;rt<$.mipmaps.length;rt++)vt(Se.__webglFramebuffer[Ke][rt],J,$,r.COLOR_ATTACHMENT0,r.TEXTURE_CUBE_MAP_POSITIVE_X+Ke,rt);else vt(Se.__webglFramebuffer[Ke],J,$,r.COLOR_ATTACHMENT0,r.TEXTURE_CUBE_MAP_POSITIVE_X+Ke,0);U($,St)&&V(r.TEXTURE_CUBE_MAP),t.unbindTexture()}else if(He){const Ke=J.texture;for(let rt=0,zt=Ke.length;rt<zt;rt++){const un=Ke[rt],Xe=n.get(un);t.bindTexture(r.TEXTURE_2D,Xe.__webglTexture),tt(r.TEXTURE_2D,un,St),vt(Se.__webglFramebuffer,J,un,r.COLOR_ATTACHMENT0+rt,r.TEXTURE_2D,0),U(un,St)&&V(r.TEXTURE_2D)}t.unbindTexture()}else{let Ke=r.TEXTURE_2D;if((J.isWebGL3DRenderTarget||J.isWebGLArrayRenderTarget)&&(o?Ke=J.isWebGL3DRenderTarget?r.TEXTURE_3D:r.TEXTURE_2D_ARRAY:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),t.bindTexture(Ke,qe.__webglTexture),tt(Ke,$,St),o&&$.mipmaps&&$.mipmaps.length>0)for(let rt=0;rt<$.mipmaps.length;rt++)vt(Se.__webglFramebuffer[rt],J,$,r.COLOR_ATTACHMENT0,Ke,rt);else vt(Se.__webglFramebuffer,J,$,r.COLOR_ATTACHMENT0,Ke,0);U($,St)&&V(Ke),t.unbindTexture()}J.depthBuffer&&Ie(J)}function bt(J){const $=I(J)||o,Se=J.isWebGLMultipleRenderTargets===!0?J.texture:[J.texture];for(let qe=0,Oe=Se.length;qe<Oe;qe++){const He=Se[qe];if(U(He,$)){const St=J.isWebGLCubeRenderTarget?r.TEXTURE_CUBE_MAP:r.TEXTURE_2D,Ke=n.get(He).__webglTexture;t.bindTexture(St,Ke),V(St),t.unbindTexture()}}}function at(J){if(o&&J.samples>0&&Pt(J)===!1){const $=J.isWebGLMultipleRenderTargets?J.texture:[J.texture],Se=J.width,qe=J.height;let Oe=r.COLOR_BUFFER_BIT;const He=[],St=J.stencilBuffer?r.DEPTH_STENCIL_ATTACHMENT:r.DEPTH_ATTACHMENT,Ke=n.get(J),rt=J.isWebGLMultipleRenderTargets===!0;if(rt)for(let zt=0;zt<$.length;zt++)t.bindFramebuffer(r.FRAMEBUFFER,Ke.__webglMultisampledFramebuffer),r.framebufferRenderbuffer(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0+zt,r.RENDERBUFFER,null),t.bindFramebuffer(r.FRAMEBUFFER,Ke.__webglFramebuffer),r.framebufferTexture2D(r.DRAW_FRAMEBUFFER,r.COLOR_ATTACHMENT0+zt,r.TEXTURE_2D,null,0);t.bindFramebuffer(r.READ_FRAMEBUFFER,Ke.__webglMultisampledFramebuffer),t.bindFramebuffer(r.DRAW_FRAMEBUFFER,Ke.__webglFramebuffer);for(let zt=0;zt<$.length;zt++){He.push(r.COLOR_ATTACHMENT0+zt),J.depthBuffer&&He.push(St);const un=Ke.__ignoreDepthValues!==void 0?Ke.__ignoreDepthValues:!1;if(un===!1&&(J.depthBuffer&&(Oe|=r.DEPTH_BUFFER_BIT),J.stencilBuffer&&(Oe|=r.STENCIL_BUFFER_BIT)),rt&&r.framebufferRenderbuffer(r.READ_FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.RENDERBUFFER,Ke.__webglColorRenderbuffer[zt]),un===!0&&(r.invalidateFramebuffer(r.READ_FRAMEBUFFER,[St]),r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER,[St])),rt){const Xe=n.get($[zt]).__webglTexture;r.framebufferTexture2D(r.DRAW_FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,Xe,0)}r.blitFramebuffer(0,0,Se,qe,0,0,Se,qe,Oe,r.NEAREST),v&&r.invalidateFramebuffer(r.READ_FRAMEBUFFER,He)}if(t.bindFramebuffer(r.READ_FRAMEBUFFER,null),t.bindFramebuffer(r.DRAW_FRAMEBUFFER,null),rt)for(let zt=0;zt<$.length;zt++){t.bindFramebuffer(r.FRAMEBUFFER,Ke.__webglMultisampledFramebuffer),r.framebufferRenderbuffer(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0+zt,r.RENDERBUFFER,Ke.__webglColorRenderbuffer[zt]);const un=n.get($[zt]).__webglTexture;t.bindFramebuffer(r.FRAMEBUFFER,Ke.__webglFramebuffer),r.framebufferTexture2D(r.DRAW_FRAMEBUFFER,r.COLOR_ATTACHMENT0+zt,r.TEXTURE_2D,un,0)}t.bindFramebuffer(r.DRAW_FRAMEBUFFER,Ke.__webglMultisampledFramebuffer)}}function dt(J){return Math.min(m,J.samples)}function Pt(J){const $=n.get(J);return o&&J.samples>0&&e.has("WEBGL_multisampled_render_to_texture")===!0&&$.__useRenderToTexture!==!1}function Gt(J){const $=a.render.frame;S.get(J)!==$&&(S.set(J,$),J.update())}function wn(J,$){const Se=J.colorSpace,qe=J.format,Oe=J.type;return J.isCompressedTexture===!0||J.isVideoTexture===!0||J.format===e0||Se!==ro&&Se!==Rs&&(Nn.getTransfer(Se)===qn?o===!1?e.has("EXT_sRGB")===!0&&qe===hs?(J.format=e0,J.minFilter=wr,J.generateMipmaps=!1):$=LS.sRGBToLinear($):(qe!==hs||Oe!==to)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",Se)),$}this.allocateTextureUnit=Z,this.resetTextureUnits=me,this.setTexture2D=ee,this.setTexture2DArray=z,this.setTexture3D=q,this.setTextureCube=ve,this.rebindTextures=je,this.setupRenderTarget=De,this.updateRenderTargetMipmap=bt,this.updateMultisampleRenderTarget=at,this.setupDepthRenderbuffer=Ie,this.setupFrameBufferTexture=vt,this.useMultisampledRTT=Pt}function iA(r,e,t){const n=t.isWebGL2;function i(s,a=Rs){let o;const u=Nn.getTransfer(a);if(s===to)return r.UNSIGNED_BYTE;if(s===TS)return r.UNSIGNED_SHORT_4_4_4_4;if(s===MS)return r.UNSIGNED_SHORT_5_5_5_1;if(s===SM)return r.BYTE;if(s===wM)return r.SHORT;if(s===E0)return r.UNSIGNED_SHORT;if(s===bS)return r.INT;if(s===il)return r.UNSIGNED_INT;if(s===Ja)return r.FLOAT;if(s===qh)return n?r.HALF_FLOAT:(o=e.get("OES_texture_half_float"),o!==null?o.HALF_FLOAT_OES:null);if(s===EM)return r.ALPHA;if(s===hs)return r.RGBA;if(s===bM)return r.LUMINANCE;if(s===TM)return r.LUMINANCE_ALPHA;if(s===uu)return r.DEPTH_COMPONENT;if(s===qc)return r.DEPTH_STENCIL;if(s===e0)return o=e.get("EXT_sRGB"),o!==null?o.SRGB_ALPHA_EXT:null;if(s===MM)return r.RED;if(s===AS)return r.RED_INTEGER;if(s===AM)return r.RG;if(s===NS)return r.RG_INTEGER;if(s===CS)return r.RGBA_INTEGER;if(s===Py||s===Ly||s===ky||s===Dy)if(u===qn)if(o=e.get("WEBGL_compressed_texture_s3tc_srgb"),o!==null){if(s===Py)return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(s===Ly)return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(s===ky)return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(s===Dy)return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(o=e.get("WEBGL_compressed_texture_s3tc"),o!==null){if(s===Py)return o.COMPRESSED_RGB_S3TC_DXT1_EXT;if(s===Ly)return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(s===ky)return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(s===Dy)return o.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(s===ix||s===sx||s===ax||s===ox)if(o=e.get("WEBGL_compressed_texture_pvrtc"),o!==null){if(s===ix)return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(s===sx)return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(s===ax)return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(s===ox)return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(s===NM)return o=e.get("WEBGL_compressed_texture_etc1"),o!==null?o.COMPRESSED_RGB_ETC1_WEBGL:null;if(s===lx||s===ux)if(o=e.get("WEBGL_compressed_texture_etc"),o!==null){if(s===lx)return u===qn?o.COMPRESSED_SRGB8_ETC2:o.COMPRESSED_RGB8_ETC2;if(s===ux)return u===qn?o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:o.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(s===cx||s===fx||s===hx||s===dx||s===px||s===mx||s===gx||s===yx||s===vx||s===_x||s===xx||s===Sx||s===wx||s===Ex)if(o=e.get("WEBGL_compressed_texture_astc"),o!==null){if(s===cx)return u===qn?o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:o.COMPRESSED_RGBA_ASTC_4x4_KHR;if(s===fx)return u===qn?o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:o.COMPRESSED_RGBA_ASTC_5x4_KHR;if(s===hx)return u===qn?o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:o.COMPRESSED_RGBA_ASTC_5x5_KHR;if(s===dx)return u===qn?o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:o.COMPRESSED_RGBA_ASTC_6x5_KHR;if(s===px)return u===qn?o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:o.COMPRESSED_RGBA_ASTC_6x6_KHR;if(s===mx)return u===qn?o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:o.COMPRESSED_RGBA_ASTC_8x5_KHR;if(s===gx)return u===qn?o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:o.COMPRESSED_RGBA_ASTC_8x6_KHR;if(s===yx)return u===qn?o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:o.COMPRESSED_RGBA_ASTC_8x8_KHR;if(s===vx)return u===qn?o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:o.COMPRESSED_RGBA_ASTC_10x5_KHR;if(s===_x)return u===qn?o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:o.COMPRESSED_RGBA_ASTC_10x6_KHR;if(s===xx)return u===qn?o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:o.COMPRESSED_RGBA_ASTC_10x8_KHR;if(s===Sx)return u===qn?o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:o.COMPRESSED_RGBA_ASTC_10x10_KHR;if(s===wx)return u===qn?o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:o.COMPRESSED_RGBA_ASTC_12x10_KHR;if(s===Ex)return u===qn?o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:o.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(s===Oy||s===bx||s===Tx)if(o=e.get("EXT_texture_compression_bptc"),o!==null){if(s===Oy)return u===qn?o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:o.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(s===bx)return o.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(s===Tx)return o.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(s===CM||s===Mx||s===Ax||s===Nx)if(o=e.get("EXT_texture_compression_rgtc"),o!==null){if(s===Oy)return o.COMPRESSED_RED_RGTC1_EXT;if(s===Mx)return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(s===Ax)return o.COMPRESSED_RED_GREEN_RGTC2_EXT;if(s===Nx)return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return s===lu?n?r.UNSIGNED_INT_24_8:(o=e.get("WEBGL_depth_texture"),o!==null?o.UNSIGNED_INT_24_8_WEBGL:null):r[s]!==void 0?r[s]:null}return{convert:i}}class sA extends Er{constructor(e=[]){super(),this.isArrayCamera=!0,this.cameras=e}}class Uh extends Sn{constructor(){super(),this.isGroup=!0,this.type="Group"}}const _z={type:"move"};class g_{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Uh,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Uh,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new X,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new X),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Uh,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new X,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new X),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}connect(e){if(e&&e.hand){const t=this._hand;if(t)for(const n of e.hand.values())this._getHandJoint(t,n)}return this.dispatchEvent({type:"connected",data:e}),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,n){let i=null,s=null,a=null;const o=this._targetRay,u=this._grip,h=this._hand;if(e&&t.session.visibilityState!=="visible-blurred"){if(h&&e.hand){a=!0;for(const T of e.hand.values()){const E=t.getJointPose(T,n),w=this._getHandJoint(h,T);E!==null&&(w.matrix.fromArray(E.transform.matrix),w.matrix.decompose(w.position,w.rotation,w.scale),w.matrixWorldNeedsUpdate=!0,w.jointRadius=E.radius),w.visible=E!==null}const p=h.joints["index-finger-tip"],m=h.joints["thumb-tip"],y=p.position.distanceTo(m.position),v=.02,S=.005;h.inputState.pinching&&y>v+S?(h.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!h.inputState.pinching&&y<=v-S&&(h.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else u!==null&&e.gripSpace&&(s=t.getPose(e.gripSpace,n),s!==null&&(u.matrix.fromArray(s.transform.matrix),u.matrix.decompose(u.position,u.rotation,u.scale),u.matrixWorldNeedsUpdate=!0,s.linearVelocity?(u.hasLinearVelocity=!0,u.linearVelocity.copy(s.linearVelocity)):u.hasLinearVelocity=!1,s.angularVelocity?(u.hasAngularVelocity=!0,u.angularVelocity.copy(s.angularVelocity)):u.hasAngularVelocity=!1));o!==null&&(i=t.getPose(e.targetRaySpace,n),i===null&&s!==null&&(i=s),i!==null&&(o.matrix.fromArray(i.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),o.matrixWorldNeedsUpdate=!0,i.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(i.linearVelocity)):o.hasLinearVelocity=!1,i.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(i.angularVelocity)):o.hasAngularVelocity=!1,this.dispatchEvent(_z)))}return o!==null&&(o.visible=i!==null),u!==null&&(u.visible=s!==null),h!==null&&(h.visible=a!==null),this}_getHandJoint(e,t){if(e.joints[t.jointName]===void 0){const n=new Uh;n.matrixAutoUpdate=!1,n.visible=!1,e.joints[t.jointName]=n,e.add(n)}return e.joints[t.jointName]}}class aA extends br{constructor(e,t,n,i,s,a,o,u,h,p){if(p=p!==void 0?p:uu,p!==uu&&p!==qc)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");n===void 0&&p===uu&&(n=il),n===void 0&&p===qc&&(n=lu),super(null,i,s,a,o,u,p,n,h),this.isDepthTexture=!0,this.image={width:e,height:t},this.magFilter=o!==void 0?o:Sr,this.minFilter=u!==void 0?u:Sr,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(e){return super.copy(e),this.compareFunction=e.compareFunction,this}toJSON(e){const t=super.toJSON(e);return this.compareFunction!==null&&(t.compareFunction=this.compareFunction),t}}class xz extends hl{constructor(e,t){super();const n=this;let i=null,s=1,a=null,o="local-floor",u=1,h=null,p=null,m=null,y=null,v=null,S=null;const T=t.getContextAttributes();let E=null,w=null;const C=[],A=[],I=new Er;I.layers.enable(1),I.viewport=new Cn;const F=new Er;F.layers.enable(2),F.viewport=new Cn;const U=[I,F],V=new sA;V.layers.enable(1),V.layers.enable(2);let G=null,L=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(z){let q=C[z];return q===void 0&&(q=new g_,C[z]=q),q.getTargetRaySpace()},this.getControllerGrip=function(z){let q=C[z];return q===void 0&&(q=new g_,C[z]=q),q.getGripSpace()},this.getHand=function(z){let q=C[z];return q===void 0&&(q=new g_,C[z]=q),q.getHandSpace()};function k(z){const q=A.indexOf(z.inputSource);if(q===-1)return;const ve=C[q];ve!==void 0&&(ve.update(z.inputSource,z.frame,h||a),ve.dispatchEvent({type:z.type,data:z.inputSource}))}function O(){i.removeEventListener("select",k),i.removeEventListener("selectstart",k),i.removeEventListener("selectend",k),i.removeEventListener("squeeze",k),i.removeEventListener("squeezestart",k),i.removeEventListener("squeezeend",k),i.removeEventListener("end",O),i.removeEventListener("inputsourceschange",Q);for(let z=0;z<C.length;z++){const q=A[z];q!==null&&(A[z]=null,C[z].disconnect(q))}G=null,L=null,e.setRenderTarget(E),v=null,y=null,m=null,i=null,w=null,ee.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(z){s=z,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(z){o=z,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return h||a},this.setReferenceSpace=function(z){h=z},this.getBaseLayer=function(){return y!==null?y:v},this.getBinding=function(){return m},this.getFrame=function(){return S},this.getSession=function(){return i},this.setSession=async function(z){if(i=z,i!==null){if(E=e.getRenderTarget(),i.addEventListener("select",k),i.addEventListener("selectstart",k),i.addEventListener("selectend",k),i.addEventListener("squeeze",k),i.addEventListener("squeezestart",k),i.addEventListener("squeezeend",k),i.addEventListener("end",O),i.addEventListener("inputsourceschange",Q),T.xrCompatible!==!0&&await t.makeXRCompatible(),i.renderState.layers===void 0||e.capabilities.isWebGL2===!1){const q={antialias:i.renderState.layers===void 0?T.antialias:!0,alpha:!0,depth:T.depth,stencil:T.stencil,framebufferScaleFactor:s};v=new XRWebGLLayer(i,t,q),i.updateRenderState({baseLayer:v}),w=new Ca(v.framebufferWidth,v.framebufferHeight,{format:hs,type:to,colorSpace:e.outputColorSpace,stencilBuffer:T.stencil})}else{let q=null,ve=null,Ce=null;T.depth&&(Ce=T.stencil?t.DEPTH24_STENCIL8:t.DEPTH_COMPONENT24,q=T.stencil?qc:uu,ve=T.stencil?lu:il);const ke={colorFormat:t.RGBA8,depthFormat:Ce,scaleFactor:s};m=new XRWebGLBinding(i,t),y=m.createProjectionLayer(ke),i.updateRenderState({layers:[y]}),w=new Ca(y.textureWidth,y.textureHeight,{format:hs,type:to,depthTexture:new aA(y.textureWidth,y.textureHeight,ve,void 0,void 0,void 0,void 0,void 0,void 0,q),stencilBuffer:T.stencil,colorSpace:e.outputColorSpace,samples:T.antialias?4:0});const We=e.properties.get(w);We.__ignoreDepthValues=y.ignoreDepthValues}w.isXRRenderTarget=!0,this.setFoveation(u),h=null,a=await i.requestReferenceSpace(o),ee.setContext(i),ee.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(i!==null)return i.environmentBlendMode};function Q(z){for(let q=0;q<z.removed.length;q++){const ve=z.removed[q],Ce=A.indexOf(ve);Ce>=0&&(A[Ce]=null,C[Ce].disconnect(ve))}for(let q=0;q<z.added.length;q++){const ve=z.added[q];let Ce=A.indexOf(ve);if(Ce===-1){for(let We=0;We<C.length;We++)if(We>=A.length){A.push(ve),Ce=We;break}else if(A[We]===null){A[We]=ve,Ce=We;break}if(Ce===-1)break}const ke=C[Ce];ke&&ke.connect(ve)}}const le=new X,K=new X;function ce(z,q,ve){le.setFromMatrixPosition(q.matrixWorld),K.setFromMatrixPosition(ve.matrixWorld);const Ce=le.distanceTo(K),ke=q.projectionMatrix.elements,We=ve.projectionMatrix.elements,tt=ke[14]/(ke[10]-1),nt=ke[14]/(ke[10]+1),ut=(ke[9]+1)/ke[5],kt=(ke[9]-1)/ke[5],vt=(ke[8]-1)/ke[0],se=(We[8]+1)/We[0],Ve=tt*vt,Ie=tt*se,je=Ce/(-vt+se),De=je*-vt;q.matrixWorld.decompose(z.position,z.quaternion,z.scale),z.translateX(De),z.translateZ(je),z.matrixWorld.compose(z.position,z.quaternion,z.scale),z.matrixWorldInverse.copy(z.matrixWorld).invert();const bt=tt+je,at=nt+je,dt=Ve-De,Pt=Ie+(Ce-De),Gt=ut*nt/at*bt,wn=kt*nt/at*bt;z.projectionMatrix.makePerspective(dt,Pt,Gt,wn,bt,at),z.projectionMatrixInverse.copy(z.projectionMatrix).invert()}function de(z,q){q===null?z.matrixWorld.copy(z.matrix):z.matrixWorld.multiplyMatrices(q.matrixWorld,z.matrix),z.matrixWorldInverse.copy(z.matrixWorld).invert()}this.updateCamera=function(z){if(i===null)return;V.near=F.near=I.near=z.near,V.far=F.far=I.far=z.far,(G!==V.near||L!==V.far)&&(i.updateRenderState({depthNear:V.near,depthFar:V.far}),G=V.near,L=V.far);const q=z.parent,ve=V.cameras;de(V,q);for(let Ce=0;Ce<ve.length;Ce++)de(ve[Ce],q);ve.length===2?ce(V,I,F):V.projectionMatrix.copy(I.projectionMatrix),me(z,V,q)};function me(z,q,ve){ve===null?z.matrix.copy(q.matrixWorld):(z.matrix.copy(ve.matrixWorld),z.matrix.invert(),z.matrix.multiply(q.matrixWorld)),z.matrix.decompose(z.position,z.quaternion,z.scale),z.updateMatrixWorld(!0),z.projectionMatrix.copy(q.projectionMatrix),z.projectionMatrixInverse.copy(q.projectionMatrixInverse),z.isPerspectiveCamera&&(z.fov=Xh*2*Math.atan(1/z.projectionMatrix.elements[5]),z.zoom=1)}this.getCamera=function(){return V},this.getFoveation=function(){if(!(y===null&&v===null))return u},this.setFoveation=function(z){u=z,y!==null&&(y.fixedFoveation=z),v!==null&&v.fixedFoveation!==void 0&&(v.fixedFoveation=z)};let Z=null;function re(z,q){if(p=q.getViewerPose(h||a),S=q,p!==null){const ve=p.views;v!==null&&(e.setRenderTargetFramebuffer(w,v.framebuffer),e.setRenderTarget(w));let Ce=!1;ve.length!==V.cameras.length&&(V.cameras.length=0,Ce=!0);for(let ke=0;ke<ve.length;ke++){const We=ve[ke];let tt=null;if(v!==null)tt=v.getViewport(We);else{const ut=m.getViewSubImage(y,We);tt=ut.viewport,ke===0&&(e.setRenderTargetTextures(w,ut.colorTexture,y.ignoreDepthValues?void 0:ut.depthStencilTexture),e.setRenderTarget(w))}let nt=U[ke];nt===void 0&&(nt=new Er,nt.layers.enable(ke),nt.viewport=new Cn,U[ke]=nt),nt.matrix.fromArray(We.transform.matrix),nt.matrix.decompose(nt.position,nt.quaternion,nt.scale),nt.projectionMatrix.fromArray(We.projectionMatrix),nt.projectionMatrixInverse.copy(nt.projectionMatrix).invert(),nt.viewport.set(tt.x,tt.y,tt.width,tt.height),ke===0&&(V.matrix.copy(nt.matrix),V.matrix.decompose(V.position,V.quaternion,V.scale)),Ce===!0&&V.cameras.push(nt)}}for(let ve=0;ve<C.length;ve++){const Ce=A[ve],ke=C[ve];Ce!==null&&ke!==void 0&&ke.update(Ce,q,h||a)}Z&&Z(z,q),q.detectedPlanes&&n.dispatchEvent({type:"planesdetected",data:q}),S=null}const ee=new QM;ee.setAnimationLoop(re),this.setAnimationLoop=function(z){Z=z},this.dispose=function(){}}}function Sz(r,e){function t(E,w){E.matrixAutoUpdate===!0&&E.updateMatrix(),w.value.copy(E.matrix)}function n(E,w){w.color.getRGB(E.fogColor.value,KM(r)),w.isFog?(E.fogNear.value=w.near,E.fogFar.value=w.far):w.isFogExp2&&(E.fogDensity.value=w.density)}function i(E,w,C,A,I){w.isMeshBasicMaterial||w.isMeshLambertMaterial?s(E,w):w.isMeshToonMaterial?(s(E,w),m(E,w)):w.isMeshPhongMaterial?(s(E,w),p(E,w)):w.isMeshStandardMaterial?(s(E,w),y(E,w),w.isMeshPhysicalMaterial&&v(E,w,I)):w.isMeshMatcapMaterial?(s(E,w),S(E,w)):w.isMeshDepthMaterial?s(E,w):w.isMeshDistanceMaterial?(s(E,w),T(E,w)):w.isMeshNormalMaterial?s(E,w):w.isLineBasicMaterial?(a(E,w),w.isLineDashedMaterial&&o(E,w)):w.isPointsMaterial?u(E,w,C,A):w.isSpriteMaterial?h(E,w):w.isShadowMaterial?(E.color.value.copy(w.color),E.opacity.value=w.opacity):w.isShaderMaterial&&(w.uniformsNeedUpdate=!1)}function s(E,w){E.opacity.value=w.opacity,w.color&&E.diffuse.value.copy(w.color),w.emissive&&E.emissive.value.copy(w.emissive).multiplyScalar(w.emissiveIntensity),w.map&&(E.map.value=w.map,t(w.map,E.mapTransform)),w.alphaMap&&(E.alphaMap.value=w.alphaMap,t(w.alphaMap,E.alphaMapTransform)),w.bumpMap&&(E.bumpMap.value=w.bumpMap,t(w.bumpMap,E.bumpMapTransform),E.bumpScale.value=w.bumpScale,w.side===Wi&&(E.bumpScale.value*=-1)),w.normalMap&&(E.normalMap.value=w.normalMap,t(w.normalMap,E.normalMapTransform),E.normalScale.value.copy(w.normalScale),w.side===Wi&&E.normalScale.value.negate()),w.displacementMap&&(E.displacementMap.value=w.displacementMap,t(w.displacementMap,E.displacementMapTransform),E.displacementScale.value=w.displacementScale,E.displacementBias.value=w.displacementBias),w.emissiveMap&&(E.emissiveMap.value=w.emissiveMap,t(w.emissiveMap,E.emissiveMapTransform)),w.specularMap&&(E.specularMap.value=w.specularMap,t(w.specularMap,E.specularMapTransform)),w.alphaTest>0&&(E.alphaTest.value=w.alphaTest);const C=e.get(w).envMap;if(C&&(E.envMap.value=C,E.flipEnvMap.value=C.isCubeTexture&&C.isRenderTargetTexture===!1?-1:1,E.reflectivity.value=w.reflectivity,E.ior.value=w.ior,E.refractionRatio.value=w.refractionRatio),w.lightMap){E.lightMap.value=w.lightMap;const A=r._useLegacyLights===!0?Math.PI:1;E.lightMapIntensity.value=w.lightMapIntensity*A,t(w.lightMap,E.lightMapTransform)}w.aoMap&&(E.aoMap.value=w.aoMap,E.aoMapIntensity.value=w.aoMapIntensity,t(w.aoMap,E.aoMapTransform))}function a(E,w){E.diffuse.value.copy(w.color),E.opacity.value=w.opacity,w.map&&(E.map.value=w.map,t(w.map,E.mapTransform))}function o(E,w){E.dashSize.value=w.dashSize,E.totalSize.value=w.dashSize+w.gapSize,E.scale.value=w.scale}function u(E,w,C,A){E.diffuse.value.copy(w.color),E.opacity.value=w.opacity,E.size.value=w.size*C,E.scale.value=A*.5,w.map&&(E.map.value=w.map,t(w.map,E.uvTransform)),w.alphaMap&&(E.alphaMap.value=w.alphaMap,t(w.alphaMap,E.alphaMapTransform)),w.alphaTest>0&&(E.alphaTest.value=w.alphaTest)}function h(E,w){E.diffuse.value.copy(w.color),E.opacity.value=w.opacity,E.rotation.value=w.rotation,w.map&&(E.map.value=w.map,t(w.map,E.mapTransform)),w.alphaMap&&(E.alphaMap.value=w.alphaMap,t(w.alphaMap,E.alphaMapTransform)),w.alphaTest>0&&(E.alphaTest.value=w.alphaTest)}function p(E,w){E.specular.value.copy(w.specular),E.shininess.value=Math.max(w.shininess,1e-4)}function m(E,w){w.gradientMap&&(E.gradientMap.value=w.gradientMap)}function y(E,w){E.metalness.value=w.metalness,w.metalnessMap&&(E.metalnessMap.value=w.metalnessMap,t(w.metalnessMap,E.metalnessMapTransform)),E.roughness.value=w.roughness,w.roughnessMap&&(E.roughnessMap.value=w.roughnessMap,t(w.roughnessMap,E.roughnessMapTransform)),e.get(w).envMap&&(E.envMapIntensity.value=w.envMapIntensity)}function v(E,w,C){E.ior.value=w.ior,w.sheen>0&&(E.sheenColor.value.copy(w.sheenColor).multiplyScalar(w.sheen),E.sheenRoughness.value=w.sheenRoughness,w.sheenColorMap&&(E.sheenColorMap.value=w.sheenColorMap,t(w.sheenColorMap,E.sheenColorMapTransform)),w.sheenRoughnessMap&&(E.sheenRoughnessMap.value=w.sheenRoughnessMap,t(w.sheenRoughnessMap,E.sheenRoughnessMapTransform))),w.clearcoat>0&&(E.clearcoat.value=w.clearcoat,E.clearcoatRoughness.value=w.clearcoatRoughness,w.clearcoatMap&&(E.clearcoatMap.value=w.clearcoatMap,t(w.clearcoatMap,E.clearcoatMapTransform)),w.clearcoatRoughnessMap&&(E.clearcoatRoughnessMap.value=w.clearcoatRoughnessMap,t(w.clearcoatRoughnessMap,E.clearcoatRoughnessMapTransform)),w.clearcoatNormalMap&&(E.clearcoatNormalMap.value=w.clearcoatNormalMap,t(w.clearcoatNormalMap,E.clearcoatNormalMapTransform),E.clearcoatNormalScale.value.copy(w.clearcoatNormalScale),w.side===Wi&&E.clearcoatNormalScale.value.negate())),w.iridescence>0&&(E.iridescence.value=w.iridescence,E.iridescenceIOR.value=w.iridescenceIOR,E.iridescenceThicknessMinimum.value=w.iridescenceThicknessRange[0],E.iridescenceThicknessMaximum.value=w.iridescenceThicknessRange[1],w.iridescenceMap&&(E.iridescenceMap.value=w.iridescenceMap,t(w.iridescenceMap,E.iridescenceMapTransform)),w.iridescenceThicknessMap&&(E.iridescenceThicknessMap.value=w.iridescenceThicknessMap,t(w.iridescenceThicknessMap,E.iridescenceThicknessMapTransform))),w.transmission>0&&(E.transmission.value=w.transmission,E.transmissionSamplerMap.value=C.texture,E.transmissionSamplerSize.value.set(C.width,C.height),w.transmissionMap&&(E.transmissionMap.value=w.transmissionMap,t(w.transmissionMap,E.transmissionMapTransform)),E.thickness.value=w.thickness,w.thicknessMap&&(E.thicknessMap.value=w.thicknessMap,t(w.thicknessMap,E.thicknessMapTransform)),E.attenuationDistance.value=w.attenuationDistance,E.attenuationColor.value.copy(w.attenuationColor)),w.anisotropy>0&&(E.anisotropyVector.value.set(w.anisotropy*Math.cos(w.anisotropyRotation),w.anisotropy*Math.sin(w.anisotropyRotation)),w.anisotropyMap&&(E.anisotropyMap.value=w.anisotropyMap,t(w.anisotropyMap,E.anisotropyMapTransform))),E.specularIntensity.value=w.specularIntensity,E.specularColor.value.copy(w.specularColor),w.specularColorMap&&(E.specularColorMap.value=w.specularColorMap,t(w.specularColorMap,E.specularColorMapTransform)),w.specularIntensityMap&&(E.specularIntensityMap.value=w.specularIntensityMap,t(w.specularIntensityMap,E.specularIntensityMapTransform))}function S(E,w){w.matcap&&(E.matcap.value=w.matcap)}function T(E,w){const C=e.get(w).light;E.referencePosition.value.setFromMatrixPosition(C.matrixWorld),E.nearDistance.value=C.shadow.camera.near,E.farDistance.value=C.shadow.camera.far}return{refreshFogUniforms:n,refreshMaterialUniforms:i}}function wz(r,e,t,n){let i={},s={},a=[];const o=t.isWebGL2?r.getParameter(r.MAX_UNIFORM_BUFFER_BINDINGS):0;function u(C,A){const I=A.program;n.uniformBlockBinding(C,I)}function h(C,A){let I=i[C.id];I===void 0&&(S(C),I=p(C),i[C.id]=I,C.addEventListener("dispose",E));const F=A.program;n.updateUBOMapping(C,F);const U=e.render.frame;s[C.id]!==U&&(y(C),s[C.id]=U)}function p(C){const A=m();C.__bindingPointIndex=A;const I=r.createBuffer(),F=C.__size,U=C.usage;return r.bindBuffer(r.UNIFORM_BUFFER,I),r.bufferData(r.UNIFORM_BUFFER,F,U),r.bindBuffer(r.UNIFORM_BUFFER,null),r.bindBufferBase(r.UNIFORM_BUFFER,A,I),I}function m(){for(let C=0;C<o;C++)if(a.indexOf(C)===-1)return a.push(C),C;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function y(C){const A=i[C.id],I=C.uniforms,F=C.__cache;r.bindBuffer(r.UNIFORM_BUFFER,A);for(let U=0,V=I.length;U<V;U++){const G=I[U];if(v(G,U,F)===!0){const L=G.__offset,k=Array.isArray(G.value)?G.value:[G.value];let O=0;for(let Q=0;Q<k.length;Q++){const le=k[Q],K=T(le);typeof le=="number"?(G.__data[0]=le,r.bufferSubData(r.UNIFORM_BUFFER,L+O,G.__data)):le.isMatrix3?(G.__data[0]=le.elements[0],G.__data[1]=le.elements[1],G.__data[2]=le.elements[2],G.__data[3]=le.elements[0],G.__data[4]=le.elements[3],G.__data[5]=le.elements[4],G.__data[6]=le.elements[5],G.__data[7]=le.elements[0],G.__data[8]=le.elements[6],G.__data[9]=le.elements[7],G.__data[10]=le.elements[8],G.__data[11]=le.elements[0]):(le.toArray(G.__data,O),O+=K.storage/Float32Array.BYTES_PER_ELEMENT)}r.bufferSubData(r.UNIFORM_BUFFER,L,G.__data)}}r.bindBuffer(r.UNIFORM_BUFFER,null)}function v(C,A,I){const F=C.value;if(I[A]===void 0){if(typeof F=="number")I[A]=F;else{const U=Array.isArray(F)?F:[F],V=[];for(let G=0;G<U.length;G++)V.push(U[G].clone());I[A]=V}return!0}else if(typeof F=="number"){if(I[A]!==F)return I[A]=F,!0}else{const U=Array.isArray(I[A])?I[A]:[I[A]],V=Array.isArray(F)?F:[F];for(let G=0;G<U.length;G++){const L=U[G];if(L.equals(V[G])===!1)return L.copy(V[G]),!0}}return!1}function S(C){const A=C.uniforms;let I=0;const F=16;let U=0;for(let V=0,G=A.length;V<G;V++){const L=A[V],k={boundary:0,storage:0},O=Array.isArray(L.value)?L.value:[L.value];for(let Q=0,le=O.length;Q<le;Q++){const K=O[Q],ce=T(K);k.boundary+=ce.boundary,k.storage+=ce.storage}if(L.__data=new Float32Array(k.storage/Float32Array.BYTES_PER_ELEMENT),L.__offset=I,V>0){U=I%F;const Q=F-U;U!==0&&Q-k.boundary<0&&(I+=F-U,L.__offset=I)}I+=k.storage}return U=I%F,U>0&&(I+=F-U),C.__size=I,C.__cache={},this}function T(C){const A={boundary:0,storage:0};return typeof C=="number"?(A.boundary=4,A.storage=4):C.isVector2?(A.boundary=8,A.storage=8):C.isVector3||C.isColor?(A.boundary=16,A.storage=12):C.isVector4?(A.boundary=16,A.storage=16):C.isMatrix3?(A.boundary=48,A.storage=48):C.isMatrix4?(A.boundary=64,A.storage=64):C.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",C),A}function E(C){const A=C.target;A.removeEventListener("dispose",E);const I=a.indexOf(A.__bindingPointIndex);a.splice(I,1),r.deleteBuffer(i[A.id]),delete i[A.id],delete s[A.id]}function w(){for(const C in i)r.deleteBuffer(i[C]);a=[],i={},s={}}return{bind:u,update:h,dispose:w}}class BS{constructor(e={}){const{canvas:t=jM(),context:n=null,depth:i=!0,stencil:s=!0,alpha:a=!1,antialias:o=!1,premultipliedAlpha:u=!0,preserveDrawingBuffer:h=!1,powerPreference:p="default",failIfMajorPerformanceCaveat:m=!1}=e;this.isWebGLRenderer=!0;let y;n!==null?y=n.getContextAttributes().alpha:y=a;const v=new Uint32Array(4),S=new Int32Array(4);let T=null,E=null;const w=[],C=[];this.domElement=t,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this._outputColorSpace=Hr,this._useLegacyLights=!1,this.toneMapping=eo,this.toneMappingExposure=1;const A=this;let I=!1,F=0,U=0,V=null,G=-1,L=null;const k=new Cn,O=new Cn;let Q=null;const le=new yt(0);let K=0,ce=t.width,de=t.height,me=1,Z=null,re=null;const ee=new Cn(0,0,ce,de),z=new Cn(0,0,ce,de);let q=!1;const ve=new A0;let Ce=!1,ke=!1,We=null;const tt=new Jt,nt=new Pe,ut=new X,kt={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function vt(){return V===null?me:1}let se=n;function Ve(W,ge){for(let Ee=0;Ee<W.length;Ee++){const Te=W[Ee],Me=t.getContext(Te,ge);if(Me!==null)return Me}return null}try{const W={alpha:!0,depth:i,stencil:s,antialias:o,premultipliedAlpha:u,preserveDrawingBuffer:h,powerPreference:p,failIfMajorPerformanceCaveat:m};if("setAttribute"in t&&t.setAttribute("data-engine",`three.js r${x0}`),t.addEventListener("webglcontextlost",Ct,!1),t.addEventListener("webglcontextrestored",ue,!1),t.addEventListener("webglcontextcreationerror",Qe,!1),se===null){const ge=["webgl2","webgl","experimental-webgl"];if(A.isWebGL1Renderer===!0&&ge.shift(),se=Ve(ge,W),se===null)throw Ve(ge)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}typeof WebGLRenderingContext<"u"&&se instanceof WebGLRenderingContext&&console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."),se.getShaderPrecisionFormat===void 0&&(se.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(W){throw console.error("THREE.WebGLRenderer: "+W.message),W}let Ie,je,De,bt,at,dt,Pt,Gt,wn,J,$,Se,qe,Oe,He,St,Ke,rt,zt,un,Xe,fn,ae,Ne;function ze(){Ie=new FF(se),je=new IF(se,Ie,e),Ie.init(je),fn=new iA(se,Ie,je),De=new yz(se,Ie,je),bt=new BF(se),at=new sz,dt=new vz(se,Ie,De,at,je,fn,bt),Pt=new LF(A),Gt=new OF(A),wn=new Yk(se,je),ae=new CF(se,Ie,wn,je),J=new UF(se,wn,bt,ae),$=new GF(se,J,wn,bt),zt=new $F(se,je,dt),St=new PF(at),Se=new iz(A,Pt,Gt,Ie,je,ae,St),qe=new Sz(A,at),Oe=new oz,He=new dz(Ie,je),rt=new NF(A,Pt,Gt,De,$,y,u),Ke=new gz(A,$,je),Ne=new wz(se,bt,je,De),un=new RF(se,Ie,bt,je),Xe=new zF(se,Ie,bt,je),bt.programs=Se.programs,A.capabilities=je,A.extensions=Ie,A.properties=at,A.renderLists=Oe,A.shadowMap=Ke,A.state=De,A.info=bt}ze();const Fe=new xz(A,se);this.xr=Fe,this.getContext=function(){return se},this.getContextAttributes=function(){return se.getContextAttributes()},this.forceContextLoss=function(){const W=Ie.get("WEBGL_lose_context");W&&W.loseContext()},this.forceContextRestore=function(){const W=Ie.get("WEBGL_lose_context");W&&W.restoreContext()},this.getPixelRatio=function(){return me},this.setPixelRatio=function(W){W!==void 0&&(me=W,this.setSize(ce,de,!1))},this.getSize=function(W){return W.set(ce,de)},this.setSize=function(W,ge,Ee=!0){if(Fe.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}ce=W,de=ge,t.width=Math.floor(W*me),t.height=Math.floor(ge*me),Ee===!0&&(t.style.width=W+"px",t.style.height=ge+"px"),this.setViewport(0,0,W,ge)},this.getDrawingBufferSize=function(W){return W.set(ce*me,de*me).floor()},this.setDrawingBufferSize=function(W,ge,Ee){ce=W,de=ge,me=Ee,t.width=Math.floor(W*Ee),t.height=Math.floor(ge*Ee),this.setViewport(0,0,W,ge)},this.getCurrentViewport=function(W){return W.copy(k)},this.getViewport=function(W){return W.copy(ee)},this.setViewport=function(W,ge,Ee,Te){W.isVector4?ee.set(W.x,W.y,W.z,W.w):ee.set(W,ge,Ee,Te),De.viewport(k.copy(ee).multiplyScalar(me).floor())},this.getScissor=function(W){return W.copy(z)},this.setScissor=function(W,ge,Ee,Te){W.isVector4?z.set(W.x,W.y,W.z,W.w):z.set(W,ge,Ee,Te),De.scissor(O.copy(z).multiplyScalar(me).floor())},this.getScissorTest=function(){return q},this.setScissorTest=function(W){De.setScissorTest(q=W)},this.setOpaqueSort=function(W){Z=W},this.setTransparentSort=function(W){re=W},this.getClearColor=function(W){return W.copy(rt.getClearColor())},this.setClearColor=function(){rt.setClearColor.apply(rt,arguments)},this.getClearAlpha=function(){return rt.getClearAlpha()},this.setClearAlpha=function(){rt.setClearAlpha.apply(rt,arguments)},this.clear=function(W=!0,ge=!0,Ee=!0){let Te=0;if(W){let Me=!1;if(V!==null){const ft=V.texture.format;Me=ft===CS||ft===NS||ft===AS}if(Me){const ft=V.texture.type,Rt=ft===to||ft===il||ft===E0||ft===lu||ft===TS||ft===MS,Dt=rt.getClearColor(),ht=rt.getClearAlpha(),Wt=Dt.r,Bt=Dt.g,$t=Dt.b;Rt?(v[0]=Wt,v[1]=Bt,v[2]=$t,v[3]=ht,se.clearBufferuiv(se.COLOR,0,v)):(S[0]=Wt,S[1]=Bt,S[2]=$t,S[3]=ht,se.clearBufferiv(se.COLOR,0,S))}else Te|=se.COLOR_BUFFER_BIT}ge&&(Te|=se.DEPTH_BUFFER_BIT),Ee&&(Te|=se.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),se.clear(Te)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",Ct,!1),t.removeEventListener("webglcontextrestored",ue,!1),t.removeEventListener("webglcontextcreationerror",Qe,!1),Oe.dispose(),He.dispose(),at.dispose(),Pt.dispose(),Gt.dispose(),$.dispose(),ae.dispose(),Ne.dispose(),Se.dispose(),Fe.dispose(),Fe.removeEventListener("sessionstart",Zn),Fe.removeEventListener("sessionend",an),We&&(We.dispose(),We=null),gr.stop()};function Ct(W){W.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),I=!0}function ue(){console.log("THREE.WebGLRenderer: Context Restored."),I=!1;const W=bt.autoReset,ge=Ke.enabled,Ee=Ke.autoUpdate,Te=Ke.needsUpdate,Me=Ke.type;ze(),bt.autoReset=W,Ke.enabled=ge,Ke.autoUpdate=Ee,Ke.needsUpdate=Te,Ke.type=Me}function Qe(W){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",W.statusMessage)}function Ze(W){const ge=W.target;ge.removeEventListener("dispose",Ze),Re(ge)}function Re(W){$e(W),at.remove(W)}function $e(W){const ge=at.get(W).programs;ge!==void 0&&(ge.forEach(function(Ee){Se.releaseProgram(Ee)}),W.isShaderMaterial&&Se.releaseShaderCache(W))}this.renderBufferDirect=function(W,ge,Ee,Te,Me,ft){ge===null&&(ge=kt);const Rt=Me.isMesh&&Me.matrixWorld.determinant()<0,Dt=pd(W,ge,Ee,Te,Me);De.setMaterial(Te,Rt);let ht=Ee.index,Wt=1;if(Te.wireframe===!0){if(ht=J.getWireframeAttribute(Ee),ht===void 0)return;Wt=2}const Bt=Ee.drawRange,$t=Ee.attributes.position;let In=Bt.start*Wt,kr=(Bt.start+Bt.count)*Wt;ft!==null&&(In=Math.max(In,ft.start*Wt),kr=Math.min(kr,(ft.start+ft.count)*Wt)),ht!==null?(In=Math.max(In,0),kr=Math.min(kr,ht.count)):$t!=null&&(In=Math.max(In,0),kr=Math.min(kr,$t.count));const Pn=kr-In;if(Pn<0||Pn===1/0)return;ae.setup(Me,Te,Dt,Ee,ht);let sr,It=un;if(ht!==null&&(sr=wn.get(ht),It=Xe,It.setIndex(sr)),Me.isMesh)Te.wireframe===!0?(De.setLineWidth(Te.wireframeLinewidth*vt()),It.setMode(se.LINES)):It.setMode(se.TRIANGLES);else if(Me.isLine){let xt=Te.linewidth;xt===void 0&&(xt=1),De.setLineWidth(xt*vt()),Me.isLineSegments?It.setMode(se.LINES):Me.isLineLoop?It.setMode(se.LINE_LOOP):It.setMode(se.LINE_STRIP)}else Me.isPoints?It.setMode(se.POINTS):Me.isSprite&&It.setMode(se.TRIANGLES);if(Me.isInstancedMesh)It.renderInstances(In,Pn,Me.count);else if(Ee.isInstancedBufferGeometry){const xt=Ee._maxInstanceCount!==void 0?Ee._maxInstanceCount:1/0,Jn=Math.min(Ee.instanceCount,xt);It.renderInstances(In,Pn,Jn)}else It.render(In,Pn)};function Et(W,ge,Ee){W.transparent===!0&&W.side===Za&&W.forceSinglePass===!1?(W.side=Wi,W.needsUpdate=!0,Da(W,ge,Ee),W.side=ll,W.needsUpdate=!0,Da(W,ge,Ee),W.side=Za):Da(W,ge,Ee)}this.compile=function(W,ge,Ee=null){Ee===null&&(Ee=W),E=He.get(Ee),E.init(),C.push(E),Ee.traverseVisible(function(Me){Me.isLight&&Me.layers.test(ge.layers)&&(E.pushLight(Me),Me.castShadow&&E.pushShadow(Me))}),W!==Ee&&W.traverseVisible(function(Me){Me.isLight&&Me.layers.test(ge.layers)&&(E.pushLight(Me),Me.castShadow&&E.pushShadow(Me))}),E.setupLights(A._useLegacyLights);const Te=new Set;return W.traverse(function(Me){const ft=Me.material;if(ft)if(Array.isArray(ft))for(let Rt=0;Rt<ft.length;Rt++){const Dt=ft[Rt];Et(Dt,Ee,Me),Te.add(Dt)}else Et(ft,Ee,Me),Te.add(ft)}),C.pop(),E=null,Te},this.compileAsync=function(W,ge,Ee=null){const Te=this.compile(W,ge,Ee);return new Promise(Me=>{function ft(){if(Te.forEach(function(Rt){at.get(Rt).currentProgram.isReady()&&Te.delete(Rt)}),Te.size===0){Me(W);return}setTimeout(ft,10)}Ie.get("KHR_parallel_shader_compile")!==null?ft():setTimeout(ft,10)})};let Yt=null;function yn(W){Yt&&Yt(W)}function Zn(){gr.stop()}function an(){gr.start()}const gr=new QM;gr.setAnimationLoop(yn),typeof self<"u"&&gr.setContext(self),this.setAnimationLoop=function(W){Yt=W,Fe.setAnimationLoop(W),W===null?gr.stop():gr.start()},Fe.addEventListener("sessionstart",Zn),Fe.addEventListener("sessionend",an),this.render=function(W,ge){if(ge!==void 0&&ge.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(I===!0)return;W.matrixWorldAutoUpdate===!0&&W.updateMatrixWorld(),ge.parent===null&&ge.matrixWorldAutoUpdate===!0&&ge.updateMatrixWorld(),Fe.enabled===!0&&Fe.isPresenting===!0&&(Fe.cameraAutoUpdate===!0&&Fe.updateCamera(ge),ge=Fe.getCamera()),W.isScene===!0&&W.onBeforeRender(A,W,ge,V),E=He.get(W,C.length),E.init(),C.push(E),tt.multiplyMatrices(ge.projectionMatrix,ge.matrixWorldInverse),ve.setFromProjectionMatrix(tt),ke=this.localClippingEnabled,Ce=St.init(this.clippingPlanes,ke),T=Oe.get(W,w.length),T.init(),w.push(T),qr(W,ge,0,A.sortObjects),T.finish(),A.sortObjects===!0&&T.sort(Z,re),this.info.render.frame++,Ce===!0&&St.beginShadows();const Ee=E.state.shadowsArray;if(Ke.render(Ee,W,ge),Ce===!0&&St.endShadows(),this.info.autoReset===!0&&this.info.reset(),rt.render(T,W),E.setupLights(A._useLegacyLights),ge.isArrayCamera){const Te=ge.cameras;for(let Me=0,ft=Te.length;Me<ft;Me++){const Rt=Te[Me];Cu(T,W,Rt,Rt.viewport)}}else Cu(T,W,ge);V!==null&&(dt.updateMultisampleRenderTarget(V),dt.updateRenderTargetMipmap(V)),W.isScene===!0&&W.onAfterRender(A,W,ge),ae.resetDefaultState(),G=-1,L=null,C.pop(),C.length>0?E=C[C.length-1]:E=null,w.pop(),w.length>0?T=w[w.length-1]:T=null};function qr(W,ge,Ee,Te){if(W.visible===!1)return;if(W.layers.test(ge.layers)){if(W.isGroup)Ee=W.renderOrder;else if(W.isLOD)W.autoUpdate===!0&&W.update(ge);else if(W.isLight)E.pushLight(W),W.castShadow&&E.pushShadow(W);else if(W.isSprite){if(!W.frustumCulled||ve.intersectsSprite(W)){Te&&ut.setFromMatrixPosition(W.matrixWorld).applyMatrix4(tt);const Rt=$.update(W),Dt=W.material;Dt.visible&&T.push(W,Rt,Dt,Ee,ut.z,null)}}else if((W.isMesh||W.isLine||W.isPoints)&&(!W.frustumCulled||ve.intersectsObject(W))){const Rt=$.update(W),Dt=W.material;if(Te&&(W.boundingSphere!==void 0?(W.boundingSphere===null&&W.computeBoundingSphere(),ut.copy(W.boundingSphere.center)):(Rt.boundingSphere===null&&Rt.computeBoundingSphere(),ut.copy(Rt.boundingSphere.center)),ut.applyMatrix4(W.matrixWorld).applyMatrix4(tt)),Array.isArray(Dt)){const ht=Rt.groups;for(let Wt=0,Bt=ht.length;Wt<Bt;Wt++){const $t=ht[Wt],In=Dt[$t.materialIndex];In&&In.visible&&T.push(W,Rt,In,Ee,ut.z,$t)}}else Dt.visible&&T.push(W,Rt,Dt,Ee,ut.z,null)}}const ft=W.children;for(let Rt=0,Dt=ft.length;Rt<Dt;Rt++)qr(ft[Rt],ge,Ee,Te)}function Cu(W,ge,Ee,Te){const Me=W.opaque,ft=W.transmissive,Rt=W.transparent;E.setupLightsView(Ee),Ce===!0&&St.setGlobalState(A.clippingPlanes,Ee),ft.length>0&&Xs(Me,ft,ge,Ee),Te&&De.viewport(k.copy(Te)),Me.length>0&&Ks(Me,ge,Ee),ft.length>0&&Ks(ft,ge,Ee),Rt.length>0&&Ks(Rt,ge,Ee),De.buffers.depth.setTest(!0),De.buffers.depth.setMask(!0),De.buffers.color.setMask(!0),De.setPolygonOffset(!1)}function Xs(W,ge,Ee,Te){if((Ee.isScene===!0?Ee.overrideMaterial:null)!==null)return;const ft=je.isWebGL2;We===null&&(We=new Ca(1,1,{generateMipmaps:!0,type:Ie.has("EXT_color_buffer_half_float")?qh:to,minFilter:pu,samples:ft?4:0})),A.getDrawingBufferSize(nt),ft?We.setSize(nt.x,nt.y):We.setSize(t0(nt.x),t0(nt.y));const Rt=A.getRenderTarget();A.setRenderTarget(We),A.getClearColor(le),K=A.getClearAlpha(),K<1&&A.setClearColor(16777215,.5),A.clear();const Dt=A.toneMapping;A.toneMapping=eo,Ks(W,Ee,Te),dt.updateMultisampleRenderTarget(We),dt.updateRenderTargetMipmap(We);let ht=!1;for(let Wt=0,Bt=ge.length;Wt<Bt;Wt++){const $t=ge[Wt],In=$t.object,kr=$t.geometry,Pn=$t.material,sr=$t.group;if(Pn.side===Za&&In.layers.test(Te.layers)){const It=Pn.side;Pn.side=Wi,Pn.needsUpdate=!0,ys(In,Ee,Te,kr,Pn,sr),Pn.side=It,Pn.needsUpdate=!0,ht=!0}}ht===!0&&(dt.updateMultisampleRenderTarget(We),dt.updateRenderTargetMipmap(We)),A.setRenderTarget(Rt),A.setClearColor(le,K),A.toneMapping=Dt}function Ks(W,ge,Ee){const Te=ge.isScene===!0?ge.overrideMaterial:null;for(let Me=0,ft=W.length;Me<ft;Me++){const Rt=W[Me],Dt=Rt.object,ht=Rt.geometry,Wt=Te===null?Rt.material:Te,Bt=Rt.group;Dt.layers.test(Ee.layers)&&ys(Dt,ge,Ee,ht,Wt,Bt)}}function ys(W,ge,Ee,Te,Me,ft){W.onBeforeRender(A,ge,Ee,Te,Me,ft),W.modelViewMatrix.multiplyMatrices(Ee.matrixWorldInverse,W.matrixWorld),W.normalMatrix.getNormalMatrix(W.modelViewMatrix),Me.onBeforeRender(A,ge,Ee,Te,W,ft),Me.transparent===!0&&Me.side===Za&&Me.forceSinglePass===!1?(Me.side=Wi,Me.needsUpdate=!0,A.renderBufferDirect(Ee,ge,Te,Me,W,ft),Me.side=ll,Me.needsUpdate=!0,A.renderBufferDirect(Ee,ge,Te,Me,W,ft),Me.side=Za):A.renderBufferDirect(Ee,ge,Te,Me,W,ft),W.onAfterRender(A,ge,Ee,Te,Me,ft)}function Da(W,ge,Ee){ge.isScene!==!0&&(ge=kt);const Te=at.get(W),Me=E.state.lights,ft=E.state.shadowsArray,Rt=Me.state.version,Dt=Se.getParameters(W,Me.state,ft,ge,Ee),ht=Se.getProgramCacheKey(Dt);let Wt=Te.programs;Te.environment=W.isMeshStandardMaterial?ge.environment:null,Te.fog=ge.fog,Te.envMap=(W.isMeshStandardMaterial?Gt:Pt).get(W.envMap||Te.environment),Wt===void 0&&(W.addEventListener("dispose",Ze),Wt=new Map,Te.programs=Wt);let Bt=Wt.get(ht);if(Bt!==void 0){if(Te.currentProgram===Bt&&Te.lightsStateVersion===Rt)return ff(W,Dt),Bt}else Dt.uniforms=Se.getUniforms(W),W.onBuild(Ee,Dt,A),W.onBeforeCompile(Dt,A),Bt=Se.acquireProgram(Dt,ht),Wt.set(ht,Bt),Te.uniforms=Dt.uniforms;const $t=Te.uniforms;return(!W.isShaderMaterial&&!W.isRawShaderMaterial||W.clipping===!0)&&($t.clippingPlanes=St.uniform),ff(W,Dt),Te.needsLights=hf(W),Te.lightsStateVersion=Rt,Te.needsLights&&($t.ambientLightColor.value=Me.state.ambient,$t.lightProbe.value=Me.state.probe,$t.directionalLights.value=Me.state.directional,$t.directionalLightShadows.value=Me.state.directionalShadow,$t.spotLights.value=Me.state.spot,$t.spotLightShadows.value=Me.state.spotShadow,$t.rectAreaLights.value=Me.state.rectArea,$t.ltc_1.value=Me.state.rectAreaLTC1,$t.ltc_2.value=Me.state.rectAreaLTC2,$t.pointLights.value=Me.state.point,$t.pointLightShadows.value=Me.state.pointShadow,$t.hemisphereLights.value=Me.state.hemi,$t.directionalShadowMap.value=Me.state.directionalShadowMap,$t.directionalShadowMatrix.value=Me.state.directionalShadowMatrix,$t.spotShadowMap.value=Me.state.spotShadowMap,$t.spotLightMatrix.value=Me.state.spotLightMatrix,$t.spotLightMap.value=Me.state.spotLightMap,$t.pointShadowMap.value=Me.state.pointShadowMap,$t.pointShadowMatrix.value=Me.state.pointShadowMatrix),Te.currentProgram=Bt,Te.uniformsList=null,Bt}function cf(W){if(W.uniformsList===null){const ge=W.currentProgram.getUniforms();W.uniformsList=Uy.seqWithValue(ge.seq,W.uniforms)}return W.uniformsList}function ff(W,ge){const Ee=at.get(W);Ee.outputColorSpace=ge.outputColorSpace,Ee.instancing=ge.instancing,Ee.instancingColor=ge.instancingColor,Ee.skinning=ge.skinning,Ee.morphTargets=ge.morphTargets,Ee.morphNormals=ge.morphNormals,Ee.morphColors=ge.morphColors,Ee.morphTargetsCount=ge.morphTargetsCount,Ee.numClippingPlanes=ge.numClippingPlanes,Ee.numIntersection=ge.numClipIntersection,Ee.vertexAlphas=ge.vertexAlphas,Ee.vertexTangents=ge.vertexTangents,Ee.toneMapping=ge.toneMapping}function pd(W,ge,Ee,Te,Me){ge.isScene!==!0&&(ge=kt),dt.resetTextureUnits();const ft=ge.fog,Rt=Te.isMeshStandardMaterial?ge.environment:null,Dt=V===null?A.outputColorSpace:V.isXRRenderTarget===!0?V.texture.colorSpace:ro,ht=(Te.isMeshStandardMaterial?Gt:Pt).get(Te.envMap||Rt),Wt=Te.vertexColors===!0&&!!Ee.attributes.color&&Ee.attributes.color.itemSize===4,Bt=!!Ee.attributes.tangent&&(!!Te.normalMap||Te.anisotropy>0),$t=!!Ee.morphAttributes.position,In=!!Ee.morphAttributes.normal,kr=!!Ee.morphAttributes.color;let Pn=eo;Te.toneMapped&&(V===null||V.isXRRenderTarget===!0)&&(Pn=A.toneMapping);const sr=Ee.morphAttributes.position||Ee.morphAttributes.normal||Ee.morphAttributes.color,It=sr!==void 0?sr.length:0,xt=at.get(Te),Jn=E.state.lights;if(Ce===!0&&(ke===!0||W!==L)){const Mr=W===L&&Te.id===G;St.setState(Te,W,Mr)}let on=!1;Te.version===xt.__version?(xt.needsLights&&xt.lightsStateVersion!==Jn.state.version||xt.outputColorSpace!==Dt||Me.isInstancedMesh&&xt.instancing===!1||!Me.isInstancedMesh&&xt.instancing===!0||Me.isSkinnedMesh&&xt.skinning===!1||!Me.isSkinnedMesh&&xt.skinning===!0||Me.isInstancedMesh&&xt.instancingColor===!0&&Me.instanceColor===null||Me.isInstancedMesh&&xt.instancingColor===!1&&Me.instanceColor!==null||xt.envMap!==ht||Te.fog===!0&&xt.fog!==ft||xt.numClippingPlanes!==void 0&&(xt.numClippingPlanes!==St.numPlanes||xt.numIntersection!==St.numIntersection)||xt.vertexAlphas!==Wt||xt.vertexTangents!==Bt||xt.morphTargets!==$t||xt.morphNormals!==In||xt.morphColors!==kr||xt.toneMapping!==Pn||je.isWebGL2===!0&&xt.morphTargetsCount!==It)&&(on=!0):(on=!0,xt.__version=Te.version);let Qn=xt.currentProgram;on===!0&&(Qn=Da(Te,ge,Me));let Ls=!1,ni=!1,ar=!1;const Gn=Qn.getUniforms(),Pi=xt.uniforms;if(De.useProgram(Qn.program)&&(Ls=!0,ni=!0,ar=!0),Te.id!==G&&(G=Te.id,ni=!0),Ls||L!==W){Gn.setValue(se,"projectionMatrix",W.projectionMatrix),Gn.setValue(se,"viewMatrix",W.matrixWorldInverse);const Mr=Gn.map.cameraPosition;Mr!==void 0&&Mr.setValue(se,ut.setFromMatrixPosition(W.matrixWorld)),je.logarithmicDepthBuffer&&Gn.setValue(se,"logDepthBufFC",2/(Math.log(W.far+1)/Math.LN2)),(Te.isMeshPhongMaterial||Te.isMeshToonMaterial||Te.isMeshLambertMaterial||Te.isMeshBasicMaterial||Te.isMeshStandardMaterial||Te.isShaderMaterial)&&Gn.setValue(se,"isOrthographic",W.isOrthographicCamera===!0),L!==W&&(L=W,ni=!0,ar=!0)}if(Me.isSkinnedMesh){Gn.setOptional(se,Me,"bindMatrix"),Gn.setOptional(se,Me,"bindMatrixInverse");const Mr=Me.skeleton;Mr&&(je.floatVertexTextures?(Mr.boneTexture===null&&Mr.computeBoneTexture(),Gn.setValue(se,"boneTexture",Mr.boneTexture,dt),Gn.setValue(se,"boneTextureSize",Mr.boneTextureSize)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}const ml=Ee.morphAttributes;if((ml.position!==void 0||ml.normal!==void 0||ml.color!==void 0&&je.isWebGL2===!0)&&zt.update(Me,Ee,Qn),(ni||xt.receiveShadow!==Me.receiveShadow)&&(xt.receiveShadow=Me.receiveShadow,Gn.setValue(se,"receiveShadow",Me.receiveShadow)),Te.isMeshGouraudMaterial&&Te.envMap!==null&&(Pi.envMap.value=ht,Pi.flipEnvMap.value=ht.isCubeTexture&&ht.isRenderTargetTexture===!1?-1:1),ni&&(Gn.setValue(se,"toneMappingExposure",A.toneMappingExposure),xt.needsLights&&Ys(Pi,ar),ft&&Te.fog===!0&&qe.refreshFogUniforms(Pi,ft),qe.refreshMaterialUniforms(Pi,Te,me,de,We),Uy.upload(se,cf(xt),Pi,dt)),Te.isShaderMaterial&&Te.uniformsNeedUpdate===!0&&(Uy.upload(se,cf(xt),Pi,dt),Te.uniformsNeedUpdate=!1),Te.isSpriteMaterial&&Gn.setValue(se,"center",Me.center),Gn.setValue(se,"modelViewMatrix",Me.modelViewMatrix),Gn.setValue(se,"normalMatrix",Me.normalMatrix),Gn.setValue(se,"modelMatrix",Me.matrixWorld),Te.isShaderMaterial||Te.isRawShaderMaterial){const Mr=Te.uniformsGroups;for(let Oa=0,pi=Mr.length;Oa<pi;Oa++)if(je.isWebGL2){const gl=Mr[Oa];Ne.update(gl,Qn),Ne.bind(gl,Qn)}else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")}return Qn}function Ys(W,ge){W.ambientLightColor.needsUpdate=ge,W.lightProbe.needsUpdate=ge,W.directionalLights.needsUpdate=ge,W.directionalLightShadows.needsUpdate=ge,W.pointLights.needsUpdate=ge,W.pointLightShadows.needsUpdate=ge,W.spotLights.needsUpdate=ge,W.spotLightShadows.needsUpdate=ge,W.rectAreaLights.needsUpdate=ge,W.hemisphereLights.needsUpdate=ge}function hf(W){return W.isMeshLambertMaterial||W.isMeshToonMaterial||W.isMeshPhongMaterial||W.isMeshStandardMaterial||W.isShadowMaterial||W.isShaderMaterial&&W.lights===!0}this.getActiveCubeFace=function(){return F},this.getActiveMipmapLevel=function(){return U},this.getRenderTarget=function(){return V},this.setRenderTargetTextures=function(W,ge,Ee){at.get(W.texture).__webglTexture=ge,at.get(W.depthTexture).__webglTexture=Ee;const Te=at.get(W);Te.__hasExternalTextures=!0,Te.__hasExternalTextures&&(Te.__autoAllocateDepthBuffer=Ee===void 0,Te.__autoAllocateDepthBuffer||Ie.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),Te.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(W,ge){const Ee=at.get(W);Ee.__webglFramebuffer=ge,Ee.__useDefaultFramebuffer=ge===void 0},this.setRenderTarget=function(W,ge=0,Ee=0){V=W,F=ge,U=Ee;let Te=!0,Me=null,ft=!1,Rt=!1;if(W){const ht=at.get(W);ht.__useDefaultFramebuffer!==void 0?(De.bindFramebuffer(se.FRAMEBUFFER,null),Te=!1):ht.__webglFramebuffer===void 0?dt.setupRenderTarget(W):ht.__hasExternalTextures&&dt.rebindTextures(W,at.get(W.texture).__webglTexture,at.get(W.depthTexture).__webglTexture);const Wt=W.texture;(Wt.isData3DTexture||Wt.isDataArrayTexture||Wt.isCompressedArrayTexture)&&(Rt=!0);const Bt=at.get(W).__webglFramebuffer;W.isWebGLCubeRenderTarget?(Array.isArray(Bt[ge])?Me=Bt[ge][Ee]:Me=Bt[ge],ft=!0):je.isWebGL2&&W.samples>0&&dt.useMultisampledRTT(W)===!1?Me=at.get(W).__webglMultisampledFramebuffer:Array.isArray(Bt)?Me=Bt[Ee]:Me=Bt,k.copy(W.viewport),O.copy(W.scissor),Q=W.scissorTest}else k.copy(ee).multiplyScalar(me).floor(),O.copy(z).multiplyScalar(me).floor(),Q=q;if(De.bindFramebuffer(se.FRAMEBUFFER,Me)&&je.drawBuffers&&Te&&De.drawBuffers(W,Me),De.viewport(k),De.scissor(O),De.setScissorTest(Q),ft){const ht=at.get(W.texture);se.framebufferTexture2D(se.FRAMEBUFFER,se.COLOR_ATTACHMENT0,se.TEXTURE_CUBE_MAP_POSITIVE_X+ge,ht.__webglTexture,Ee)}else if(Rt){const ht=at.get(W.texture),Wt=ge||0;se.framebufferTextureLayer(se.FRAMEBUFFER,se.COLOR_ATTACHMENT0,ht.__webglTexture,Ee||0,Wt)}G=-1},this.readRenderTargetPixels=function(W,ge,Ee,Te,Me,ft,Rt){if(!(W&&W.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let Dt=at.get(W).__webglFramebuffer;if(W.isWebGLCubeRenderTarget&&Rt!==void 0&&(Dt=Dt[Rt]),Dt){De.bindFramebuffer(se.FRAMEBUFFER,Dt);try{const ht=W.texture,Wt=ht.format,Bt=ht.type;if(Wt!==hs&&fn.convert(Wt)!==se.getParameter(se.IMPLEMENTATION_COLOR_READ_FORMAT)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const $t=Bt===qh&&(Ie.has("EXT_color_buffer_half_float")||je.isWebGL2&&Ie.has("EXT_color_buffer_float"));if(Bt!==to&&fn.convert(Bt)!==se.getParameter(se.IMPLEMENTATION_COLOR_READ_TYPE)&&!(Bt===Ja&&(je.isWebGL2||Ie.has("OES_texture_float")||Ie.has("WEBGL_color_buffer_float")))&&!$t){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}ge>=0&&ge<=W.width-Te&&Ee>=0&&Ee<=W.height-Me&&se.readPixels(ge,Ee,Te,Me,fn.convert(Wt),fn.convert(Bt),ft)}finally{const ht=V!==null?at.get(V).__webglFramebuffer:null;De.bindFramebuffer(se.FRAMEBUFFER,ht)}}},this.copyFramebufferToTexture=function(W,ge,Ee=0){const Te=Math.pow(2,-Ee),Me=Math.floor(ge.image.width*Te),ft=Math.floor(ge.image.height*Te);dt.setTexture2D(ge,0),se.copyTexSubImage2D(se.TEXTURE_2D,Ee,0,0,W.x,W.y,Me,ft),De.unbindTexture()},this.copyTextureToTexture=function(W,ge,Ee,Te=0){const Me=ge.image.width,ft=ge.image.height,Rt=fn.convert(Ee.format),Dt=fn.convert(Ee.type);dt.setTexture2D(Ee,0),se.pixelStorei(se.UNPACK_FLIP_Y_WEBGL,Ee.flipY),se.pixelStorei(se.UNPACK_PREMULTIPLY_ALPHA_WEBGL,Ee.premultiplyAlpha),se.pixelStorei(se.UNPACK_ALIGNMENT,Ee.unpackAlignment),ge.isDataTexture?se.texSubImage2D(se.TEXTURE_2D,Te,W.x,W.y,Me,ft,Rt,Dt,ge.image.data):ge.isCompressedTexture?se.compressedTexSubImage2D(se.TEXTURE_2D,Te,W.x,W.y,ge.mipmaps[0].width,ge.mipmaps[0].height,Rt,ge.mipmaps[0].data):se.texSubImage2D(se.TEXTURE_2D,Te,W.x,W.y,Rt,Dt,ge.image),Te===0&&Ee.generateMipmaps&&se.generateMipmap(se.TEXTURE_2D),De.unbindTexture()},this.copyTextureToTexture3D=function(W,ge,Ee,Te,Me=0){if(A.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const ft=W.max.x-W.min.x+1,Rt=W.max.y-W.min.y+1,Dt=W.max.z-W.min.z+1,ht=fn.convert(Te.format),Wt=fn.convert(Te.type);let Bt;if(Te.isData3DTexture)dt.setTexture3D(Te,0),Bt=se.TEXTURE_3D;else if(Te.isDataArrayTexture)dt.setTexture2DArray(Te,0),Bt=se.TEXTURE_2D_ARRAY;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}se.pixelStorei(se.UNPACK_FLIP_Y_WEBGL,Te.flipY),se.pixelStorei(se.UNPACK_PREMULTIPLY_ALPHA_WEBGL,Te.premultiplyAlpha),se.pixelStorei(se.UNPACK_ALIGNMENT,Te.unpackAlignment);const $t=se.getParameter(se.UNPACK_ROW_LENGTH),In=se.getParameter(se.UNPACK_IMAGE_HEIGHT),kr=se.getParameter(se.UNPACK_SKIP_PIXELS),Pn=se.getParameter(se.UNPACK_SKIP_ROWS),sr=se.getParameter(se.UNPACK_SKIP_IMAGES),It=Ee.isCompressedTexture?Ee.mipmaps[0]:Ee.image;se.pixelStorei(se.UNPACK_ROW_LENGTH,It.width),se.pixelStorei(se.UNPACK_IMAGE_HEIGHT,It.height),se.pixelStorei(se.UNPACK_SKIP_PIXELS,W.min.x),se.pixelStorei(se.UNPACK_SKIP_ROWS,W.min.y),se.pixelStorei(se.UNPACK_SKIP_IMAGES,W.min.z),Ee.isDataTexture||Ee.isData3DTexture?se.texSubImage3D(Bt,Me,ge.x,ge.y,ge.z,ft,Rt,Dt,ht,Wt,It.data):Ee.isCompressedArrayTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),se.compressedTexSubImage3D(Bt,Me,ge.x,ge.y,ge.z,ft,Rt,Dt,ht,It.data)):se.texSubImage3D(Bt,Me,ge.x,ge.y,ge.z,ft,Rt,Dt,ht,Wt,It),se.pixelStorei(se.UNPACK_ROW_LENGTH,$t),se.pixelStorei(se.UNPACK_IMAGE_HEIGHT,In),se.pixelStorei(se.UNPACK_SKIP_PIXELS,kr),se.pixelStorei(se.UNPACK_SKIP_ROWS,Pn),se.pixelStorei(se.UNPACK_SKIP_IMAGES,sr),Me===0&&Te.generateMipmaps&&se.generateMipmap(Bt),De.unbindTexture()},this.initTexture=function(W){W.isCubeTexture?dt.setTextureCube(W,0):W.isData3DTexture?dt.setTexture3D(W,0):W.isDataArrayTexture||W.isCompressedArrayTexture?dt.setTexture2DArray(W,0):dt.setTexture2D(W,0),De.unbindTexture()},this.resetState=function(){F=0,U=0,V=null,De.reset(),ae.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return Qa}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(e){this._outputColorSpace=e;const t=this.getContext();t.drawingBufferColorSpace=e===T0?"display-p3":"srgb",t.unpackColorSpace=Nn.workingColorSpace===xm?"display-p3":"srgb"}get physicallyCorrectLights(){return console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),!this.useLegacyLights}set physicallyCorrectLights(e){console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),this.useLegacyLights=!e}get outputEncoding(){return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),this.outputColorSpace===Hr?cu:IS}set outputEncoding(e){console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),this.outputColorSpace=e===cu?Hr:ro}get useLegacyLights(){return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),this._useLegacyLights}set useLegacyLights(e){console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),this._useLegacyLights=e}}class oA extends BS{}oA.prototype.isWebGL1Renderer=!0;class C0{constructor(e,t=25e-5){this.isFogExp2=!0,this.name="",this.color=new yt(e),this.density=t}clone(){return new C0(this.color,this.density)}toJSON(){return{type:"FogExp2",name:this.name,color:this.color.getHex(),density:this.density}}}class R0{constructor(e,t=1,n=1e3){this.isFog=!0,this.name="",this.color=new yt(e),this.near=t,this.far=n}clone(){return new R0(this.color,this.near,this.far)}toJSON(){return{type:"Fog",name:this.name,color:this.color.getHex(),near:this.near,far:this.far}}}class VS extends Sn{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),this.backgroundBlurriness=e.backgroundBlurriness,this.backgroundIntensity=e.backgroundIntensity,e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(t.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(t.object.backgroundIntensity=this.backgroundIntensity),t}}class I0{constructor(e,t){this.isInterleavedBuffer=!0,this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=Xp,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=Ps()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,n){e*=this.stride,n*=t.stride;for(let i=0,s=this.stride;i<s;i++)this.array[e+i]=t.array[n+i];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Ps()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(t,this.stride);return n.setUsage(this.usage),n}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Ps()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const $i=new X;class Xc{constructor(e,t,n,i=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=e,this.itemSize=t,this.offset=n,this.normalized=i}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,n=this.data.count;t<n;t++)$i.fromBufferAttribute(this,t),$i.applyMatrix4(e),this.setXYZ(t,$i.x,$i.y,$i.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)$i.fromBufferAttribute(this,t),$i.applyNormalMatrix(e),this.setXYZ(t,$i.x,$i.y,$i.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)$i.fromBufferAttribute(this,t),$i.transformDirection(e),this.setXYZ(t,$i.x,$i.y,$i.z);return this}setX(e,t){return this.normalized&&(t=nn(t,this.array)),this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.normalized&&(t=nn(t,this.array)),this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.normalized&&(t=nn(t,this.array)),this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.normalized&&(t=nn(t,this.array)),this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){let t=this.data.array[e*this.data.stride+this.offset];return this.normalized&&(t=ds(t,this.array)),t}getY(e){let t=this.data.array[e*this.data.stride+this.offset+1];return this.normalized&&(t=ds(t,this.array)),t}getZ(e){let t=this.data.array[e*this.data.stride+this.offset+2];return this.normalized&&(t=ds(t,this.array)),t}getW(e){let t=this.data.array[e*this.data.stride+this.offset+3];return this.normalized&&(t=ds(t,this.array)),t}setXY(e,t,n){return e=e*this.data.stride+this.offset,this.normalized&&(t=nn(t,this.array),n=nn(n,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=n,this}setXYZ(e,t,n,i){return e=e*this.data.stride+this.offset,this.normalized&&(t=nn(t,this.array),n=nn(n,this.array),i=nn(i,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=i,this}setXYZW(e,t,n,i,s){return e=e*this.data.stride+this.offset,this.normalized&&(t=nn(t,this.array),n=nn(n,this.array),i=nn(i,this.array),s=nn(s,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=i,this.data.array[e+3]=s,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)t.push(this.data.array[i+s])}return new Hn(new this.array.constructor(t),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new Xc(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)t.push(this.data.array[i+s])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class HS extends Ri{constructor(e){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new yt(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}let Th;const pp=new X,Mh=new X,Ah=new X,Nh=new Pe,mp=new Pe,lA=new Jt,iy=new X,gp=new X,sy=new X,XE=new Pe,y_=new Pe,KE=new Pe;class uA extends Sn{constructor(e=new HS){if(super(),this.isSprite=!0,this.type="Sprite",Th===void 0){Th=new ln;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),n=new I0(t,5);Th.setIndex([0,1,2,0,2,3]),Th.setAttribute("position",new Xc(n,3,0,!1)),Th.setAttribute("uv",new Xc(n,2,3,!1))}this.geometry=Th,this.material=e,this.center=new Pe(.5,.5)}raycast(e,t){e.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Mh.setFromMatrixScale(this.matrixWorld),lA.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),Ah.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&Mh.multiplyScalar(-Ah.z);const n=this.material.rotation;let i,s;n!==0&&(s=Math.cos(n),i=Math.sin(n));const a=this.center;ay(iy.set(-.5,-.5,0),Ah,a,Mh,i,s),ay(gp.set(.5,-.5,0),Ah,a,Mh,i,s),ay(sy.set(.5,.5,0),Ah,a,Mh,i,s),XE.set(0,0),y_.set(1,0),KE.set(1,1);let o=e.ray.intersectTriangle(iy,gp,sy,!1,pp);if(o===null&&(ay(gp.set(-.5,.5,0),Ah,a,Mh,i,s),y_.set(0,1),o=e.ray.intersectTriangle(iy,sy,gp,!1,pp),o===null))return;const u=e.ray.origin.distanceTo(pp);u<e.near||u>e.far||t.push({distance:u,point:pp.clone(),uv:fs.getInterpolation(pp,iy,gp,sy,XE,y_,KE,new Pe),face:null,object:this})}copy(e,t){return super.copy(e,t),e.center!==void 0&&this.center.copy(e.center),this.material=e.material,this}}function ay(r,e,t,n,i,s){Nh.subVectors(r,t).addScalar(.5).multiply(n),i!==void 0?(mp.x=s*Nh.x-i*Nh.y,mp.y=i*Nh.x+s*Nh.y):mp.copy(Nh),r.copy(e),r.x+=mp.x,r.y+=mp.y,r.applyMatrix4(lA)}const oy=new X,YE=new X;class cA extends Sn{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(e){super.copy(e,!1);const t=e.levels;for(let n=0,i=t.length;n<i;n++){const s=t[n];this.addLevel(s.object.clone(),s.distance,s.hysteresis)}return this.autoUpdate=e.autoUpdate,this}addLevel(e,t=0,n=0){t=Math.abs(t);const i=this.levels;let s;for(s=0;s<i.length&&!(t<i[s].distance);s++);return i.splice(s,0,{distance:t,hysteresis:n,object:e}),this.add(e),this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(e){const t=this.levels;if(t.length>0){let n,i;for(n=1,i=t.length;n<i;n++){let s=t[n].distance;if(t[n].object.visible&&(s-=s*t[n].hysteresis),e<s)break}return t[n-1].object}return null}raycast(e,t){if(this.levels.length>0){oy.setFromMatrixPosition(this.matrixWorld);const i=e.ray.origin.distanceTo(oy);this.getObjectForDistance(i).raycast(e,t)}}update(e){const t=this.levels;if(t.length>1){oy.setFromMatrixPosition(e.matrixWorld),YE.setFromMatrixPosition(this.matrixWorld);const n=oy.distanceTo(YE)/e.zoom;t[0].object.visible=!0;let i,s;for(i=1,s=t.length;i<s;i++){let a=t[i].distance;if(t[i].object.visible&&(a-=a*t[i].hysteresis),n>=a)t[i-1].object.visible=!1,t[i].object.visible=!0;else break}for(this._currentLevel=i-1;i<s;i++)t[i].object.visible=!1}}toJSON(e){const t=super.toJSON(e);this.autoUpdate===!1&&(t.object.autoUpdate=!1),t.object.levels=[];const n=this.levels;for(let i=0,s=n.length;i<s;i++){const a=n[i];t.object.levels.push({object:a.object.uuid,distance:a.distance,hysteresis:a.hysteresis})}return t}}const ZE=new X,JE=new Cn,QE=new Cn,Ez=new X,eb=new Jt,ly=new X,v_=new Ia,tb=new Jt,__=new sf;class fA extends hi{constructor(e,t){super(e,t),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=rx,this.bindMatrix=new Jt,this.bindMatrixInverse=new Jt,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const e=this.geometry;this.boundingBox===null&&(this.boundingBox=new co),this.boundingBox.makeEmpty();const t=e.getAttribute("position");for(let n=0;n<t.count;n++)this.getVertexPosition(n,ly),this.boundingBox.expandByPoint(ly)}computeBoundingSphere(){const e=this.geometry;this.boundingSphere===null&&(this.boundingSphere=new Ia),this.boundingSphere.makeEmpty();const t=e.getAttribute("position");for(let n=0;n<t.count;n++)this.getVertexPosition(n,ly),this.boundingSphere.expandByPoint(ly)}copy(e,t){return super.copy(e,t),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}raycast(e,t){const n=this.material,i=this.matrixWorld;n!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),v_.copy(this.boundingSphere),v_.applyMatrix4(i),e.ray.intersectsSphere(v_)!==!1&&(tb.copy(i).invert(),__.copy(e.ray).applyMatrix4(tb),!(this.boundingBox!==null&&__.intersectsBox(this.boundingBox)===!1)&&this._computeIntersections(e,t,__)))}getVertexPosition(e,t){return super.getVertexPosition(e,t),this.applyBoneTransform(e,t),t}bind(e,t){this.skeleton=e,t===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new Cn,t=this.geometry.attributes.skinWeight;for(let n=0,i=t.count;n<i;n++){e.fromBufferAttribute(t,n);const s=1/e.manhattanLength();s!==1/0?e.multiplyScalar(s):e.set(1,0,0,0),t.setXYZW(n,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode===rx?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===xM?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(e,t){const n=this.skeleton,i=this.geometry;JE.fromBufferAttribute(i.attributes.skinIndex,e),QE.fromBufferAttribute(i.attributes.skinWeight,e),ZE.copy(t).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let s=0;s<4;s++){const a=QE.getComponent(s);if(a!==0){const o=JE.getComponent(s);eb.multiplyMatrices(n.bones[o].matrixWorld,n.boneInverses[o]),t.addScaledVector(Ez.copy(ZE).applyMatrix4(eb),a)}}return t.applyMatrix4(this.bindMatrixInverse)}boneTransform(e,t){return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."),this.applyBoneTransform(e,t)}}class $S extends Sn{constructor(){super(),this.isBone=!0,this.type="Bone"}}class Hh extends br{constructor(e=null,t=1,n=1,i,s,a,o,u,h=Sr,p=Sr,m,y){super(null,a,o,u,h,p,i,s,m,y),this.isDataTexture=!0,this.image={data:e,width:t,height:n},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const nb=new Jt,bz=new Jt;class P0{constructor(e=[],t=[]){this.uuid=Ps(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.init()}init(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(e.length*16),t.length===0)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let n=0,i=this.bones.length;n<i;n++)this.boneInverses.push(new Jt)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const n=new Jt;this.bones[e]&&n.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(n)}}pose(){for(let e=0,t=this.bones.length;e<t;e++){const n=this.bones[e];n&&n.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const n=this.bones[e];n&&(n.parent&&n.parent.isBone?(n.matrix.copy(n.parent.matrixWorld).invert(),n.matrix.multiply(n.matrixWorld)):n.matrix.copy(n.matrixWorld),n.matrix.decompose(n.position,n.quaternion,n.scale))}}update(){const e=this.bones,t=this.boneInverses,n=this.boneMatrices,i=this.boneTexture;for(let s=0,a=e.length;s<a;s++){const o=e[s]?e[s].matrixWorld:bz;nb.multiplyMatrices(o,t[s]),nb.toArray(n,s*16)}i!==null&&(i.needsUpdate=!0)}clone(){return new P0(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(this.bones.length*4);e=GM(e),e=Math.max(e,4);const t=new Float32Array(e*e*4);t.set(this.boneMatrices);const n=new Hh(t,e,e,hs,Ja);return n.needsUpdate=!0,this.boneMatrices=t,this.boneTexture=n,this.boneTextureSize=e,this}getBoneByName(e){for(let t=0,n=this.bones.length;t<n;t++){const i=this.bones[t];if(i.name===e)return i}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,t){this.uuid=e.uuid;for(let n=0,i=e.bones.length;n<i;n++){const s=e.bones[n];let a=t[s];a===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",s),a=new $S),this.bones.push(a),this.boneInverses.push(new Jt().fromArray(e.boneInverses[n]))}return this.init(),this}toJSON(){const e={metadata:{version:4.6,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,n=this.boneInverses;for(let i=0,s=t.length;i<s;i++){const a=t[i];e.bones.push(a.uuid);const o=n[i];e.boneInverses.push(o.toArray())}return e}}class Yh extends Hn{constructor(e,t,n,i=1){super(e,t,n),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=i}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}const Ch=new Jt,rb=new Jt,uy=[],ib=new co,Tz=new Jt,yp=new hi,vp=new Ia;class hA extends hi{constructor(e,t,n){super(e,t),this.isInstancedMesh=!0,this.instanceMatrix=new Yh(new Float32Array(n*16),16),this.instanceColor=null,this.count=n,this.boundingBox=null,this.boundingSphere=null;for(let i=0;i<n;i++)this.setMatrixAt(i,Tz)}computeBoundingBox(){const e=this.geometry,t=this.count;this.boundingBox===null&&(this.boundingBox=new co),e.boundingBox===null&&e.computeBoundingBox(),this.boundingBox.makeEmpty();for(let n=0;n<t;n++)this.getMatrixAt(n,Ch),ib.copy(e.boundingBox).applyMatrix4(Ch),this.boundingBox.union(ib)}computeBoundingSphere(){const e=this.geometry,t=this.count;this.boundingSphere===null&&(this.boundingSphere=new Ia),e.boundingSphere===null&&e.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let n=0;n<t;n++)this.getMatrixAt(n,Ch),vp.copy(e.boundingSphere).applyMatrix4(Ch),this.boundingSphere.union(vp)}copy(e,t){return super.copy(e,t),this.instanceMatrix.copy(e.instanceMatrix),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}getColorAt(e,t){t.fromArray(this.instanceColor.array,e*3)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,e*16)}raycast(e,t){const n=this.matrixWorld,i=this.count;if(yp.geometry=this.geometry,yp.material=this.material,yp.material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),vp.copy(this.boundingSphere),vp.applyMatrix4(n),e.ray.intersectsSphere(vp)!==!1))for(let s=0;s<i;s++){this.getMatrixAt(s,Ch),rb.multiplyMatrices(n,Ch),yp.matrixWorld=rb,yp.raycast(e,uy);for(let a=0,o=uy.length;a<o;a++){const u=uy[a];u.instanceId=s,u.object=this,t.push(u)}uy.length=0}}setColorAt(e,t){this.instanceColor===null&&(this.instanceColor=new Yh(new Float32Array(this.instanceMatrix.count*3),3)),t.toArray(this.instanceColor.array,e*3)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,e*16)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}class qi extends Ri{constructor(e){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new yt(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}}const sb=new X,ab=new X,ob=new Jt,x_=new sf,cy=new Ia;class mu extends Sn{constructor(e=new ln,t=new qi){super(),this.isLine=!0,this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,n=[0];for(let i=1,s=t.count;i<s;i++)sb.fromBufferAttribute(t,i-1),ab.fromBufferAttribute(t,i),n[i]=n[i-1],n[i]+=sb.distanceTo(ab);e.setAttribute("lineDistance",new At(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(e,t){const n=this.geometry,i=this.matrixWorld,s=e.params.Line.threshold,a=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),cy.copy(n.boundingSphere),cy.applyMatrix4(i),cy.radius+=s,e.ray.intersectsSphere(cy)===!1)return;ob.copy(i).invert(),x_.copy(e.ray).applyMatrix4(ob);const o=s/((this.scale.x+this.scale.y+this.scale.z)/3),u=o*o,h=new X,p=new X,m=new X,y=new X,v=this.isLineSegments?2:1,S=n.index,E=n.attributes.position;if(S!==null){const w=Math.max(0,a.start),C=Math.min(S.count,a.start+a.count);for(let A=w,I=C-1;A<I;A+=v){const F=S.getX(A),U=S.getX(A+1);if(h.fromBufferAttribute(E,F),p.fromBufferAttribute(E,U),x_.distanceSqToSegment(h,p,y,m)>u)continue;y.applyMatrix4(this.matrixWorld);const G=e.ray.origin.distanceTo(y);G<e.near||G>e.far||t.push({distance:G,point:m.clone().applyMatrix4(this.matrixWorld),index:A,face:null,faceIndex:null,object:this})}}else{const w=Math.max(0,a.start),C=Math.min(E.count,a.start+a.count);for(let A=w,I=C-1;A<I;A+=v){if(h.fromBufferAttribute(E,A),p.fromBufferAttribute(E,A+1),x_.distanceSqToSegment(h,p,y,m)>u)continue;y.applyMatrix4(this.matrixWorld);const U=e.ray.origin.distanceTo(y);U<e.near||U>e.far||t.push({distance:U,point:m.clone().applyMatrix4(this.matrixWorld),index:A,face:null,faceIndex:null,object:this})}}}updateMorphTargets(){const t=this.geometry.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,a=i.length;s<a;s++){const o=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=s}}}}}const lb=new X,ub=new X;class fo extends mu{constructor(e,t){super(e,t),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,n=[];for(let i=0,s=t.count;i<s;i+=2)lb.fromBufferAttribute(t,i),ub.fromBufferAttribute(t,i+1),n[i]=i===0?0:n[i-1],n[i+1]=n[i]+lb.distanceTo(ub);e.setAttribute("lineDistance",new At(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class dA extends mu{constructor(e,t){super(e,t),this.isLineLoop=!0,this.type="LineLoop"}}class GS extends Ri{constructor(e){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new yt(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}const cb=new Jt,kx=new sf,fy=new Ia,hy=new X;class pA extends Sn{constructor(e=new ln,t=new GS){super(),this.isPoints=!0,this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}raycast(e,t){const n=this.geometry,i=this.matrixWorld,s=e.params.Points.threshold,a=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),fy.copy(n.boundingSphere),fy.applyMatrix4(i),fy.radius+=s,e.ray.intersectsSphere(fy)===!1)return;cb.copy(i).invert(),kx.copy(e.ray).applyMatrix4(cb);const o=s/((this.scale.x+this.scale.y+this.scale.z)/3),u=o*o,h=n.index,m=n.attributes.position;if(h!==null){const y=Math.max(0,a.start),v=Math.min(h.count,a.start+a.count);for(let S=y,T=v;S<T;S++){const E=h.getX(S);hy.fromBufferAttribute(m,E),fb(hy,E,u,i,e,t,this)}}else{const y=Math.max(0,a.start),v=Math.min(m.count,a.start+a.count);for(let S=y,T=v;S<T;S++)hy.fromBufferAttribute(m,S),fb(hy,S,u,i,e,t,this)}}updateMorphTargets(){const t=this.geometry.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,a=i.length;s<a;s++){const o=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=s}}}}}function fb(r,e,t,n,i,s,a){const o=kx.distanceSqToPoint(r);if(o<t){const u=new X;kx.closestPointToPoint(r,u),u.applyMatrix4(n);const h=i.ray.origin.distanceTo(u);if(h<i.near||h>i.far)return;s.push({distance:h,distanceToRay:Math.sqrt(o),point:u,index:e,face:null,object:a})}}class Mz extends br{constructor(e,t,n,i,s,a,o,u,h){super(e,t,n,i,s,a,o,u,h),this.isVideoTexture=!0,this.minFilter=a!==void 0?a:wr,this.magFilter=s!==void 0?s:wr,this.generateMipmaps=!1;const p=this;function m(){p.needsUpdate=!0,e.requestVideoFrameCallback(m)}"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(m)}clone(){return new this.constructor(this.image).copy(this)}update(){const e=this.image;"requestVideoFrameCallback"in e===!1&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}class Az extends br{constructor(e,t){super({width:e,height:t}),this.isFramebufferTexture=!0,this.magFilter=Sr,this.minFilter=Sr,this.generateMipmaps=!1,this.needsUpdate=!0}}class L0 extends br{constructor(e,t,n,i,s,a,o,u,h,p,m,y){super(null,a,o,u,h,p,i,s,m,y),this.isCompressedTexture=!0,this.image={width:t,height:n},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}}class Nz extends L0{constructor(e,t,n,i,s,a){super(e,t,n,s,a),this.isCompressedArrayTexture=!0,this.image.depth=i,this.wrapR=Mi}}class Cz extends L0{constructor(e,t,n){super(void 0,e[0].width,e[0].height,t,n,ul),this.isCompressedCubeTexture=!0,this.isCubeTexture=!0,this.image=e}}class Rz extends br{constructor(e,t,n,i,s,a,o,u,h){super(e,t,n,i,s,a,o,u,h),this.isCanvasTexture=!0,this.needsUpdate=!0}}class Pa{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(e,t){const n=this.getUtoTmapping(e);return this.getPoint(n,t)}getPoints(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return t}getSpacedPoints(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPointAt(n/e));return t}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let n,i=this.getPoint(0),s=0;t.push(0);for(let a=1;a<=e;a++)n=this.getPoint(a/e),s+=n.distanceTo(i),t.push(s),i=n;return this.cacheArcLengths=t,t}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,t){const n=this.getLengths();let i=0;const s=n.length;let a;t?a=t:a=e*n[s-1];let o=0,u=s-1,h;for(;o<=u;)if(i=Math.floor(o+(u-o)/2),h=n[i]-a,h<0)o=i+1;else if(h>0)u=i-1;else{u=i;break}if(i=u,n[i]===a)return i/(s-1);const p=n[i],y=n[i+1]-p,v=(a-p)/y;return(i+v)/(s-1)}getTangent(e,t){let i=e-1e-4,s=e+1e-4;i<0&&(i=0),s>1&&(s=1);const a=this.getPoint(i),o=this.getPoint(s),u=t||(a.isVector2?new Pe:new X);return u.copy(o).sub(a).normalize(),u}getTangentAt(e,t){const n=this.getUtoTmapping(e);return this.getTangent(n,t)}computeFrenetFrames(e,t){const n=new X,i=[],s=[],a=[],o=new X,u=new Jt;for(let v=0;v<=e;v++){const S=v/e;i[v]=this.getTangentAt(S,new X)}s[0]=new X,a[0]=new X;let h=Number.MAX_VALUE;const p=Math.abs(i[0].x),m=Math.abs(i[0].y),y=Math.abs(i[0].z);p<=h&&(h=p,n.set(1,0,0)),m<=h&&(h=m,n.set(0,1,0)),y<=h&&n.set(0,0,1),o.crossVectors(i[0],n).normalize(),s[0].crossVectors(i[0],o),a[0].crossVectors(i[0],s[0]);for(let v=1;v<=e;v++){if(s[v]=s[v-1].clone(),a[v]=a[v-1].clone(),o.crossVectors(i[v-1],i[v]),o.length()>Number.EPSILON){o.normalize();const S=Math.acos(mr(i[v-1].dot(i[v]),-1,1));s[v].applyMatrix4(u.makeRotationAxis(o,S))}a[v].crossVectors(i[v],s[v])}if(t===!0){let v=Math.acos(mr(s[0].dot(s[e]),-1,1));v/=e,i[0].dot(o.crossVectors(s[0],s[e]))>0&&(v=-v);for(let S=1;S<=e;S++)s[S].applyMatrix4(u.makeRotationAxis(i[S],v*S)),a[S].crossVectors(i[S],s[S])}return{tangents:i,normals:s,binormals:a}}clone(){return new this.constructor().copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){const e={metadata:{version:4.6,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class k0 extends Pa{constructor(e=0,t=0,n=1,i=1,s=0,a=Math.PI*2,o=!1,u=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=e,this.aY=t,this.xRadius=n,this.yRadius=i,this.aStartAngle=s,this.aEndAngle=a,this.aClockwise=o,this.aRotation=u}getPoint(e,t){const n=t||new Pe,i=Math.PI*2;let s=this.aEndAngle-this.aStartAngle;const a=Math.abs(s)<Number.EPSILON;for(;s<0;)s+=i;for(;s>i;)s-=i;s<Number.EPSILON&&(a?s=0:s=i),this.aClockwise===!0&&!a&&(s===i?s=-i:s=s-i);const o=this.aStartAngle+e*s;let u=this.aX+this.xRadius*Math.cos(o),h=this.aY+this.yRadius*Math.sin(o);if(this.aRotation!==0){const p=Math.cos(this.aRotation),m=Math.sin(this.aRotation),y=u-this.aX,v=h-this.aY;u=y*p-v*m+this.aX,h=y*m+v*p+this.aY}return n.set(u,h)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){const e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}class mA extends k0{constructor(e,t,n,i,s,a){super(e,t,n,n,i,s,a),this.isArcCurve=!0,this.type="ArcCurve"}}function WS(){let r=0,e=0,t=0,n=0;function i(s,a,o,u){r=s,e=o,t=-3*s+3*a-2*o-u,n=2*s-2*a+o+u}return{initCatmullRom:function(s,a,o,u,h){i(a,o,h*(o-s),h*(u-a))},initNonuniformCatmullRom:function(s,a,o,u,h,p,m){let y=(a-s)/h-(o-s)/(h+p)+(o-a)/p,v=(o-a)/p-(u-a)/(p+m)+(u-o)/m;y*=p,v*=p,i(a,o,y,v)},calc:function(s){const a=s*s,o=a*s;return r+e*s+t*a+n*o}}}const dy=new X,S_=new WS,w_=new WS,E_=new WS;class gA extends Pa{constructor(e=[],t=!1,n="centripetal",i=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=n,this.tension=i}getPoint(e,t=new X){const n=t,i=this.points,s=i.length,a=(s-(this.closed?0:1))*e;let o=Math.floor(a),u=a-o;this.closed?o+=o>0?0:(Math.floor(Math.abs(o)/s)+1)*s:u===0&&o===s-1&&(o=s-2,u=1);let h,p;this.closed||o>0?h=i[(o-1)%s]:(dy.subVectors(i[0],i[1]).add(i[0]),h=dy);const m=i[o%s],y=i[(o+1)%s];if(this.closed||o+2<s?p=i[(o+2)%s]:(dy.subVectors(i[s-1],i[s-2]).add(i[s-1]),p=dy),this.curveType==="centripetal"||this.curveType==="chordal"){const v=this.curveType==="chordal"?.5:.25;let S=Math.pow(h.distanceToSquared(m),v),T=Math.pow(m.distanceToSquared(y),v),E=Math.pow(y.distanceToSquared(p),v);T<1e-4&&(T=1),S<1e-4&&(S=T),E<1e-4&&(E=T),S_.initNonuniformCatmullRom(h.x,m.x,y.x,p.x,S,T,E),w_.initNonuniformCatmullRom(h.y,m.y,y.y,p.y,S,T,E),E_.initNonuniformCatmullRom(h.z,m.z,y.z,p.z,S,T,E)}else this.curveType==="catmullrom"&&(S_.initCatmullRom(h.x,m.x,y.x,p.x,this.tension),w_.initCatmullRom(h.y,m.y,y.y,p.y,this.tension),E_.initCatmullRom(h.z,m.z,y.z,p.z,this.tension));return n.set(S_.calc(u),w_.calc(u),E_.calc(u)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(i.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const i=this.points[t];e.points.push(i.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(new X().fromArray(i))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}function hb(r,e,t,n,i){const s=(n-e)*.5,a=(i-t)*.5,o=r*r,u=r*o;return(2*t-2*n+s+a)*u+(-3*t+3*n-2*s-a)*o+s*r+t}function Iz(r,e){const t=1-r;return t*t*e}function Pz(r,e){return 2*(1-r)*r*e}function Lz(r,e){return r*r*e}function Lp(r,e,t,n){return Iz(r,e)+Pz(r,t)+Lz(r,n)}function kz(r,e){const t=1-r;return t*t*t*e}function Dz(r,e){const t=1-r;return 3*t*t*r*e}function Oz(r,e){return 3*(1-r)*r*r*e}function Fz(r,e){return r*r*r*e}function kp(r,e,t,n,i){return kz(r,e)+Dz(r,t)+Oz(r,n)+Fz(r,i)}class jS extends Pa{constructor(e=new Pe,t=new Pe,n=new Pe,i=new Pe){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=n,this.v3=i}getPoint(e,t=new Pe){const n=t,i=this.v0,s=this.v1,a=this.v2,o=this.v3;return n.set(kp(e,i.x,s.x,a.x,o.x),kp(e,i.y,s.y,a.y,o.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class yA extends Pa{constructor(e=new X,t=new X,n=new X,i=new X){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=n,this.v3=i}getPoint(e,t=new X){const n=t,i=this.v0,s=this.v1,a=this.v2,o=this.v3;return n.set(kp(e,i.x,s.x,a.x,o.x),kp(e,i.y,s.y,a.y,o.y),kp(e,i.z,s.z,a.z,o.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class qS extends Pa{constructor(e=new Pe,t=new Pe){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=e,this.v2=t}getPoint(e,t=new Pe){const n=t;return e===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t=new Pe){return t.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,t){return this.getTangent(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class vA extends Pa{constructor(e=new X,t=new X){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=e,this.v2=t}getPoint(e,t=new X){const n=t;return e===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t=new X){return t.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,t){return this.getTangent(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class XS extends Pa{constructor(e=new Pe,t=new Pe,n=new Pe){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new Pe){const n=t,i=this.v0,s=this.v1,a=this.v2;return n.set(Lp(e,i.x,s.x,a.x),Lp(e,i.y,s.y,a.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class KS extends Pa{constructor(e=new X,t=new X,n=new X){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new X){const n=t,i=this.v0,s=this.v1,a=this.v2;return n.set(Lp(e,i.x,s.x,a.x),Lp(e,i.y,s.y,a.y),Lp(e,i.z,s.z,a.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class YS extends Pa{constructor(e=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=e}getPoint(e,t=new Pe){const n=t,i=this.points,s=(i.length-1)*e,a=Math.floor(s),o=s-a,u=i[a===0?a:a-1],h=i[a],p=i[a>i.length-2?i.length-1:a+1],m=i[a>i.length-3?i.length-1:a+2];return n.set(hb(o,u.x,h.x,p.x,m.x),hb(o,u.y,h.y,p.y,m.y)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(i.clone())}return this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const i=this.points[t];e.points.push(i.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(new Pe().fromArray(i))}return this}}var n0=Object.freeze({__proto__:null,ArcCurve:mA,CatmullRomCurve3:gA,CubicBezierCurve:jS,CubicBezierCurve3:yA,EllipseCurve:k0,LineCurve:qS,LineCurve3:vA,QuadraticBezierCurve:XS,QuadraticBezierCurve3:KS,SplineCurve:YS});class _A extends Pa{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);if(!e.equals(t)){const n=e.isVector2===!0?"LineCurve":"LineCurve3";this.curves.push(new n0[n](t,e))}return this}getPoint(e,t){const n=e*this.getLength(),i=this.getCurveLengths();let s=0;for(;s<i.length;){if(i[s]>=n){const a=i[s]-n,o=this.curves[s],u=o.getLength(),h=u===0?0:1-a/u;return o.getPointAt(h,t)}s++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let n=0,i=this.curves.length;n<i;n++)t+=this.curves[n].getLength(),e.push(t);return this.cacheLengths=e,e}getSpacedPoints(e=40){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return this.autoClose&&t.push(t[0]),t}getPoints(e=12){const t=[];let n;for(let i=0,s=this.curves;i<s.length;i++){const a=s[i],o=a.isEllipseCurve?e*2:a.isLineCurve||a.isLineCurve3?1:a.isSplineCurve?e*a.points.length:e,u=a.getPoints(o);for(let h=0;h<u.length;h++){const p=u[h];n&&n.equals(p)||(t.push(p),n=p)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t}copy(e){super.copy(e),this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const i=e.curves[t];this.curves.push(i.clone())}return this.autoClose=e.autoClose,this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let t=0,n=this.curves.length;t<n;t++){const i=this.curves[t];e.curves.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const i=e.curves[t];this.curves.push(new n0[i.type]().fromJSON(i))}return this}}class Zp extends _A{constructor(e){super(),this.type="Path",this.currentPoint=new Pe,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let t=1,n=e.length;t<n;t++)this.lineTo(e[t].x,e[t].y);return this}moveTo(e,t){return this.currentPoint.set(e,t),this}lineTo(e,t){const n=new qS(this.currentPoint.clone(),new Pe(e,t));return this.curves.push(n),this.currentPoint.set(e,t),this}quadraticCurveTo(e,t,n,i){const s=new XS(this.currentPoint.clone(),new Pe(e,t),new Pe(n,i));return this.curves.push(s),this.currentPoint.set(n,i),this}bezierCurveTo(e,t,n,i,s,a){const o=new jS(this.currentPoint.clone(),new Pe(e,t),new Pe(n,i),new Pe(s,a));return this.curves.push(o),this.currentPoint.set(s,a),this}splineThru(e){const t=[this.currentPoint.clone()].concat(e),n=new YS(t);return this.curves.push(n),this.currentPoint.copy(e[e.length-1]),this}arc(e,t,n,i,s,a){const o=this.currentPoint.x,u=this.currentPoint.y;return this.absarc(e+o,t+u,n,i,s,a),this}absarc(e,t,n,i,s,a){return this.absellipse(e,t,n,n,i,s,a),this}ellipse(e,t,n,i,s,a,o,u){const h=this.currentPoint.x,p=this.currentPoint.y;return this.absellipse(e+h,t+p,n,i,s,a,o,u),this}absellipse(e,t,n,i,s,a,o,u){const h=new k0(e,t,n,i,s,a,o,u);if(this.curves.length>0){const m=h.getPoint(0);m.equals(this.currentPoint)||this.lineTo(m.x,m.y)}this.curves.push(h);const p=h.getPoint(1);return this.currentPoint.copy(p),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class Tm extends ln{constructor(e=[new Pe(0,-.5),new Pe(.5,0),new Pe(0,.5)],t=12,n=0,i=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points:e,segments:t,phiStart:n,phiLength:i},t=Math.floor(t),i=mr(i,0,Math.PI*2);const s=[],a=[],o=[],u=[],h=[],p=1/t,m=new X,y=new Pe,v=new X,S=new X,T=new X;let E=0,w=0;for(let C=0;C<=e.length-1;C++)switch(C){case 0:E=e[C+1].x-e[C].x,w=e[C+1].y-e[C].y,v.x=w*1,v.y=-E,v.z=w*0,T.copy(v),v.normalize(),u.push(v.x,v.y,v.z);break;case e.length-1:u.push(T.x,T.y,T.z);break;default:E=e[C+1].x-e[C].x,w=e[C+1].y-e[C].y,v.x=w*1,v.y=-E,v.z=w*0,S.copy(v),v.x+=T.x,v.y+=T.y,v.z+=T.z,v.normalize(),u.push(v.x,v.y,v.z),T.copy(S)}for(let C=0;C<=t;C++){const A=n+C*p*i,I=Math.sin(A),F=Math.cos(A);for(let U=0;U<=e.length-1;U++){m.x=e[U].x*I,m.y=e[U].y,m.z=e[U].x*F,a.push(m.x,m.y,m.z),y.x=C/t,y.y=U/(e.length-1),o.push(y.x,y.y);const V=u[3*U+0]*I,G=u[3*U+1],L=u[3*U+0]*F;h.push(V,G,L)}}for(let C=0;C<t;C++)for(let A=0;A<e.length-1;A++){const I=A+C*e.length,F=I,U=I+e.length,V=I+e.length+1,G=I+1;s.push(F,U,G),s.push(V,G,U)}this.setIndex(s),this.setAttribute("position",new At(a,3)),this.setAttribute("uv",new At(o,2)),this.setAttribute("normal",new At(h,3))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Tm(e.points,e.segments,e.phiStart,e.phiLength)}}class D0 extends Tm{constructor(e=1,t=1,n=4,i=8){const s=new Zp;s.absarc(0,-t/2,e,Math.PI*1.5,0),s.absarc(0,t/2,e,0,Math.PI*.5),super(s.getPoints(n),i),this.type="CapsuleGeometry",this.parameters={radius:e,length:t,capSegments:n,radialSegments:i}}static fromJSON(e){return new D0(e.radius,e.length,e.capSegments,e.radialSegments)}}class O0 extends ln{constructor(e=1,t=32,n=0,i=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:t,thetaStart:n,thetaLength:i},t=Math.max(3,t);const s=[],a=[],o=[],u=[],h=new X,p=new Pe;a.push(0,0,0),o.push(0,0,1),u.push(.5,.5);for(let m=0,y=3;m<=t;m++,y+=3){const v=n+m/t*i;h.x=e*Math.cos(v),h.y=e*Math.sin(v),a.push(h.x,h.y,h.z),o.push(0,0,1),p.x=(a[y]/e+1)/2,p.y=(a[y+1]/e+1)/2,u.push(p.x,p.y)}for(let m=1;m<=t;m++)s.push(m,m+1,0);this.setIndex(s),this.setAttribute("position",new At(a,3)),this.setAttribute("normal",new At(o,3)),this.setAttribute("uv",new At(u,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new O0(e.radius,e.segments,e.thetaStart,e.thetaLength)}}class ld extends ln{constructor(e=1,t=1,n=1,i=32,s=1,a=!1,o=0,u=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:n,radialSegments:i,heightSegments:s,openEnded:a,thetaStart:o,thetaLength:u};const h=this;i=Math.floor(i),s=Math.floor(s);const p=[],m=[],y=[],v=[];let S=0;const T=[],E=n/2;let w=0;C(),a===!1&&(e>0&&A(!0),t>0&&A(!1)),this.setIndex(p),this.setAttribute("position",new At(m,3)),this.setAttribute("normal",new At(y,3)),this.setAttribute("uv",new At(v,2));function C(){const I=new X,F=new X;let U=0;const V=(t-e)/n;for(let G=0;G<=s;G++){const L=[],k=G/s,O=k*(t-e)+e;for(let Q=0;Q<=i;Q++){const le=Q/i,K=le*u+o,ce=Math.sin(K),de=Math.cos(K);F.x=O*ce,F.y=-k*n+E,F.z=O*de,m.push(F.x,F.y,F.z),I.set(ce,V,de).normalize(),y.push(I.x,I.y,I.z),v.push(le,1-k),L.push(S++)}T.push(L)}for(let G=0;G<i;G++)for(let L=0;L<s;L++){const k=T[L][G],O=T[L+1][G],Q=T[L+1][G+1],le=T[L][G+1];p.push(k,O,le),p.push(O,Q,le),U+=6}h.addGroup(w,U,0),w+=U}function A(I){const F=S,U=new Pe,V=new X;let G=0;const L=I===!0?e:t,k=I===!0?1:-1;for(let Q=1;Q<=i;Q++)m.push(0,E*k,0),y.push(0,k,0),v.push(.5,.5),S++;const O=S;for(let Q=0;Q<=i;Q++){const K=Q/i*u+o,ce=Math.cos(K),de=Math.sin(K);V.x=L*de,V.y=E*k,V.z=L*ce,m.push(V.x,V.y,V.z),y.push(0,k,0),U.x=ce*.5+.5,U.y=de*.5*k+.5,v.push(U.x,U.y),S++}for(let Q=0;Q<i;Q++){const le=F+Q,K=O+Q;I===!0?p.push(K,K+1,le):p.push(K+1,K,le),G+=3}h.addGroup(w,G,I===!0?1:2),w+=G}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new ld(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class F0 extends ld{constructor(e=1,t=1,n=32,i=1,s=!1,a=0,o=Math.PI*2){super(0,e,t,n,i,s,a,o),this.type="ConeGeometry",this.parameters={radius:e,height:t,radialSegments:n,heightSegments:i,openEnded:s,thetaStart:a,thetaLength:o}}static fromJSON(e){return new F0(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class bu extends ln{constructor(e=[],t=[],n=1,i=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:t,radius:n,detail:i};const s=[],a=[];o(i),h(n),p(),this.setAttribute("position",new At(s,3)),this.setAttribute("normal",new At(s.slice(),3)),this.setAttribute("uv",new At(a,2)),i===0?this.computeVertexNormals():this.normalizeNormals();function o(C){const A=new X,I=new X,F=new X;for(let U=0;U<t.length;U+=3)v(t[U+0],A),v(t[U+1],I),v(t[U+2],F),u(A,I,F,C)}function u(C,A,I,F){const U=F+1,V=[];for(let G=0;G<=U;G++){V[G]=[];const L=C.clone().lerp(I,G/U),k=A.clone().lerp(I,G/U),O=U-G;for(let Q=0;Q<=O;Q++)Q===0&&G===U?V[G][Q]=L:V[G][Q]=L.clone().lerp(k,Q/O)}for(let G=0;G<U;G++)for(let L=0;L<2*(U-G)-1;L++){const k=Math.floor(L/2);L%2===0?(y(V[G][k+1]),y(V[G+1][k]),y(V[G][k])):(y(V[G][k+1]),y(V[G+1][k+1]),y(V[G+1][k]))}}function h(C){const A=new X;for(let I=0;I<s.length;I+=3)A.x=s[I+0],A.y=s[I+1],A.z=s[I+2],A.normalize().multiplyScalar(C),s[I+0]=A.x,s[I+1]=A.y,s[I+2]=A.z}function p(){const C=new X;for(let A=0;A<s.length;A+=3){C.x=s[A+0],C.y=s[A+1],C.z=s[A+2];const I=E(C)/2/Math.PI+.5,F=w(C)/Math.PI+.5;a.push(I,1-F)}S(),m()}function m(){for(let C=0;C<a.length;C+=6){const A=a[C+0],I=a[C+2],F=a[C+4],U=Math.max(A,I,F),V=Math.min(A,I,F);U>.9&&V<.1&&(A<.2&&(a[C+0]+=1),I<.2&&(a[C+2]+=1),F<.2&&(a[C+4]+=1))}}function y(C){s.push(C.x,C.y,C.z)}function v(C,A){const I=C*3;A.x=e[I+0],A.y=e[I+1],A.z=e[I+2]}function S(){const C=new X,A=new X,I=new X,F=new X,U=new Pe,V=new Pe,G=new Pe;for(let L=0,k=0;L<s.length;L+=9,k+=6){C.set(s[L+0],s[L+1],s[L+2]),A.set(s[L+3],s[L+4],s[L+5]),I.set(s[L+6],s[L+7],s[L+8]),U.set(a[k+0],a[k+1]),V.set(a[k+2],a[k+3]),G.set(a[k+4],a[k+5]),F.copy(C).add(A).add(I).divideScalar(3);const O=E(F);T(U,k+0,C,O),T(V,k+2,A,O),T(G,k+4,I,O)}}function T(C,A,I,F){F<0&&C.x===1&&(a[A]=C.x-1),I.x===0&&I.z===0&&(a[A]=F/2/Math.PI+.5)}function E(C){return Math.atan2(C.z,-C.x)}function w(C){return Math.atan2(-C.y,Math.sqrt(C.x*C.x+C.z*C.z))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new bu(e.vertices,e.indices,e.radius,e.details)}}class U0 extends bu{constructor(e=1,t=0){const n=(1+Math.sqrt(5))/2,i=1/n,s=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-i,-n,0,-i,n,0,i,-n,0,i,n,-i,-n,0,-i,n,0,i,-n,0,i,n,0,-n,0,-i,n,0,-i,-n,0,i,n,0,i],a=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(s,a,e,t),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new U0(e.radius,e.detail)}}const py=new X,my=new X,b_=new X,gy=new fs;class xA extends ln{constructor(e=null,t=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:e,thresholdAngle:t},e!==null){const i=Math.pow(10,4),s=Math.cos(Vc*t),a=e.getIndex(),o=e.getAttribute("position"),u=a?a.count:o.count,h=[0,0,0],p=["a","b","c"],m=new Array(3),y={},v=[];for(let S=0;S<u;S+=3){a?(h[0]=a.getX(S),h[1]=a.getX(S+1),h[2]=a.getX(S+2)):(h[0]=S,h[1]=S+1,h[2]=S+2);const{a:T,b:E,c:w}=gy;if(T.fromBufferAttribute(o,h[0]),E.fromBufferAttribute(o,h[1]),w.fromBufferAttribute(o,h[2]),gy.getNormal(b_),m[0]=`${Math.round(T.x*i)},${Math.round(T.y*i)},${Math.round(T.z*i)}`,m[1]=`${Math.round(E.x*i)},${Math.round(E.y*i)},${Math.round(E.z*i)}`,m[2]=`${Math.round(w.x*i)},${Math.round(w.y*i)},${Math.round(w.z*i)}`,!(m[0]===m[1]||m[1]===m[2]||m[2]===m[0]))for(let C=0;C<3;C++){const A=(C+1)%3,I=m[C],F=m[A],U=gy[p[C]],V=gy[p[A]],G=`${I}_${F}`,L=`${F}_${I}`;L in y&&y[L]?(b_.dot(y[L].normal)<=s&&(v.push(U.x,U.y,U.z),v.push(V.x,V.y,V.z)),y[L]=null):G in y||(y[G]={index0:h[C],index1:h[A],normal:b_.clone()})}}for(const S in y)if(y[S]){const{index0:T,index1:E}=y[S];py.fromBufferAttribute(o,T),my.fromBufferAttribute(o,E),v.push(py.x,py.y,py.z),v.push(my.x,my.y,my.z)}this.setAttribute("position",new At(v,3))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}}class $c extends Zp{constructor(e){super(e),this.uuid=Ps(),this.type="Shape",this.holes=[]}getPointsHoles(e){const t=[];for(let n=0,i=this.holes.length;n<i;n++)t[n]=this.holes[n].getPoints(e);return t}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const i=e.holes[t];this.holes.push(i.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let t=0,n=this.holes.length;t<n;t++){const i=this.holes[t];e.holes.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const i=e.holes[t];this.holes.push(new Zp().fromJSON(i))}return this}}const Uz={triangulate:function(r,e,t=2){const n=e&&e.length,i=n?e[0]*t:r.length;let s=SA(r,0,i,t,!0);const a=[];if(!s||s.next===s.prev)return a;let o,u,h,p,m,y,v;if(n&&(s=$z(r,e,s,t)),r.length>80*t){o=h=r[0],u=p=r[1];for(let S=t;S<i;S+=t)m=r[S],y=r[S+1],m<o&&(o=m),y<u&&(u=y),m>h&&(h=m),y>p&&(p=y);v=Math.max(h-o,p-u),v=v!==0?32767/v:0}return Jp(s,a,t,o,u,v,0),a}};function SA(r,e,t,n,i){let s,a;if(i===eB(r,e,t,n)>0)for(s=e;s<t;s+=n)a=db(s,r[s],r[s+1],a);else for(s=t-n;s>=e;s-=n)a=db(s,r[s],r[s+1],a);return a&&z0(a,a.next)&&(em(a),a=a.next),a}function Kc(r,e){if(!r)return r;e||(e=r);let t=r,n;do if(n=!1,!t.steiner&&(z0(t,t.next)||cr(t.prev,t,t.next)===0)){if(em(t),t=e=t.prev,t===t.next)break;n=!0}else t=t.next;while(n||t!==e);return e}function Jp(r,e,t,n,i,s,a){if(!r)return;!a&&s&&Xz(r,n,i,s);let o=r,u,h;for(;r.prev!==r.next;){if(u=r.prev,h=r.next,s?Bz(r,n,i,s):zz(r)){e.push(u.i/t|0),e.push(r.i/t|0),e.push(h.i/t|0),em(r),r=h.next,o=h.next;continue}if(r=h,r===o){a?a===1?(r=Vz(Kc(r),e,t),Jp(r,e,t,n,i,s,2)):a===2&&Hz(r,e,t,n,i,s):Jp(Kc(r),e,t,n,i,s,1);break}}}function zz(r){const e=r.prev,t=r,n=r.next;if(cr(e,t,n)>=0)return!1;const i=e.x,s=t.x,a=n.x,o=e.y,u=t.y,h=n.y,p=i<s?i<a?i:a:s<a?s:a,m=o<u?o<h?o:h:u<h?u:h,y=i>s?i>a?i:a:s>a?s:a,v=o>u?o>h?o:h:u>h?u:h;let S=n.next;for(;S!==e;){if(S.x>=p&&S.x<=y&&S.y>=m&&S.y<=v&&zh(i,o,s,u,a,h,S.x,S.y)&&cr(S.prev,S,S.next)>=0)return!1;S=S.next}return!0}function Bz(r,e,t,n){const i=r.prev,s=r,a=r.next;if(cr(i,s,a)>=0)return!1;const o=i.x,u=s.x,h=a.x,p=i.y,m=s.y,y=a.y,v=o<u?o<h?o:h:u<h?u:h,S=p<m?p<y?p:y:m<y?m:y,T=o>u?o>h?o:h:u>h?u:h,E=p>m?p>y?p:y:m>y?m:y,w=Dx(v,S,e,t,n),C=Dx(T,E,e,t,n);let A=r.prevZ,I=r.nextZ;for(;A&&A.z>=w&&I&&I.z<=C;){if(A.x>=v&&A.x<=T&&A.y>=S&&A.y<=E&&A!==i&&A!==a&&zh(o,p,u,m,h,y,A.x,A.y)&&cr(A.prev,A,A.next)>=0||(A=A.prevZ,I.x>=v&&I.x<=T&&I.y>=S&&I.y<=E&&I!==i&&I!==a&&zh(o,p,u,m,h,y,I.x,I.y)&&cr(I.prev,I,I.next)>=0))return!1;I=I.nextZ}for(;A&&A.z>=w;){if(A.x>=v&&A.x<=T&&A.y>=S&&A.y<=E&&A!==i&&A!==a&&zh(o,p,u,m,h,y,A.x,A.y)&&cr(A.prev,A,A.next)>=0)return!1;A=A.prevZ}for(;I&&I.z<=C;){if(I.x>=v&&I.x<=T&&I.y>=S&&I.y<=E&&I!==i&&I!==a&&zh(o,p,u,m,h,y,I.x,I.y)&&cr(I.prev,I,I.next)>=0)return!1;I=I.nextZ}return!0}function Vz(r,e,t){let n=r;do{const i=n.prev,s=n.next.next;!z0(i,s)&&wA(i,n,n.next,s)&&Qp(i,s)&&Qp(s,i)&&(e.push(i.i/t|0),e.push(n.i/t|0),e.push(s.i/t|0),em(n),em(n.next),n=r=s),n=n.next}while(n!==r);return Kc(n)}function Hz(r,e,t,n,i,s){let a=r;do{let o=a.next.next;for(;o!==a.prev;){if(a.i!==o.i&&Zz(a,o)){let u=EA(a,o);a=Kc(a,a.next),u=Kc(u,u.next),Jp(a,e,t,n,i,s,0),Jp(u,e,t,n,i,s,0);return}o=o.next}a=a.next}while(a!==r)}function $z(r,e,t,n){const i=[];let s,a,o,u,h;for(s=0,a=e.length;s<a;s++)o=e[s]*n,u=s<a-1?e[s+1]*n:r.length,h=SA(r,o,u,n,!1),h===h.next&&(h.steiner=!0),i.push(Yz(h));for(i.sort(Gz),s=0;s<i.length;s++)t=Wz(i[s],t);return t}function Gz(r,e){return r.x-e.x}function Wz(r,e){const t=jz(r,e);if(!t)return e;const n=EA(t,r);return Kc(n,n.next),Kc(t,t.next)}function jz(r,e){let t=e,n=-1/0,i;const s=r.x,a=r.y;do{if(a<=t.y&&a>=t.next.y&&t.next.y!==t.y){const y=t.x+(a-t.y)*(t.next.x-t.x)/(t.next.y-t.y);if(y<=s&&y>n&&(n=y,i=t.x<t.next.x?t:t.next,y===s))return i}t=t.next}while(t!==e);if(!i)return null;const o=i,u=i.x,h=i.y;let p=1/0,m;t=i;do s>=t.x&&t.x>=u&&s!==t.x&&zh(a<h?s:n,a,u,h,a<h?n:s,a,t.x,t.y)&&(m=Math.abs(a-t.y)/(s-t.x),Qp(t,r)&&(m<p||m===p&&(t.x>i.x||t.x===i.x&&qz(i,t)))&&(i=t,p=m)),t=t.next;while(t!==o);return i}function qz(r,e){return cr(r.prev,r,e.prev)<0&&cr(e.next,r,r.next)<0}function Xz(r,e,t,n){let i=r;do i.z===0&&(i.z=Dx(i.x,i.y,e,t,n)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==r);i.prevZ.nextZ=null,i.prevZ=null,Kz(i)}function Kz(r){let e,t,n,i,s,a,o,u,h=1;do{for(t=r,r=null,s=null,a=0;t;){for(a++,n=t,o=0,e=0;e<h&&(o++,n=n.nextZ,!!n);e++);for(u=h;o>0||u>0&&n;)o!==0&&(u===0||!n||t.z<=n.z)?(i=t,t=t.nextZ,o--):(i=n,n=n.nextZ,u--),s?s.nextZ=i:r=i,i.prevZ=s,s=i;t=n}s.nextZ=null,h*=2}while(a>1);return r}function Dx(r,e,t,n,i){return r=(r-t)*i|0,e=(e-n)*i|0,r=(r|r<<8)&16711935,r=(r|r<<4)&252645135,r=(r|r<<2)&858993459,r=(r|r<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,r|e<<1}function Yz(r){let e=r,t=r;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==r);return t}function zh(r,e,t,n,i,s,a,o){return(i-a)*(e-o)>=(r-a)*(s-o)&&(r-a)*(n-o)>=(t-a)*(e-o)&&(t-a)*(s-o)>=(i-a)*(n-o)}function Zz(r,e){return r.next.i!==e.i&&r.prev.i!==e.i&&!Jz(r,e)&&(Qp(r,e)&&Qp(e,r)&&Qz(r,e)&&(cr(r.prev,r,e.prev)||cr(r,e.prev,e))||z0(r,e)&&cr(r.prev,r,r.next)>0&&cr(e.prev,e,e.next)>0)}function cr(r,e,t){return(e.y-r.y)*(t.x-e.x)-(e.x-r.x)*(t.y-e.y)}function z0(r,e){return r.x===e.x&&r.y===e.y}function wA(r,e,t,n){const i=vy(cr(r,e,t)),s=vy(cr(r,e,n)),a=vy(cr(t,n,r)),o=vy(cr(t,n,e));return!!(i!==s&&a!==o||i===0&&yy(r,t,e)||s===0&&yy(r,n,e)||a===0&&yy(t,r,n)||o===0&&yy(t,e,n))}function yy(r,e,t){return e.x<=Math.max(r.x,t.x)&&e.x>=Math.min(r.x,t.x)&&e.y<=Math.max(r.y,t.y)&&e.y>=Math.min(r.y,t.y)}function vy(r){return r>0?1:r<0?-1:0}function Jz(r,e){let t=r;do{if(t.i!==r.i&&t.next.i!==r.i&&t.i!==e.i&&t.next.i!==e.i&&wA(t,t.next,r,e))return!0;t=t.next}while(t!==r);return!1}function Qp(r,e){return cr(r.prev,r,r.next)<0?cr(r,e,r.next)>=0&&cr(r,r.prev,e)>=0:cr(r,e,r.prev)<0||cr(r,r.next,e)<0}function Qz(r,e){let t=r,n=!1;const i=(r.x+e.x)/2,s=(r.y+e.y)/2;do t.y>s!=t.next.y>s&&t.next.y!==t.y&&i<(t.next.x-t.x)*(s-t.y)/(t.next.y-t.y)+t.x&&(n=!n),t=t.next;while(t!==r);return n}function EA(r,e){const t=new Ox(r.i,r.x,r.y),n=new Ox(e.i,e.x,e.y),i=r.next,s=e.prev;return r.next=e,e.prev=r,t.next=i,i.prev=t,n.next=t,t.prev=n,s.next=n,n.prev=s,n}function db(r,e,t,n){const i=new Ox(r,e,t);return n?(i.next=n.next,i.prev=n,n.next.prev=i,n.next=i):(i.prev=i,i.next=i),i}function em(r){r.next.prev=r.prev,r.prev.next=r.next,r.prevZ&&(r.prevZ.nextZ=r.nextZ),r.nextZ&&(r.nextZ.prevZ=r.prevZ)}function Ox(r,e,t){this.i=r,this.x=e,this.y=t,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function eB(r,e,t,n){let i=0;for(let s=e,a=t-n;s<t;s+=n)i+=(r[a]-r[s])*(r[s+1]+r[a+1]),a=s;return i}class no{static area(e){const t=e.length;let n=0;for(let i=t-1,s=0;s<t;i=s++)n+=e[i].x*e[s].y-e[s].x*e[i].y;return n*.5}static isClockWise(e){return no.area(e)<0}static triangulateShape(e,t){const n=[],i=[],s=[];pb(e),mb(n,e);let a=e.length;t.forEach(pb);for(let u=0;u<t.length;u++)i.push(a),a+=t[u].length,mb(n,t[u]);const o=Uz.triangulate(n,i);for(let u=0;u<o.length;u+=3)s.push(o.slice(u,u+3));return s}}function pb(r){const e=r.length;e>2&&r[e-1].equals(r[0])&&r.pop()}function mb(r,e){for(let t=0;t<e.length;t++)r.push(e[t].x),r.push(e[t].y)}class B0 extends ln{constructor(e=new $c([new Pe(.5,.5),new Pe(-.5,.5),new Pe(-.5,-.5),new Pe(.5,-.5)]),t={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const n=this,i=[],s=[];for(let o=0,u=e.length;o<u;o++){const h=e[o];a(h)}this.setAttribute("position",new At(i,3)),this.setAttribute("uv",new At(s,2)),this.computeVertexNormals();function a(o){const u=[],h=t.curveSegments!==void 0?t.curveSegments:12,p=t.steps!==void 0?t.steps:1,m=t.depth!==void 0?t.depth:1;let y=t.bevelEnabled!==void 0?t.bevelEnabled:!0,v=t.bevelThickness!==void 0?t.bevelThickness:.2,S=t.bevelSize!==void 0?t.bevelSize:v-.1,T=t.bevelOffset!==void 0?t.bevelOffset:0,E=t.bevelSegments!==void 0?t.bevelSegments:3;const w=t.extrudePath,C=t.UVGenerator!==void 0?t.UVGenerator:tB;let A,I=!1,F,U,V,G;w&&(A=w.getSpacedPoints(p),I=!0,y=!1,F=w.computeFrenetFrames(p,!1),U=new X,V=new X,G=new X),y||(E=0,v=0,S=0,T=0);const L=o.extractPoints(h);let k=L.shape;const O=L.holes;if(!no.isClockWise(k)){k=k.reverse();for(let se=0,Ve=O.length;se<Ve;se++){const Ie=O[se];no.isClockWise(Ie)&&(O[se]=Ie.reverse())}}const le=no.triangulateShape(k,O),K=k;for(let se=0,Ve=O.length;se<Ve;se++){const Ie=O[se];k=k.concat(Ie)}function ce(se,Ve,Ie){return Ve||console.error("THREE.ExtrudeGeometry: vec does not exist"),se.clone().addScaledVector(Ve,Ie)}const de=k.length,me=le.length;function Z(se,Ve,Ie){let je,De,bt;const at=se.x-Ve.x,dt=se.y-Ve.y,Pt=Ie.x-se.x,Gt=Ie.y-se.y,wn=at*at+dt*dt,J=at*Gt-dt*Pt;if(Math.abs(J)>Number.EPSILON){const $=Math.sqrt(wn),Se=Math.sqrt(Pt*Pt+Gt*Gt),qe=Ve.x-dt/$,Oe=Ve.y+at/$,He=Ie.x-Gt/Se,St=Ie.y+Pt/Se,Ke=((He-qe)*Gt-(St-Oe)*Pt)/(at*Gt-dt*Pt);je=qe+at*Ke-se.x,De=Oe+dt*Ke-se.y;const rt=je*je+De*De;if(rt<=2)return new Pe(je,De);bt=Math.sqrt(rt/2)}else{let $=!1;at>Number.EPSILON?Pt>Number.EPSILON&&($=!0):at<-Number.EPSILON?Pt<-Number.EPSILON&&($=!0):Math.sign(dt)===Math.sign(Gt)&&($=!0),$?(je=-dt,De=at,bt=Math.sqrt(wn)):(je=at,De=dt,bt=Math.sqrt(wn/2))}return new Pe(je/bt,De/bt)}const re=[];for(let se=0,Ve=K.length,Ie=Ve-1,je=se+1;se<Ve;se++,Ie++,je++)Ie===Ve&&(Ie=0),je===Ve&&(je=0),re[se]=Z(K[se],K[Ie],K[je]);const ee=[];let z,q=re.concat();for(let se=0,Ve=O.length;se<Ve;se++){const Ie=O[se];z=[];for(let je=0,De=Ie.length,bt=De-1,at=je+1;je<De;je++,bt++,at++)bt===De&&(bt=0),at===De&&(at=0),z[je]=Z(Ie[je],Ie[bt],Ie[at]);ee.push(z),q=q.concat(z)}for(let se=0;se<E;se++){const Ve=se/E,Ie=v*Math.cos(Ve*Math.PI/2),je=S*Math.sin(Ve*Math.PI/2)+T;for(let De=0,bt=K.length;De<bt;De++){const at=ce(K[De],re[De],je);tt(at.x,at.y,-Ie)}for(let De=0,bt=O.length;De<bt;De++){const at=O[De];z=ee[De];for(let dt=0,Pt=at.length;dt<Pt;dt++){const Gt=ce(at[dt],z[dt],je);tt(Gt.x,Gt.y,-Ie)}}}const ve=S+T;for(let se=0;se<de;se++){const Ve=y?ce(k[se],q[se],ve):k[se];I?(V.copy(F.normals[0]).multiplyScalar(Ve.x),U.copy(F.binormals[0]).multiplyScalar(Ve.y),G.copy(A[0]).add(V).add(U),tt(G.x,G.y,G.z)):tt(Ve.x,Ve.y,0)}for(let se=1;se<=p;se++)for(let Ve=0;Ve<de;Ve++){const Ie=y?ce(k[Ve],q[Ve],ve):k[Ve];I?(V.copy(F.normals[se]).multiplyScalar(Ie.x),U.copy(F.binormals[se]).multiplyScalar(Ie.y),G.copy(A[se]).add(V).add(U),tt(G.x,G.y,G.z)):tt(Ie.x,Ie.y,m/p*se)}for(let se=E-1;se>=0;se--){const Ve=se/E,Ie=v*Math.cos(Ve*Math.PI/2),je=S*Math.sin(Ve*Math.PI/2)+T;for(let De=0,bt=K.length;De<bt;De++){const at=ce(K[De],re[De],je);tt(at.x,at.y,m+Ie)}for(let De=0,bt=O.length;De<bt;De++){const at=O[De];z=ee[De];for(let dt=0,Pt=at.length;dt<Pt;dt++){const Gt=ce(at[dt],z[dt],je);I?tt(Gt.x,Gt.y+A[p-1].y,A[p-1].x+Ie):tt(Gt.x,Gt.y,m+Ie)}}}Ce(),ke();function Ce(){const se=i.length/3;if(y){let Ve=0,Ie=de*Ve;for(let je=0;je<me;je++){const De=le[je];nt(De[2]+Ie,De[1]+Ie,De[0]+Ie)}Ve=p+E*2,Ie=de*Ve;for(let je=0;je<me;je++){const De=le[je];nt(De[0]+Ie,De[1]+Ie,De[2]+Ie)}}else{for(let Ve=0;Ve<me;Ve++){const Ie=le[Ve];nt(Ie[2],Ie[1],Ie[0])}for(let Ve=0;Ve<me;Ve++){const Ie=le[Ve];nt(Ie[0]+de*p,Ie[1]+de*p,Ie[2]+de*p)}}n.addGroup(se,i.length/3-se,0)}function ke(){const se=i.length/3;let Ve=0;We(K,Ve),Ve+=K.length;for(let Ie=0,je=O.length;Ie<je;Ie++){const De=O[Ie];We(De,Ve),Ve+=De.length}n.addGroup(se,i.length/3-se,1)}function We(se,Ve){let Ie=se.length;for(;--Ie>=0;){const je=Ie;let De=Ie-1;De<0&&(De=se.length-1);for(let bt=0,at=p+E*2;bt<at;bt++){const dt=de*bt,Pt=de*(bt+1),Gt=Ve+je+dt,wn=Ve+De+dt,J=Ve+De+Pt,$=Ve+je+Pt;ut(Gt,wn,J,$)}}}function tt(se,Ve,Ie){u.push(se),u.push(Ve),u.push(Ie)}function nt(se,Ve,Ie){kt(se),kt(Ve),kt(Ie);const je=i.length/3,De=C.generateTopUV(n,i,je-3,je-2,je-1);vt(De[0]),vt(De[1]),vt(De[2])}function ut(se,Ve,Ie,je){kt(se),kt(Ve),kt(je),kt(Ve),kt(Ie),kt(je);const De=i.length/3,bt=C.generateSideWallUV(n,i,De-6,De-3,De-2,De-1);vt(bt[0]),vt(bt[1]),vt(bt[3]),vt(bt[1]),vt(bt[2]),vt(bt[3])}function kt(se){i.push(u[se*3+0]),i.push(u[se*3+1]),i.push(u[se*3+2])}function vt(se){s.push(se.x),s.push(se.y)}}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON(),t=this.parameters.shapes,n=this.parameters.options;return nB(t,n,e)}static fromJSON(e,t){const n=[];for(let s=0,a=e.shapes.length;s<a;s++){const o=t[e.shapes[s]];n.push(o)}const i=e.options.extrudePath;return i!==void 0&&(e.options.extrudePath=new n0[i.type]().fromJSON(i)),new B0(n,e.options)}}const tB={generateTopUV:function(r,e,t,n,i){const s=e[t*3],a=e[t*3+1],o=e[n*3],u=e[n*3+1],h=e[i*3],p=e[i*3+1];return[new Pe(s,a),new Pe(o,u),new Pe(h,p)]},generateSideWallUV:function(r,e,t,n,i,s){const a=e[t*3],o=e[t*3+1],u=e[t*3+2],h=e[n*3],p=e[n*3+1],m=e[n*3+2],y=e[i*3],v=e[i*3+1],S=e[i*3+2],T=e[s*3],E=e[s*3+1],w=e[s*3+2];return Math.abs(o-p)<Math.abs(a-h)?[new Pe(a,1-u),new Pe(h,1-m),new Pe(y,1-S),new Pe(T,1-w)]:[new Pe(o,1-u),new Pe(p,1-m),new Pe(v,1-S),new Pe(E,1-w)]}};function nB(r,e,t){if(t.shapes=[],Array.isArray(r))for(let n=0,i=r.length;n<i;n++){const s=r[n];t.shapes.push(s.uuid)}else t.shapes.push(r.uuid);return t.options=Object.assign({},e),e.extrudePath!==void 0&&(t.options.extrudePath=e.extrudePath.toJSON()),t}class V0 extends bu{constructor(e=1,t=0){const n=(1+Math.sqrt(5))/2,i=[-1,n,0,1,n,0,-1,-n,0,1,-n,0,0,-1,n,0,1,n,0,-1,-n,0,1,-n,n,0,-1,n,0,1,-n,0,-1,-n,0,1],s=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(i,s,e,t),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new V0(e.radius,e.detail)}}class Mm extends bu{constructor(e=1,t=0){const n=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],i=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(n,i,e,t),this.type="OctahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new Mm(e.radius,e.detail)}}class H0 extends ln{constructor(e=.5,t=1,n=32,i=1,s=0,a=Math.PI*2){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:n,phiSegments:i,thetaStart:s,thetaLength:a},n=Math.max(3,n),i=Math.max(1,i);const o=[],u=[],h=[],p=[];let m=e;const y=(t-e)/i,v=new X,S=new Pe;for(let T=0;T<=i;T++){for(let E=0;E<=n;E++){const w=s+E/n*a;v.x=m*Math.cos(w),v.y=m*Math.sin(w),u.push(v.x,v.y,v.z),h.push(0,0,1),S.x=(v.x/t+1)/2,S.y=(v.y/t+1)/2,p.push(S.x,S.y)}m+=y}for(let T=0;T<i;T++){const E=T*(n+1);for(let w=0;w<n;w++){const C=w+E,A=C,I=C+n+1,F=C+n+2,U=C+1;o.push(A,I,U),o.push(I,F,U)}}this.setIndex(o),this.setAttribute("position",new At(u,3)),this.setAttribute("normal",new At(h,3)),this.setAttribute("uv",new At(p,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new H0(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)}}class $0 extends ln{constructor(e=new $c([new Pe(0,.5),new Pe(-.5,-.5),new Pe(.5,-.5)]),t=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const n=[],i=[],s=[],a=[];let o=0,u=0;if(Array.isArray(e)===!1)h(e);else for(let p=0;p<e.length;p++)h(e[p]),this.addGroup(o,u,p),o+=u,u=0;this.setIndex(n),this.setAttribute("position",new At(i,3)),this.setAttribute("normal",new At(s,3)),this.setAttribute("uv",new At(a,2));function h(p){const m=i.length/3,y=p.extractPoints(t);let v=y.shape;const S=y.holes;no.isClockWise(v)===!1&&(v=v.reverse());for(let E=0,w=S.length;E<w;E++){const C=S[E];no.isClockWise(C)===!0&&(S[E]=C.reverse())}const T=no.triangulateShape(v,S);for(let E=0,w=S.length;E<w;E++){const C=S[E];v=v.concat(C)}for(let E=0,w=v.length;E<w;E++){const C=v[E];i.push(C.x,C.y,0),s.push(0,0,1),a.push(C.x,C.y)}for(let E=0,w=T.length;E<w;E++){const C=T[E],A=C[0]+m,I=C[1]+m,F=C[2]+m;n.push(A,I,F),u+=3}}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON(),t=this.parameters.shapes;return rB(t,e)}static fromJSON(e,t){const n=[];for(let i=0,s=e.shapes.length;i<s;i++){const a=t[e.shapes[i]];n.push(a)}return new $0(n,e.curveSegments)}}function rB(r,e){if(e.shapes=[],Array.isArray(r))for(let t=0,n=r.length;t<n;t++){const i=r[t];e.shapes.push(i.uuid)}else e.shapes.push(r.uuid);return e}class Am extends ln{constructor(e=1,t=32,n=16,i=0,s=Math.PI*2,a=0,o=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:n,phiStart:i,phiLength:s,thetaStart:a,thetaLength:o},t=Math.max(3,Math.floor(t)),n=Math.max(2,Math.floor(n));const u=Math.min(a+o,Math.PI);let h=0;const p=[],m=new X,y=new X,v=[],S=[],T=[],E=[];for(let w=0;w<=n;w++){const C=[],A=w/n;let I=0;w===0&&a===0?I=.5/t:w===n&&u===Math.PI&&(I=-.5/t);for(let F=0;F<=t;F++){const U=F/t;m.x=-e*Math.cos(i+U*s)*Math.sin(a+A*o),m.y=e*Math.cos(a+A*o),m.z=e*Math.sin(i+U*s)*Math.sin(a+A*o),S.push(m.x,m.y,m.z),y.copy(m).normalize(),T.push(y.x,y.y,y.z),E.push(U+I,1-A),C.push(h++)}p.push(C)}for(let w=0;w<n;w++)for(let C=0;C<t;C++){const A=p[w][C+1],I=p[w][C],F=p[w+1][C],U=p[w+1][C+1];(w!==0||a>0)&&v.push(A,I,U),(w!==n-1||u<Math.PI)&&v.push(I,F,U)}this.setIndex(v),this.setAttribute("position",new At(S,3)),this.setAttribute("normal",new At(T,3)),this.setAttribute("uv",new At(E,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Am(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}class G0 extends bu{constructor(e=1,t=0){const n=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],i=[2,1,0,0,3,2,1,3,0,2,3,1];super(n,i,e,t),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new G0(e.radius,e.detail)}}class W0 extends ln{constructor(e=1,t=.4,n=12,i=48,s=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:t,radialSegments:n,tubularSegments:i,arc:s},n=Math.floor(n),i=Math.floor(i);const a=[],o=[],u=[],h=[],p=new X,m=new X,y=new X;for(let v=0;v<=n;v++)for(let S=0;S<=i;S++){const T=S/i*s,E=v/n*Math.PI*2;m.x=(e+t*Math.cos(E))*Math.cos(T),m.y=(e+t*Math.cos(E))*Math.sin(T),m.z=t*Math.sin(E),o.push(m.x,m.y,m.z),p.x=e*Math.cos(T),p.y=e*Math.sin(T),y.subVectors(m,p).normalize(),u.push(y.x,y.y,y.z),h.push(S/i),h.push(v/n)}for(let v=1;v<=n;v++)for(let S=1;S<=i;S++){const T=(i+1)*v+S-1,E=(i+1)*(v-1)+S-1,w=(i+1)*(v-1)+S,C=(i+1)*v+S;a.push(T,E,C),a.push(E,w,C)}this.setIndex(a),this.setAttribute("position",new At(o,3)),this.setAttribute("normal",new At(u,3)),this.setAttribute("uv",new At(h,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new W0(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}}class j0 extends ln{constructor(e=1,t=.4,n=64,i=8,s=2,a=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:t,tubularSegments:n,radialSegments:i,p:s,q:a},n=Math.floor(n),i=Math.floor(i);const o=[],u=[],h=[],p=[],m=new X,y=new X,v=new X,S=new X,T=new X,E=new X,w=new X;for(let A=0;A<=n;++A){const I=A/n*s*Math.PI*2;C(I,s,a,e,v),C(I+.01,s,a,e,S),E.subVectors(S,v),w.addVectors(S,v),T.crossVectors(E,w),w.crossVectors(T,E),T.normalize(),w.normalize();for(let F=0;F<=i;++F){const U=F/i*Math.PI*2,V=-t*Math.cos(U),G=t*Math.sin(U);m.x=v.x+(V*w.x+G*T.x),m.y=v.y+(V*w.y+G*T.y),m.z=v.z+(V*w.z+G*T.z),u.push(m.x,m.y,m.z),y.subVectors(m,v).normalize(),h.push(y.x,y.y,y.z),p.push(A/n),p.push(F/i)}}for(let A=1;A<=n;A++)for(let I=1;I<=i;I++){const F=(i+1)*(A-1)+(I-1),U=(i+1)*A+(I-1),V=(i+1)*A+I,G=(i+1)*(A-1)+I;o.push(F,U,G),o.push(U,V,G)}this.setIndex(o),this.setAttribute("position",new At(u,3)),this.setAttribute("normal",new At(h,3)),this.setAttribute("uv",new At(p,2));function C(A,I,F,U,V){const G=Math.cos(A),L=Math.sin(A),k=F/I*A,O=Math.cos(k);V.x=U*(2+O)*.5*G,V.y=U*(2+O)*L*.5,V.z=U*Math.sin(k)*.5}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new j0(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)}}class q0 extends ln{constructor(e=new KS(new X(-1,-1,0),new X(-1,1,0),new X(1,1,0)),t=64,n=1,i=8,s=!1){super(),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:t,radius:n,radialSegments:i,closed:s};const a=e.computeFrenetFrames(t,s);this.tangents=a.tangents,this.normals=a.normals,this.binormals=a.binormals;const o=new X,u=new X,h=new Pe;let p=new X;const m=[],y=[],v=[],S=[];T(),this.setIndex(S),this.setAttribute("position",new At(m,3)),this.setAttribute("normal",new At(y,3)),this.setAttribute("uv",new At(v,2));function T(){for(let A=0;A<t;A++)E(A);E(s===!1?t:0),C(),w()}function E(A){p=e.getPointAt(A/t,p);const I=a.normals[A],F=a.binormals[A];for(let U=0;U<=i;U++){const V=U/i*Math.PI*2,G=Math.sin(V),L=-Math.cos(V);u.x=L*I.x+G*F.x,u.y=L*I.y+G*F.y,u.z=L*I.z+G*F.z,u.normalize(),y.push(u.x,u.y,u.z),o.x=p.x+n*u.x,o.y=p.y+n*u.y,o.z=p.z+n*u.z,m.push(o.x,o.y,o.z)}}function w(){for(let A=1;A<=t;A++)for(let I=1;I<=i;I++){const F=(i+1)*(A-1)+(I-1),U=(i+1)*A+(I-1),V=(i+1)*A+I,G=(i+1)*(A-1)+I;S.push(F,U,G),S.push(U,V,G)}}function C(){for(let A=0;A<=t;A++)for(let I=0;I<=i;I++)h.x=A/t,h.y=I/i,v.push(h.x,h.y)}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON();return e.path=this.parameters.path.toJSON(),e}static fromJSON(e){return new q0(new n0[e.path.type]().fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)}}class bA extends ln{constructor(e=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:e},e!==null){const t=[],n=new Set,i=new X,s=new X;if(e.index!==null){const a=e.attributes.position,o=e.index;let u=e.groups;u.length===0&&(u=[{start:0,count:o.count,materialIndex:0}]);for(let h=0,p=u.length;h<p;++h){const m=u[h],y=m.start,v=m.count;for(let S=y,T=y+v;S<T;S+=3)for(let E=0;E<3;E++){const w=o.getX(S+E),C=o.getX(S+(E+1)%3);i.fromBufferAttribute(a,w),s.fromBufferAttribute(a,C),gb(i,s,n)===!0&&(t.push(i.x,i.y,i.z),t.push(s.x,s.y,s.z))}}}else{const a=e.attributes.position;for(let o=0,u=a.count/3;o<u;o++)for(let h=0;h<3;h++){const p=3*o+h,m=3*o+(h+1)%3;i.fromBufferAttribute(a,p),s.fromBufferAttribute(a,m),gb(i,s,n)===!0&&(t.push(i.x,i.y,i.z),t.push(s.x,s.y,s.z))}}this.setAttribute("position",new At(t,3))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}}function gb(r,e,t){const n=`${r.x},${r.y},${r.z}-${e.x},${e.y},${e.z}`,i=`${e.x},${e.y},${e.z}-${r.x},${r.y},${r.z}`;return t.has(n)===!0||t.has(i)===!0?!1:(t.add(n),t.add(i),!0)}var yb=Object.freeze({__proto__:null,BoxGeometry:af,CapsuleGeometry:D0,CircleGeometry:O0,ConeGeometry:F0,CylinderGeometry:ld,DodecahedronGeometry:U0,EdgesGeometry:xA,ExtrudeGeometry:B0,IcosahedronGeometry:V0,LatheGeometry:Tm,OctahedronGeometry:Mm,PlaneGeometry:bm,PolyhedronGeometry:bu,RingGeometry:H0,ShapeGeometry:$0,SphereGeometry:Am,TetrahedronGeometry:G0,TorusGeometry:W0,TorusKnotGeometry:j0,TubeGeometry:q0,WireframeGeometry:bA});class TA extends Ri{constructor(e){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new yt(0),this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.fog=e.fog,this}}class MA extends io{constructor(e){super(e),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class ZS extends Ri{constructor(e){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new yt(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new yt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=wu,this.normalScale=new Pe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class AA extends ZS{constructor(e){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Pe(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return mr(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new yt(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new yt(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new yt(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(e)}get anisotropy(){return this._anisotropy}set anisotropy(e){this._anisotropy>0!=e>0&&this.version++,this._anisotropy=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get iridescence(){return this._iridescence}set iridescence(e){this._iridescence>0!=e>0&&this.version++,this._iridescence=e}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=e.anisotropy,this.anisotropyRotation=e.anisotropyRotation,this.anisotropyMap=e.anisotropyMap,this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.ior=e.ior,this.iridescence=e.iridescence,this.iridescenceMap=e.iridescenceMap,this.iridescenceIOR=e.iridescenceIOR,this.iridescenceThicknessRange=[...e.iridescenceThicknessRange],this.iridescenceThicknessMap=e.iridescenceThicknessMap,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}class NA extends Ri{constructor(e){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new yt(16777215),this.specular=new yt(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new yt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=wu,this.normalScale=new Pe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=_m,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class CA extends Ri{constructor(e){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new yt(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new yt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=wu,this.normalScale=new Pe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}class RA extends Ri{constructor(e){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=wu,this.normalScale=new Pe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this}}class IA extends Ri{constructor(e){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new yt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new yt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=wu,this.normalScale=new Pe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=_m,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class PA extends Ri{constructor(e){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new yt(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=wu,this.normalScale=new Pe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.flatShading=e.flatShading,this.fog=e.fog,this}}class LA extends qi{constructor(e){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}function Uc(r,e,t){return!r||!t&&r.constructor===e?r:typeof e.BYTES_PER_ELEMENT=="number"?new e(r):Array.prototype.slice.call(r)}function kA(r){return ArrayBuffer.isView(r)&&!(r instanceof DataView)}function DA(r){function e(i,s){return r[i]-r[s]}const t=r.length,n=new Array(t);for(let i=0;i!==t;++i)n[i]=i;return n.sort(e),n}function Fx(r,e,t){const n=r.length,i=new r.constructor(n);for(let s=0,a=0;a!==n;++s){const o=t[s]*e;for(let u=0;u!==e;++u)i[a++]=r[o+u]}return i}function JS(r,e,t,n){let i=1,s=r[0];for(;s!==void 0&&s[n]===void 0;)s=r[i++];if(s===void 0)return;let a=s[n];if(a!==void 0)if(Array.isArray(a))do a=s[n],a!==void 0&&(e.push(s.time),t.push.apply(t,a)),s=r[i++];while(s!==void 0);else if(a.toArray!==void 0)do a=s[n],a!==void 0&&(e.push(s.time),a.toArray(t,t.length)),s=r[i++];while(s!==void 0);else do a=s[n],a!==void 0&&(e.push(s.time),t.push(a)),s=r[i++];while(s!==void 0)}function iB(r,e,t,n,i=30){const s=r.clone();s.name=e;const a=[];for(let u=0;u<s.tracks.length;++u){const h=s.tracks[u],p=h.getValueSize(),m=[],y=[];for(let v=0;v<h.times.length;++v){const S=h.times[v]*i;if(!(S<t||S>=n)){m.push(h.times[v]);for(let T=0;T<p;++T)y.push(h.values[v*p+T])}}m.length!==0&&(h.times=Uc(m,h.times.constructor),h.values=Uc(y,h.values.constructor),a.push(h))}s.tracks=a;let o=1/0;for(let u=0;u<s.tracks.length;++u)o>s.tracks[u].times[0]&&(o=s.tracks[u].times[0]);for(let u=0;u<s.tracks.length;++u)s.tracks[u].shift(-1*o);return s.resetDuration(),s}function sB(r,e=0,t=r,n=30){n<=0&&(n=30);const i=t.tracks.length,s=e/n;for(let a=0;a<i;++a){const o=t.tracks[a],u=o.ValueTypeName;if(u==="bool"||u==="string")continue;const h=r.tracks.find(function(w){return w.name===o.name&&w.ValueTypeName===u});if(h===void 0)continue;let p=0;const m=o.getValueSize();o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(p=m/3);let y=0;const v=h.getValueSize();h.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(y=v/3);const S=o.times.length-1;let T;if(s<=o.times[0]){const w=p,C=m-p;T=o.values.slice(w,C)}else if(s>=o.times[S]){const w=S*m+p,C=w+m-p;T=o.values.slice(w,C)}else{const w=o.createInterpolant(),C=p,A=m-p;w.evaluate(s),T=w.resultBuffer.slice(C,A)}u==="quaternion"&&new Ni().fromArray(T).normalize().conjugate().toArray(T);const E=h.times.length;for(let w=0;w<E;++w){const C=w*v+y;if(u==="quaternion")Ni.multiplyQuaternionsFlat(h.values,C,T,0,h.values,C);else{const A=v-y*2;for(let I=0;I<A;++I)h.values[C+I]-=T[I]}}}return r.blendMode=RS,r}const aB={convertArray:Uc,isTypedArray:kA,getKeyframeOrder:DA,sortedArray:Fx,flattenJSON:JS,subclip:iB,makeClipAdditive:sB};class Nm{constructor(e,t,n,i){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=i!==void 0?i:new t.constructor(n),this.sampleValues=t,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let n=this._cachedIndex,i=t[n],s=t[n-1];e:{t:{let a;n:{r:if(!(e<i)){for(let o=n+2;;){if(i===void 0){if(e<s)break r;return n=t.length,this._cachedIndex=n,this.copySampleValue_(n-1)}if(n===o)break;if(s=i,i=t[++n],e<i)break t}a=t.length;break n}if(!(e>=s)){const o=t[1];e<o&&(n=2,s=o);for(let u=n-2;;){if(s===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(n===u)break;if(i=s,s=t[--n-1],e>=s)break t}a=n,n=0;break n}break e}for(;n<a;){const o=n+a>>>1;e<t[o]?a=o:n=o+1}if(i=t[n],s=t[n-1],s===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(i===void 0)return n=t.length,this._cachedIndex=n,this.copySampleValue_(n-1)}this._cachedIndex=n,this.intervalChanged_(n,s,i)}return this.interpolate_(n,s,e,i)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,i=this.valueSize,s=e*i;for(let a=0;a!==i;++a)t[a]=n[s+a];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class OA extends Nm{constructor(e,t,n,i){super(e,t,n,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:Dc,endingEnd:Dc}}intervalChanged_(e,t,n){const i=this.parameterPositions;let s=e-2,a=e+1,o=i[s],u=i[a];if(o===void 0)switch(this.getSettings_().endingStart){case Oc:s=e,o=2*t-n;break;case Gp:s=i.length-2,o=t+i[s]-i[s+1];break;default:s=e,o=n}if(u===void 0)switch(this.getSettings_().endingEnd){case Oc:a=e,u=2*n-t;break;case Gp:a=1,u=n+i[1]-i[0];break;default:a=e-1,u=t}const h=(n-t)*.5,p=this.valueSize;this._weightPrev=h/(t-o),this._weightNext=h/(u-n),this._offsetPrev=s*p,this._offsetNext=a*p}interpolate_(e,t,n,i){const s=this.resultBuffer,a=this.sampleValues,o=this.valueSize,u=e*o,h=u-o,p=this._offsetPrev,m=this._offsetNext,y=this._weightPrev,v=this._weightNext,S=(n-t)/(i-t),T=S*S,E=T*S,w=-y*E+2*y*T-y*S,C=(1+y)*E+(-1.5-2*y)*T+(-.5+y)*S+1,A=(-1-v)*E+(1.5+v)*T+.5*S,I=v*E-v*T;for(let F=0;F!==o;++F)s[F]=w*a[p+F]+C*a[h+F]+A*a[u+F]+I*a[m+F];return s}}class QS extends Nm{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e,t,n,i){const s=this.resultBuffer,a=this.sampleValues,o=this.valueSize,u=e*o,h=u-o,p=(n-t)/(i-t),m=1-p;for(let y=0;y!==o;++y)s[y]=a[h+y]*m+a[u+y]*p;return s}}class FA extends Nm{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e){return this.copySampleValue_(e-1)}}class La{constructor(e,t,n,i){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(t===void 0||t.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=Uc(t,this.TimeBufferType),this.values=Uc(n,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let n;if(t.toJSON!==this.toJSON)n=t.toJSON(e);else{n={name:e.name,times:Uc(e.times,Array),values:Uc(e.values,Array)};const i=e.getInterpolation();i!==e.DefaultInterpolation&&(n.interpolation=i)}return n.type=e.ValueTypeName,n}InterpolantFactoryMethodDiscrete(e){return new FA(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new QS(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new OA(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case Hp:t=this.InterpolantFactoryMethodDiscrete;break;case $p:t=this.InterpolantFactoryMethodLinear;break;case Fy:t=this.InterpolantFactoryMethodSmooth;break}if(t===void 0){const n="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(e!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(n);return console.warn("THREE.KeyframeTrack:",n),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Hp;case this.InterpolantFactoryMethodLinear:return $p;case this.InterpolantFactoryMethodSmooth:return Fy}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){const t=this.times;for(let n=0,i=t.length;n!==i;++n)t[n]+=e}return this}scale(e){if(e!==1){const t=this.times;for(let n=0,i=t.length;n!==i;++n)t[n]*=e}return this}trim(e,t){const n=this.times,i=n.length;let s=0,a=i-1;for(;s!==i&&n[s]<e;)++s;for(;a!==-1&&n[a]>t;)--a;if(++a,s!==0||a!==i){s>=a&&(a=Math.max(a,1),s=a-1);const o=this.getValueSize();this.times=n.slice(s,a),this.values=this.values.slice(s*o,a*o)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const n=this.times,i=this.values,s=n.length;s===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let a=null;for(let o=0;o!==s;o++){const u=n[o];if(typeof u=="number"&&isNaN(u)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,o,u),e=!1;break}if(a!==null&&a>u){console.error("THREE.KeyframeTrack: Out of order keys.",this,o,u,a),e=!1;break}a=u}if(i!==void 0&&kA(i))for(let o=0,u=i.length;o!==u;++o){const h=i[o];if(isNaN(h)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,o,h),e=!1;break}}return e}optimize(){const e=this.times.slice(),t=this.values.slice(),n=this.getValueSize(),i=this.getInterpolation()===Fy,s=e.length-1;let a=1;for(let o=1;o<s;++o){let u=!1;const h=e[o],p=e[o+1];if(h!==p&&(o!==1||h!==e[0]))if(i)u=!0;else{const m=o*n,y=m-n,v=m+n;for(let S=0;S!==n;++S){const T=t[m+S];if(T!==t[y+S]||T!==t[v+S]){u=!0;break}}}if(u){if(o!==a){e[a]=e[o];const m=o*n,y=a*n;for(let v=0;v!==n;++v)t[y+v]=t[m+v]}++a}}if(s>0){e[a]=e[s];for(let o=s*n,u=a*n,h=0;h!==n;++h)t[u+h]=t[o+h];++a}return a!==e.length?(this.times=e.slice(0,a),this.values=t.slice(0,a*n)):(this.times=e,this.values=t),this}clone(){const e=this.times.slice(),t=this.values.slice(),n=this.constructor,i=new n(this.name,e,t);return i.createInterpolant=this.createInterpolant,i}}La.prototype.TimeBufferType=Float32Array;La.prototype.ValueBufferType=Float32Array;La.prototype.DefaultInterpolation=$p;class of extends La{}of.prototype.ValueTypeName="bool";of.prototype.ValueBufferType=Array;of.prototype.DefaultInterpolation=Hp;of.prototype.InterpolantFactoryMethodLinear=void 0;of.prototype.InterpolantFactoryMethodSmooth=void 0;class e1 extends La{}e1.prototype.ValueTypeName="color";class tm extends La{}tm.prototype.ValueTypeName="number";class UA extends Nm{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e,t,n,i){const s=this.resultBuffer,a=this.sampleValues,o=this.valueSize,u=(n-t)/(i-t);let h=e*o;for(let p=h+o;h!==p;h+=4)Ni.slerpFlat(s,0,a,h-o,a,h,u);return s}}class ud extends La{InterpolantFactoryMethodLinear(e){return new UA(this.times,this.values,this.getValueSize(),e)}}ud.prototype.ValueTypeName="quaternion";ud.prototype.DefaultInterpolation=$p;ud.prototype.InterpolantFactoryMethodSmooth=void 0;class lf extends La{}lf.prototype.ValueTypeName="string";lf.prototype.ValueBufferType=Array;lf.prototype.DefaultInterpolation=Hp;lf.prototype.InterpolantFactoryMethodLinear=void 0;lf.prototype.InterpolantFactoryMethodSmooth=void 0;class nm extends La{}nm.prototype.ValueTypeName="vector";class rm{constructor(e,t=-1,n,i=b0){this.name=e,this.tracks=n,this.duration=t,this.blendMode=i,this.uuid=Ps(),this.duration<0&&this.resetDuration()}static parse(e){const t=[],n=e.tracks,i=1/(e.fps||1);for(let a=0,o=n.length;a!==o;++a)t.push(lB(n[a]).scale(i));const s=new this(e.name,e.duration,t,e.blendMode);return s.uuid=e.uuid,s}static toJSON(e){const t=[],n=e.tracks,i={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let s=0,a=n.length;s!==a;++s)t.push(La.toJSON(n[s]));return i}static CreateFromMorphTargetSequence(e,t,n,i){const s=t.length,a=[];for(let o=0;o<s;o++){let u=[],h=[];u.push((o+s-1)%s,o,(o+1)%s),h.push(0,1,0);const p=DA(u);u=Fx(u,1,p),h=Fx(h,1,p),!i&&u[0]===0&&(u.push(s),h.push(h[0])),a.push(new tm(".morphTargetInfluences["+t[o].name+"]",u,h).scale(1/n))}return new this(e,-1,a)}static findByName(e,t){let n=e;if(!Array.isArray(e)){const i=e;n=i.geometry&&i.geometry.animations||i.animations}for(let i=0;i<n.length;i++)if(n[i].name===t)return n[i];return null}static CreateClipsFromMorphTargetSequences(e,t,n){const i={},s=/^([\w-]*?)([\d]+)$/;for(let o=0,u=e.length;o<u;o++){const h=e[o],p=h.name.match(s);if(p&&p.length>1){const m=p[1];let y=i[m];y||(i[m]=y=[]),y.push(h)}}const a=[];for(const o in i)a.push(this.CreateFromMorphTargetSequence(o,i[o],t,n));return a}static parseAnimation(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(m,y,v,S,T){if(v.length!==0){const E=[],w=[];JS(v,E,w,S),E.length!==0&&T.push(new m(y,E,w))}},i=[],s=e.name||"default",a=e.fps||30,o=e.blendMode;let u=e.length||-1;const h=e.hierarchy||[];for(let m=0;m<h.length;m++){const y=h[m].keys;if(!(!y||y.length===0))if(y[0].morphTargets){const v={};let S;for(S=0;S<y.length;S++)if(y[S].morphTargets)for(let T=0;T<y[S].morphTargets.length;T++)v[y[S].morphTargets[T]]=-1;for(const T in v){const E=[],w=[];for(let C=0;C!==y[S].morphTargets.length;++C){const A=y[S];E.push(A.time),w.push(A.morphTarget===T?1:0)}i.push(new tm(".morphTargetInfluence["+T+"]",E,w))}u=v.length*a}else{const v=".bones["+t[m].name+"]";n(nm,v+".position",y,"pos",i),n(ud,v+".quaternion",y,"rot",i),n(nm,v+".scale",y,"scl",i)}}return i.length===0?null:new this(s,u,i,o)}resetDuration(){const e=this.tracks;let t=0;for(let n=0,i=e.length;n!==i;++n){const s=this.tracks[n];t=Math.max(t,s.times[s.times.length-1])}return this.duration=t,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function oB(r){switch(r.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return tm;case"vector":case"vector2":case"vector3":case"vector4":return nm;case"color":return e1;case"quaternion":return ud;case"bool":case"boolean":return of;case"string":return lf}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+r)}function lB(r){if(r.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=oB(r.type);if(r.times===void 0){const t=[],n=[];JS(r.keys,t,n,"value"),r.times=t,r.values=n}return e.parse!==void 0?e.parse(r):new e(r.name,r.times,r.values,r.interpolation)}const Yc={enabled:!1,files:{},add:function(r,e){this.enabled!==!1&&(this.files[r]=e)},get:function(r){if(this.enabled!==!1)return this.files[r]},remove:function(r){delete this.files[r]},clear:function(){this.files={}}};class t1{constructor(e,t,n){const i=this;let s=!1,a=0,o=0,u;const h=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=n,this.itemStart=function(p){o++,s===!1&&i.onStart!==void 0&&i.onStart(p,a,o),s=!0},this.itemEnd=function(p){a++,i.onProgress!==void 0&&i.onProgress(p,a,o),a===o&&(s=!1,i.onLoad!==void 0&&i.onLoad())},this.itemError=function(p){i.onError!==void 0&&i.onError(p)},this.resolveURL=function(p){return u?u(p):p},this.setURLModifier=function(p){return u=p,this},this.addHandler=function(p,m){return h.push(p,m),this},this.removeHandler=function(p){const m=h.indexOf(p);return m!==-1&&h.splice(m,2),this},this.getHandler=function(p){for(let m=0,y=h.length;m<y;m+=2){const v=h[m],S=h[m+1];if(v.global&&(v.lastIndex=0),v.test(p))return S}return null}}}const zA=new t1;class ms{constructor(e){this.manager=e!==void 0?e:zA,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){const n=this;return new Promise(function(i,s){n.load(e,i,t,s)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}ms.DEFAULT_MATERIAL_NAME="__DEFAULT";const Yo={};class uB extends Error{constructor(e,t){super(e),this.response=t}}class cl extends ms{constructor(e){super(e)}load(e,t,n,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=Yc.get(e);if(s!==void 0)return this.manager.itemStart(e),setTimeout(()=>{t&&t(s),this.manager.itemEnd(e)},0),s;if(Yo[e]!==void 0){Yo[e].push({onLoad:t,onProgress:n,onError:i});return}Yo[e]=[],Yo[e].push({onLoad:t,onProgress:n,onError:i});const a=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),o=this.mimeType,u=this.responseType;fetch(a).then(h=>{if(h.status===200||h.status===0){if(h.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||h.body===void 0||h.body.getReader===void 0)return h;const p=Yo[e],m=h.body.getReader(),y=h.headers.get("Content-Length")||h.headers.get("X-File-Size"),v=y?parseInt(y):0,S=v!==0;let T=0;const E=new ReadableStream({start(w){C();function C(){m.read().then(({done:A,value:I})=>{if(A)w.close();else{T+=I.byteLength;const F=new ProgressEvent("progress",{lengthComputable:S,loaded:T,total:v});for(let U=0,V=p.length;U<V;U++){const G=p[U];G.onProgress&&G.onProgress(F)}w.enqueue(I),C()}})}}});return new Response(E)}else throw new uB(`fetch for "${h.url}" responded with ${h.status}: ${h.statusText}`,h)}).then(h=>{switch(u){case"arraybuffer":return h.arrayBuffer();case"blob":return h.blob();case"document":return h.text().then(p=>new DOMParser().parseFromString(p,o));case"json":return h.json();default:if(o===void 0)return h.text();{const m=/charset="?([^;"\s]*)"?/i.exec(o),y=m&&m[1]?m[1].toLowerCase():void 0,v=new TextDecoder(y);return h.arrayBuffer().then(S=>v.decode(S))}}}).then(h=>{Yc.add(e,h);const p=Yo[e];delete Yo[e];for(let m=0,y=p.length;m<y;m++){const v=p[m];v.onLoad&&v.onLoad(h)}}).catch(h=>{const p=Yo[e];if(p===void 0)throw this.manager.itemError(e),h;delete Yo[e];for(let m=0,y=p.length;m<y;m++){const v=p[m];v.onError&&v.onError(h)}this.manager.itemError(e)}).finally(()=>{this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class cB extends ms{constructor(e){super(e)}load(e,t,n,i){const s=this,a=new cl(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(o){try{t(s.parse(JSON.parse(o)))}catch(u){i?i(u):console.error(u),s.manager.itemError(e)}},n,i)}parse(e){const t=[];for(let n=0;n<e.length;n++){const i=rm.parse(e[n]);t.push(i)}return t}}class fB extends ms{constructor(e){super(e)}load(e,t,n,i){const s=this,a=[],o=new L0,u=new cl(this.manager);u.setPath(this.path),u.setResponseType("arraybuffer"),u.setRequestHeader(this.requestHeader),u.setWithCredentials(s.withCredentials);let h=0;function p(m){u.load(e[m],function(y){const v=s.parse(y,!0);a[m]={width:v.width,height:v.height,format:v.format,mipmaps:v.mipmaps},h+=1,h===6&&(v.mipmapCount===1&&(o.minFilter=wr),o.image=a,o.format=v.format,o.needsUpdate=!0,t&&t(o))},n,i)}if(Array.isArray(e))for(let m=0,y=e.length;m<y;++m)p(m);else u.load(e,function(m){const y=s.parse(m,!0);if(y.isCubemap){const v=y.mipmaps.length/y.mipmapCount;for(let S=0;S<v;S++){a[S]={mipmaps:[]};for(let T=0;T<y.mipmapCount;T++)a[S].mipmaps.push(y.mipmaps[S*y.mipmapCount+T]),a[S].format=y.format,a[S].width=y.width,a[S].height=y.height}o.image=a}else o.image.width=y.width,o.image.height=y.height,o.mipmaps=y.mipmaps;y.mipmapCount===1&&(o.minFilter=wr),o.format=y.format,o.needsUpdate=!0,t&&t(o)},n,i);return o}}class im extends ms{constructor(e){super(e)}load(e,t,n,i){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=this,a=Yc.get(e);if(a!==void 0)return s.manager.itemStart(e),setTimeout(function(){t&&t(a),s.manager.itemEnd(e)},0),a;const o=Yp("img");function u(){p(),Yc.add(e,this),t&&t(this),s.manager.itemEnd(e)}function h(m){p(),i&&i(m),s.manager.itemError(e),s.manager.itemEnd(e)}function p(){o.removeEventListener("load",u,!1),o.removeEventListener("error",h,!1)}return o.addEventListener("load",u,!1),o.addEventListener("error",h,!1),e.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(o.crossOrigin=this.crossOrigin),s.manager.itemStart(e),o.src=e,o}}class hB extends ms{constructor(e){super(e)}load(e,t,n,i){const s=new Em;s.colorSpace=Hr;const a=new im(this.manager);a.setCrossOrigin(this.crossOrigin),a.setPath(this.path);let o=0;function u(h){a.load(e[h],function(p){s.images[h]=p,o++,o===6&&(s.needsUpdate=!0,t&&t(s))},void 0,i)}for(let h=0;h<e.length;++h)u(h);return s}}class dB extends ms{constructor(e){super(e)}load(e,t,n,i){const s=this,a=new Hh,o=new cl(this.manager);return o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setPath(this.path),o.setWithCredentials(s.withCredentials),o.load(e,function(u){let h;try{h=s.parse(u)}catch(p){if(i!==void 0)i(p);else{console.error(p);return}}h.image!==void 0?a.image=h.image:h.data!==void 0&&(a.image.width=h.width,a.image.height=h.height,a.image.data=h.data),a.wrapS=h.wrapS!==void 0?h.wrapS:Mi,a.wrapT=h.wrapT!==void 0?h.wrapT:Mi,a.magFilter=h.magFilter!==void 0?h.magFilter:wr,a.minFilter=h.minFilter!==void 0?h.minFilter:wr,a.anisotropy=h.anisotropy!==void 0?h.anisotropy:1,h.colorSpace!==void 0?a.colorSpace=h.colorSpace:h.encoding!==void 0&&(a.encoding=h.encoding),h.flipY!==void 0&&(a.flipY=h.flipY),h.format!==void 0&&(a.format=h.format),h.type!==void 0&&(a.type=h.type),h.mipmaps!==void 0&&(a.mipmaps=h.mipmaps,a.minFilter=pu),h.mipmapCount===1&&(a.minFilter=wr),h.generateMipmaps!==void 0&&(a.generateMipmaps=h.generateMipmaps),a.needsUpdate=!0,t&&t(a,h)},n,i),a}}class pB extends ms{constructor(e){super(e)}load(e,t,n,i){const s=new br,a=new im(this.manager);return a.setCrossOrigin(this.crossOrigin),a.setPath(this.path),a.load(e,function(o){s.image=o,s.needsUpdate=!0,t!==void 0&&t(s)},n,i),s}}class Tu extends Sn{constructor(e,t=1){super(),this.isLight=!0,this.type="Light",this.color=new yt(e),this.intensity=t}dispose(){}copy(e,t){return super.copy(e,t),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),t}}class BA extends Tu{constructor(e,t,n){super(e,n),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(Sn.DEFAULT_UP),this.updateMatrix(),this.groundColor=new yt(t)}copy(e,t){return super.copy(e,t),this.groundColor.copy(e.groundColor),this}}const T_=new Jt,vb=new X,_b=new X;class n1{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Pe(512,512),this.map=null,this.mapPass=null,this.matrix=new Jt,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new A0,this._frameExtents=new Pe(1,1),this._viewportCount=1,this._viewports=[new Cn(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,n=this.matrix;vb.setFromMatrixPosition(e.matrixWorld),t.position.copy(vb),_b.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(_b),t.updateMatrixWorld(),T_.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(T_),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(T_)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class mB extends n1{constructor(){super(new Er(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(e){const t=this.camera,n=Xh*2*e.angle*this.focus,i=this.mapSize.width/this.mapSize.height,s=e.distance||t.far;(n!==t.fov||i!==t.aspect||s!==t.far)&&(t.fov=n,t.aspect=i,t.far=s,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}class VA extends Tu{constructor(e,t,n=0,i=Math.PI/3,s=0,a=2){super(e,t),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(Sn.DEFAULT_UP),this.updateMatrix(),this.target=new Sn,this.distance=n,this.angle=i,this.penumbra=s,this.decay=a,this.map=null,this.shadow=new mB}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}const xb=new Jt,_p=new X,M_=new X;class gB extends n1{constructor(){super(new Er(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new Pe(4,2),this._viewportCount=6,this._viewports=[new Cn(2,1,1,1),new Cn(0,1,1,1),new Cn(3,1,1,1),new Cn(1,1,1,1),new Cn(3,0,1,1),new Cn(1,0,1,1)],this._cubeDirections=[new X(1,0,0),new X(-1,0,0),new X(0,0,1),new X(0,0,-1),new X(0,1,0),new X(0,-1,0)],this._cubeUps=[new X(0,1,0),new X(0,1,0),new X(0,1,0),new X(0,1,0),new X(0,0,1),new X(0,0,-1)]}updateMatrices(e,t=0){const n=this.camera,i=this.matrix,s=e.distance||n.far;s!==n.far&&(n.far=s,n.updateProjectionMatrix()),_p.setFromMatrixPosition(e.matrixWorld),n.position.copy(_p),M_.copy(n.position),M_.add(this._cubeDirections[t]),n.up.copy(this._cubeUps[t]),n.lookAt(M_),n.updateMatrixWorld(),i.makeTranslation(-_p.x,-_p.y,-_p.z),xb.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(xb)}}class HA extends Tu{constructor(e,t,n=0,i=2){super(e,t),this.isPointLight=!0,this.type="PointLight",this.distance=n,this.decay=i,this.shadow=new gB}get power(){return this.intensity*4*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}class yB extends n1{constructor(){super(new fu(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class $A extends Tu{constructor(e,t){super(e,t),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(Sn.DEFAULT_UP),this.updateMatrix(),this.target=new Sn,this.shadow=new yB}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}class GA extends Tu{constructor(e,t){super(e,t),this.isAmbientLight=!0,this.type="AmbientLight"}}class WA extends Tu{constructor(e,t,n=10,i=10){super(e,t),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=n,this.height=i}get power(){return this.intensity*this.width*this.height*Math.PI}set power(e){this.intensity=e/(this.width*this.height*Math.PI)}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this}toJSON(e){const t=super.toJSON(e);return t.object.width=this.width,t.object.height=this.height,t}}class jA{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new X)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const n=e.x,i=e.y,s=e.z,a=this.coefficients;return t.copy(a[0]).multiplyScalar(.282095),t.addScaledVector(a[1],.488603*i),t.addScaledVector(a[2],.488603*s),t.addScaledVector(a[3],.488603*n),t.addScaledVector(a[4],1.092548*(n*i)),t.addScaledVector(a[5],1.092548*(i*s)),t.addScaledVector(a[6],.315392*(3*s*s-1)),t.addScaledVector(a[7],1.092548*(n*s)),t.addScaledVector(a[8],.546274*(n*n-i*i)),t}getIrradianceAt(e,t){const n=e.x,i=e.y,s=e.z,a=this.coefficients;return t.copy(a[0]).multiplyScalar(.886227),t.addScaledVector(a[1],2*.511664*i),t.addScaledVector(a[2],2*.511664*s),t.addScaledVector(a[3],2*.511664*n),t.addScaledVector(a[4],2*.429043*n*i),t.addScaledVector(a[5],2*.429043*i*s),t.addScaledVector(a[6],.743125*s*s-.247708),t.addScaledVector(a[7],2*.429043*n*s),t.addScaledVector(a[8],.429043*(n*n-i*i)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(e.coefficients[n],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let n=0;n<9;n++)this.coefficients[n].lerp(e.coefficients[n],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,t=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].fromArray(e,t+i*3);return this}toArray(e=[],t=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].toArray(e,t+i*3);return e}static getBasisAt(e,t){const n=e.x,i=e.y,s=e.z;t[0]=.282095,t[1]=.488603*i,t[2]=.488603*s,t[3]=.488603*n,t[4]=1.092548*n*i,t[5]=1.092548*i*s,t[6]=.315392*(3*s*s-1),t[7]=1.092548*n*s,t[8]=.546274*(n*n-i*i)}}class qA extends Tu{constructor(e=new jA,t=1){super(void 0,t),this.isLightProbe=!0,this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){const t=super.toJSON(e);return t.object.sh=this.sh.toArray(),t}}class X0 extends ms{constructor(e){super(e),this.textures={}}load(e,t,n,i){const s=this,a=new cl(s.manager);a.setPath(s.path),a.setRequestHeader(s.requestHeader),a.setWithCredentials(s.withCredentials),a.load(e,function(o){try{t(s.parse(JSON.parse(o)))}catch(u){i?i(u):console.error(u),s.manager.itemError(e)}},n,i)}parse(e){const t=this.textures;function n(s){return t[s]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",s),t[s]}const i=X0.createMaterialFromType(e.type);if(e.uuid!==void 0&&(i.uuid=e.uuid),e.name!==void 0&&(i.name=e.name),e.color!==void 0&&i.color!==void 0&&i.color.setHex(e.color),e.roughness!==void 0&&(i.roughness=e.roughness),e.metalness!==void 0&&(i.metalness=e.metalness),e.sheen!==void 0&&(i.sheen=e.sheen),e.sheenColor!==void 0&&(i.sheenColor=new yt().setHex(e.sheenColor)),e.sheenRoughness!==void 0&&(i.sheenRoughness=e.sheenRoughness),e.emissive!==void 0&&i.emissive!==void 0&&i.emissive.setHex(e.emissive),e.specular!==void 0&&i.specular!==void 0&&i.specular.setHex(e.specular),e.specularIntensity!==void 0&&(i.specularIntensity=e.specularIntensity),e.specularColor!==void 0&&i.specularColor!==void 0&&i.specularColor.setHex(e.specularColor),e.shininess!==void 0&&(i.shininess=e.shininess),e.clearcoat!==void 0&&(i.clearcoat=e.clearcoat),e.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=e.clearcoatRoughness),e.iridescence!==void 0&&(i.iridescence=e.iridescence),e.iridescenceIOR!==void 0&&(i.iridescenceIOR=e.iridescenceIOR),e.iridescenceThicknessRange!==void 0&&(i.iridescenceThicknessRange=e.iridescenceThicknessRange),e.transmission!==void 0&&(i.transmission=e.transmission),e.thickness!==void 0&&(i.thickness=e.thickness),e.attenuationDistance!==void 0&&(i.attenuationDistance=e.attenuationDistance),e.attenuationColor!==void 0&&i.attenuationColor!==void 0&&i.attenuationColor.setHex(e.attenuationColor),e.anisotropy!==void 0&&(i.anisotropy=e.anisotropy),e.anisotropyRotation!==void 0&&(i.anisotropyRotation=e.anisotropyRotation),e.fog!==void 0&&(i.fog=e.fog),e.flatShading!==void 0&&(i.flatShading=e.flatShading),e.blending!==void 0&&(i.blending=e.blending),e.combine!==void 0&&(i.combine=e.combine),e.side!==void 0&&(i.side=e.side),e.shadowSide!==void 0&&(i.shadowSide=e.shadowSide),e.opacity!==void 0&&(i.opacity=e.opacity),e.transparent!==void 0&&(i.transparent=e.transparent),e.alphaTest!==void 0&&(i.alphaTest=e.alphaTest),e.alphaHash!==void 0&&(i.alphaHash=e.alphaHash),e.depthFunc!==void 0&&(i.depthFunc=e.depthFunc),e.depthTest!==void 0&&(i.depthTest=e.depthTest),e.depthWrite!==void 0&&(i.depthWrite=e.depthWrite),e.colorWrite!==void 0&&(i.colorWrite=e.colorWrite),e.blendSrc!==void 0&&(i.blendSrc=e.blendSrc),e.blendDst!==void 0&&(i.blendDst=e.blendDst),e.blendEquation!==void 0&&(i.blendEquation=e.blendEquation),e.blendSrcAlpha!==void 0&&(i.blendSrcAlpha=e.blendSrcAlpha),e.blendDstAlpha!==void 0&&(i.blendDstAlpha=e.blendDstAlpha),e.blendEquationAlpha!==void 0&&(i.blendEquationAlpha=e.blendEquationAlpha),e.blendColor!==void 0&&i.blendColor!==void 0&&i.blendColor.setHex(e.blendColor),e.blendAlpha!==void 0&&(i.blendAlpha=e.blendAlpha),e.stencilWriteMask!==void 0&&(i.stencilWriteMask=e.stencilWriteMask),e.stencilFunc!==void 0&&(i.stencilFunc=e.stencilFunc),e.stencilRef!==void 0&&(i.stencilRef=e.stencilRef),e.stencilFuncMask!==void 0&&(i.stencilFuncMask=e.stencilFuncMask),e.stencilFail!==void 0&&(i.stencilFail=e.stencilFail),e.stencilZFail!==void 0&&(i.stencilZFail=e.stencilZFail),e.stencilZPass!==void 0&&(i.stencilZPass=e.stencilZPass),e.stencilWrite!==void 0&&(i.stencilWrite=e.stencilWrite),e.wireframe!==void 0&&(i.wireframe=e.wireframe),e.wireframeLinewidth!==void 0&&(i.wireframeLinewidth=e.wireframeLinewidth),e.wireframeLinecap!==void 0&&(i.wireframeLinecap=e.wireframeLinecap),e.wireframeLinejoin!==void 0&&(i.wireframeLinejoin=e.wireframeLinejoin),e.rotation!==void 0&&(i.rotation=e.rotation),e.linewidth!==void 0&&(i.linewidth=e.linewidth),e.dashSize!==void 0&&(i.dashSize=e.dashSize),e.gapSize!==void 0&&(i.gapSize=e.gapSize),e.scale!==void 0&&(i.scale=e.scale),e.polygonOffset!==void 0&&(i.polygonOffset=e.polygonOffset),e.polygonOffsetFactor!==void 0&&(i.polygonOffsetFactor=e.polygonOffsetFactor),e.polygonOffsetUnits!==void 0&&(i.polygonOffsetUnits=e.polygonOffsetUnits),e.dithering!==void 0&&(i.dithering=e.dithering),e.alphaToCoverage!==void 0&&(i.alphaToCoverage=e.alphaToCoverage),e.premultipliedAlpha!==void 0&&(i.premultipliedAlpha=e.premultipliedAlpha),e.forceSinglePass!==void 0&&(i.forceSinglePass=e.forceSinglePass),e.visible!==void 0&&(i.visible=e.visible),e.toneMapped!==void 0&&(i.toneMapped=e.toneMapped),e.userData!==void 0&&(i.userData=e.userData),e.vertexColors!==void 0&&(typeof e.vertexColors=="number"?i.vertexColors=e.vertexColors>0:i.vertexColors=e.vertexColors),e.uniforms!==void 0)for(const s in e.uniforms){const a=e.uniforms[s];switch(i.uniforms[s]={},a.type){case"t":i.uniforms[s].value=n(a.value);break;case"c":i.uniforms[s].value=new yt().setHex(a.value);break;case"v2":i.uniforms[s].value=new Pe().fromArray(a.value);break;case"v3":i.uniforms[s].value=new X().fromArray(a.value);break;case"v4":i.uniforms[s].value=new Cn().fromArray(a.value);break;case"m3":i.uniforms[s].value=new rn().fromArray(a.value);break;case"m4":i.uniforms[s].value=new Jt().fromArray(a.value);break;default:i.uniforms[s].value=a.value}}if(e.defines!==void 0&&(i.defines=e.defines),e.vertexShader!==void 0&&(i.vertexShader=e.vertexShader),e.fragmentShader!==void 0&&(i.fragmentShader=e.fragmentShader),e.glslVersion!==void 0&&(i.glslVersion=e.glslVersion),e.extensions!==void 0)for(const s in e.extensions)i.extensions[s]=e.extensions[s];if(e.lights!==void 0&&(i.lights=e.lights),e.clipping!==void 0&&(i.clipping=e.clipping),e.size!==void 0&&(i.size=e.size),e.sizeAttenuation!==void 0&&(i.sizeAttenuation=e.sizeAttenuation),e.map!==void 0&&(i.map=n(e.map)),e.matcap!==void 0&&(i.matcap=n(e.matcap)),e.alphaMap!==void 0&&(i.alphaMap=n(e.alphaMap)),e.bumpMap!==void 0&&(i.bumpMap=n(e.bumpMap)),e.bumpScale!==void 0&&(i.bumpScale=e.bumpScale),e.normalMap!==void 0&&(i.normalMap=n(e.normalMap)),e.normalMapType!==void 0&&(i.normalMapType=e.normalMapType),e.normalScale!==void 0){let s=e.normalScale;Array.isArray(s)===!1&&(s=[s,s]),i.normalScale=new Pe().fromArray(s)}return e.displacementMap!==void 0&&(i.displacementMap=n(e.displacementMap)),e.displacementScale!==void 0&&(i.displacementScale=e.displacementScale),e.displacementBias!==void 0&&(i.displacementBias=e.displacementBias),e.roughnessMap!==void 0&&(i.roughnessMap=n(e.roughnessMap)),e.metalnessMap!==void 0&&(i.metalnessMap=n(e.metalnessMap)),e.emissiveMap!==void 0&&(i.emissiveMap=n(e.emissiveMap)),e.emissiveIntensity!==void 0&&(i.emissiveIntensity=e.emissiveIntensity),e.specularMap!==void 0&&(i.specularMap=n(e.specularMap)),e.specularIntensityMap!==void 0&&(i.specularIntensityMap=n(e.specularIntensityMap)),e.specularColorMap!==void 0&&(i.specularColorMap=n(e.specularColorMap)),e.envMap!==void 0&&(i.envMap=n(e.envMap)),e.envMapIntensity!==void 0&&(i.envMapIntensity=e.envMapIntensity),e.reflectivity!==void 0&&(i.reflectivity=e.reflectivity),e.refractionRatio!==void 0&&(i.refractionRatio=e.refractionRatio),e.lightMap!==void 0&&(i.lightMap=n(e.lightMap)),e.lightMapIntensity!==void 0&&(i.lightMapIntensity=e.lightMapIntensity),e.aoMap!==void 0&&(i.aoMap=n(e.aoMap)),e.aoMapIntensity!==void 0&&(i.aoMapIntensity=e.aoMapIntensity),e.gradientMap!==void 0&&(i.gradientMap=n(e.gradientMap)),e.clearcoatMap!==void 0&&(i.clearcoatMap=n(e.clearcoatMap)),e.clearcoatRoughnessMap!==void 0&&(i.clearcoatRoughnessMap=n(e.clearcoatRoughnessMap)),e.clearcoatNormalMap!==void 0&&(i.clearcoatNormalMap=n(e.clearcoatNormalMap)),e.clearcoatNormalScale!==void 0&&(i.clearcoatNormalScale=new Pe().fromArray(e.clearcoatNormalScale)),e.iridescenceMap!==void 0&&(i.iridescenceMap=n(e.iridescenceMap)),e.iridescenceThicknessMap!==void 0&&(i.iridescenceThicknessMap=n(e.iridescenceThicknessMap)),e.transmissionMap!==void 0&&(i.transmissionMap=n(e.transmissionMap)),e.thicknessMap!==void 0&&(i.thicknessMap=n(e.thicknessMap)),e.anisotropyMap!==void 0&&(i.anisotropyMap=n(e.anisotropyMap)),e.sheenColorMap!==void 0&&(i.sheenColorMap=n(e.sheenColorMap)),e.sheenRoughnessMap!==void 0&&(i.sheenRoughnessMap=n(e.sheenRoughnessMap)),i}setTextures(e){return this.textures=e,this}static createMaterialFromType(e){const t={ShadowMaterial:TA,SpriteMaterial:HS,RawShaderMaterial:MA,ShaderMaterial:io,PointsMaterial:GS,MeshPhysicalMaterial:AA,MeshStandardMaterial:ZS,MeshPhongMaterial:NA,MeshToonMaterial:CA,MeshNormalMaterial:RA,MeshLambertMaterial:IA,MeshDepthMaterial:US,MeshDistanceMaterial:zS,MeshBasicMaterial:Eu,MeshMatcapMaterial:PA,LineDashedMaterial:LA,LineBasicMaterial:qi,Material:Ri};return new t[e]}}class Ux{static decodeText(e){if(typeof TextDecoder<"u")return new TextDecoder().decode(e);let t="";for(let n=0,i=e.length;n<i;n++)t+=String.fromCharCode(e[n]);try{return decodeURIComponent(escape(t))}catch{return t}}static extractUrlBase(e){const t=e.lastIndexOf("/");return t===-1?"./":e.slice(0,t+1)}static resolveURL(e,t){return typeof e!="string"||e===""?"":(/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:t+e)}}class XA extends ln{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}toJSON(){const e=super.toJSON();return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}class KA extends ms{constructor(e){super(e)}load(e,t,n,i){const s=this,a=new cl(s.manager);a.setPath(s.path),a.setRequestHeader(s.requestHeader),a.setWithCredentials(s.withCredentials),a.load(e,function(o){try{t(s.parse(JSON.parse(o)))}catch(u){i?i(u):console.error(u),s.manager.itemError(e)}},n,i)}parse(e){const t={},n={};function i(v,S){if(t[S]!==void 0)return t[S];const E=v.interleavedBuffers[S],w=s(v,E.buffer),C=Oh(E.type,w),A=new I0(C,E.stride);return A.uuid=E.uuid,t[S]=A,A}function s(v,S){if(n[S]!==void 0)return n[S];const E=v.arrayBuffers[S],w=new Uint32Array(E).buffer;return n[S]=w,w}const a=e.isInstancedBufferGeometry?new XA:new ln,o=e.data.index;if(o!==void 0){const v=Oh(o.type,o.array);a.setIndex(new Hn(v,1))}const u=e.data.attributes;for(const v in u){const S=u[v];let T;if(S.isInterleavedBufferAttribute){const E=i(e.data,S.data);T=new Xc(E,S.itemSize,S.offset,S.normalized)}else{const E=Oh(S.type,S.array),w=S.isInstancedBufferAttribute?Yh:Hn;T=new w(E,S.itemSize,S.normalized)}S.name!==void 0&&(T.name=S.name),S.usage!==void 0&&T.setUsage(S.usage),S.updateRange!==void 0&&(T.updateRange.offset=S.updateRange.offset,T.updateRange.count=S.updateRange.count),a.setAttribute(v,T)}const h=e.data.morphAttributes;if(h)for(const v in h){const S=h[v],T=[];for(let E=0,w=S.length;E<w;E++){const C=S[E];let A;if(C.isInterleavedBufferAttribute){const I=i(e.data,C.data);A=new Xc(I,C.itemSize,C.offset,C.normalized)}else{const I=Oh(C.type,C.array);A=new Hn(I,C.itemSize,C.normalized)}C.name!==void 0&&(A.name=C.name),T.push(A)}a.morphAttributes[v]=T}e.data.morphTargetsRelative&&(a.morphTargetsRelative=!0);const m=e.data.groups||e.data.drawcalls||e.data.offsets;if(m!==void 0)for(let v=0,S=m.length;v!==S;++v){const T=m[v];a.addGroup(T.start,T.count,T.materialIndex)}const y=e.data.boundingSphere;if(y!==void 0){const v=new X;y.center!==void 0&&v.fromArray(y.center),a.boundingSphere=new Ia(v,y.radius)}return e.name&&(a.name=e.name),e.userData&&(a.userData=e.userData),a}}class vB extends ms{constructor(e){super(e)}load(e,t,n,i){const s=this,a=this.path===""?Ux.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||a;const o=new cl(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(u){let h=null;try{h=JSON.parse(u)}catch(m){i!==void 0&&i(m),console.error("THREE:ObjectLoader: Can't parse "+e+".",m.message);return}const p=h.metadata;if(p===void 0||p.type===void 0||p.type.toLowerCase()==="geometry"){i!==void 0&&i(new Error("THREE.ObjectLoader: Can't load "+e)),console.error("THREE.ObjectLoader: Can't load "+e);return}s.parse(h,t)},n,i)}async loadAsync(e,t){const n=this,i=this.path===""?Ux.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||i;const s=new cl(this.manager);s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials);const a=await s.loadAsync(e,t),o=JSON.parse(a),u=o.metadata;if(u===void 0||u.type===void 0||u.type.toLowerCase()==="geometry")throw new Error("THREE.ObjectLoader: Can't load "+e);return await n.parseAsync(o)}parse(e,t){const n=this.parseAnimations(e.animations),i=this.parseShapes(e.shapes),s=this.parseGeometries(e.geometries,i),a=this.parseImages(e.images,function(){t!==void 0&&t(h)}),o=this.parseTextures(e.textures,a),u=this.parseMaterials(e.materials,o),h=this.parseObject(e.object,s,u,o,n),p=this.parseSkeletons(e.skeletons,h);if(this.bindSkeletons(h,p),t!==void 0){let m=!1;for(const y in a)if(a[y].data instanceof HTMLImageElement){m=!0;break}m===!1&&t(h)}return h}async parseAsync(e){const t=this.parseAnimations(e.animations),n=this.parseShapes(e.shapes),i=this.parseGeometries(e.geometries,n),s=await this.parseImagesAsync(e.images),a=this.parseTextures(e.textures,s),o=this.parseMaterials(e.materials,a),u=this.parseObject(e.object,i,o,a,t),h=this.parseSkeletons(e.skeletons,u);return this.bindSkeletons(u,h),u}parseShapes(e){const t={};if(e!==void 0)for(let n=0,i=e.length;n<i;n++){const s=new $c().fromJSON(e[n]);t[s.uuid]=s}return t}parseSkeletons(e,t){const n={},i={};if(t.traverse(function(s){s.isBone&&(i[s.uuid]=s)}),e!==void 0)for(let s=0,a=e.length;s<a;s++){const o=new P0().fromJSON(e[s],i);n[o.uuid]=o}return n}parseGeometries(e,t){const n={};if(e!==void 0){const i=new KA;for(let s=0,a=e.length;s<a;s++){let o;const u=e[s];switch(u.type){case"BufferGeometry":case"InstancedBufferGeometry":o=i.parse(u);break;default:u.type in yb?o=yb[u.type].fromJSON(u,t):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${u.type}"`)}o.uuid=u.uuid,u.name!==void 0&&(o.name=u.name),u.userData!==void 0&&(o.userData=u.userData),n[u.uuid]=o}}return n}parseMaterials(e,t){const n={},i={};if(e!==void 0){const s=new X0;s.setTextures(t);for(let a=0,o=e.length;a<o;a++){const u=e[a];n[u.uuid]===void 0&&(n[u.uuid]=s.parse(u)),i[u.uuid]=n[u.uuid]}}return i}parseAnimations(e){const t={};if(e!==void 0)for(let n=0;n<e.length;n++){const i=e[n],s=rm.parse(i);t[s.uuid]=s}return t}parseImages(e,t){const n=this,i={};let s;function a(u){return n.manager.itemStart(u),s.load(u,function(){n.manager.itemEnd(u)},void 0,function(){n.manager.itemError(u),n.manager.itemEnd(u)})}function o(u){if(typeof u=="string"){const h=u,p=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(h)?h:n.resourcePath+h;return a(p)}else return u.data?{data:Oh(u.type,u.data),width:u.width,height:u.height}:null}if(e!==void 0&&e.length>0){const u=new t1(t);s=new im(u),s.setCrossOrigin(this.crossOrigin);for(let h=0,p=e.length;h<p;h++){const m=e[h],y=m.url;if(Array.isArray(y)){const v=[];for(let S=0,T=y.length;S<T;S++){const E=y[S],w=o(E);w!==null&&(w instanceof HTMLImageElement?v.push(w):v.push(new Hh(w.data,w.width,w.height)))}i[m.uuid]=new Fc(v)}else{const v=o(m.url);i[m.uuid]=new Fc(v)}}}return i}async parseImagesAsync(e){const t=this,n={};let i;async function s(a){if(typeof a=="string"){const o=a,u=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(o)?o:t.resourcePath+o;return await i.loadAsync(u)}else return a.data?{data:Oh(a.type,a.data),width:a.width,height:a.height}:null}if(e!==void 0&&e.length>0){i=new im(this.manager),i.setCrossOrigin(this.crossOrigin);for(let a=0,o=e.length;a<o;a++){const u=e[a],h=u.url;if(Array.isArray(h)){const p=[];for(let m=0,y=h.length;m<y;m++){const v=h[m],S=await s(v);S!==null&&(S instanceof HTMLImageElement?p.push(S):p.push(new Hh(S.data,S.width,S.height)))}n[u.uuid]=new Fc(p)}else{const p=await s(u.url);n[u.uuid]=new Fc(p)}}}return n}parseTextures(e,t){function n(s,a){return typeof s=="number"?s:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",s),a[s])}const i={};if(e!==void 0)for(let s=0,a=e.length;s<a;s++){const o=e[s];o.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',o.uuid),t[o.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",o.image);const u=t[o.image],h=u.data;let p;Array.isArray(h)?(p=new Em,h.length===6&&(p.needsUpdate=!0)):(h&&h.data?p=new Hh:p=new br,h&&(p.needsUpdate=!0)),p.source=u,p.uuid=o.uuid,o.name!==void 0&&(p.name=o.name),o.mapping!==void 0&&(p.mapping=n(o.mapping,_B)),o.channel!==void 0&&(p.channel=o.channel),o.offset!==void 0&&p.offset.fromArray(o.offset),o.repeat!==void 0&&p.repeat.fromArray(o.repeat),o.center!==void 0&&p.center.fromArray(o.center),o.rotation!==void 0&&(p.rotation=o.rotation),o.wrap!==void 0&&(p.wrapS=n(o.wrap[0],Sb),p.wrapT=n(o.wrap[1],Sb)),o.format!==void 0&&(p.format=o.format),o.internalFormat!==void 0&&(p.internalFormat=o.internalFormat),o.type!==void 0&&(p.type=o.type),o.colorSpace!==void 0&&(p.colorSpace=o.colorSpace),o.encoding!==void 0&&(p.encoding=o.encoding),o.minFilter!==void 0&&(p.minFilter=n(o.minFilter,wb)),o.magFilter!==void 0&&(p.magFilter=n(o.magFilter,wb)),o.anisotropy!==void 0&&(p.anisotropy=o.anisotropy),o.flipY!==void 0&&(p.flipY=o.flipY),o.generateMipmaps!==void 0&&(p.generateMipmaps=o.generateMipmaps),o.premultiplyAlpha!==void 0&&(p.premultiplyAlpha=o.premultiplyAlpha),o.unpackAlignment!==void 0&&(p.unpackAlignment=o.unpackAlignment),o.compareFunction!==void 0&&(p.compareFunction=o.compareFunction),o.userData!==void 0&&(p.userData=o.userData),i[o.uuid]=p}return i}parseObject(e,t,n,i,s){let a;function o(y){return t[y]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",y),t[y]}function u(y){if(y!==void 0){if(Array.isArray(y)){const v=[];for(let S=0,T=y.length;S<T;S++){const E=y[S];n[E]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",E),v.push(n[E])}return v}return n[y]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",y),n[y]}}function h(y){return i[y]===void 0&&console.warn("THREE.ObjectLoader: Undefined texture",y),i[y]}let p,m;switch(e.type){case"Scene":a=new VS,e.background!==void 0&&(Number.isInteger(e.background)?a.background=new yt(e.background):a.background=h(e.background)),e.environment!==void 0&&(a.environment=h(e.environment)),e.fog!==void 0&&(e.fog.type==="Fog"?a.fog=new R0(e.fog.color,e.fog.near,e.fog.far):e.fog.type==="FogExp2"&&(a.fog=new C0(e.fog.color,e.fog.density)),e.fog.name!==""&&(a.fog.name=e.fog.name)),e.backgroundBlurriness!==void 0&&(a.backgroundBlurriness=e.backgroundBlurriness),e.backgroundIntensity!==void 0&&(a.backgroundIntensity=e.backgroundIntensity);break;case"PerspectiveCamera":a=new Er(e.fov,e.aspect,e.near,e.far),e.focus!==void 0&&(a.focus=e.focus),e.zoom!==void 0&&(a.zoom=e.zoom),e.filmGauge!==void 0&&(a.filmGauge=e.filmGauge),e.filmOffset!==void 0&&(a.filmOffset=e.filmOffset),e.view!==void 0&&(a.view=Object.assign({},e.view));break;case"OrthographicCamera":a=new fu(e.left,e.right,e.top,e.bottom,e.near,e.far),e.zoom!==void 0&&(a.zoom=e.zoom),e.view!==void 0&&(a.view=Object.assign({},e.view));break;case"AmbientLight":a=new GA(e.color,e.intensity);break;case"DirectionalLight":a=new $A(e.color,e.intensity);break;case"PointLight":a=new HA(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":a=new WA(e.color,e.intensity,e.width,e.height);break;case"SpotLight":a=new VA(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);break;case"HemisphereLight":a=new BA(e.color,e.groundColor,e.intensity);break;case"LightProbe":a=new qA().fromJSON(e);break;case"SkinnedMesh":p=o(e.geometry),m=u(e.material),a=new fA(p,m),e.bindMode!==void 0&&(a.bindMode=e.bindMode),e.bindMatrix!==void 0&&a.bindMatrix.fromArray(e.bindMatrix),e.skeleton!==void 0&&(a.skeleton=e.skeleton);break;case"Mesh":p=o(e.geometry),m=u(e.material),a=new hi(p,m);break;case"InstancedMesh":p=o(e.geometry),m=u(e.material);const y=e.count,v=e.instanceMatrix,S=e.instanceColor;a=new hA(p,m,y),a.instanceMatrix=new Yh(new Float32Array(v.array),16),S!==void 0&&(a.instanceColor=new Yh(new Float32Array(S.array),S.itemSize));break;case"LOD":a=new cA;break;case"Line":a=new mu(o(e.geometry),u(e.material));break;case"LineLoop":a=new dA(o(e.geometry),u(e.material));break;case"LineSegments":a=new fo(o(e.geometry),u(e.material));break;case"PointCloud":case"Points":a=new pA(o(e.geometry),u(e.material));break;case"Sprite":a=new uA(u(e.material));break;case"Group":a=new Uh;break;case"Bone":a=new $S;break;default:a=new Sn}if(a.uuid=e.uuid,e.name!==void 0&&(a.name=e.name),e.matrix!==void 0?(a.matrix.fromArray(e.matrix),e.matrixAutoUpdate!==void 0&&(a.matrixAutoUpdate=e.matrixAutoUpdate),a.matrixAutoUpdate&&a.matrix.decompose(a.position,a.quaternion,a.scale)):(e.position!==void 0&&a.position.fromArray(e.position),e.rotation!==void 0&&a.rotation.fromArray(e.rotation),e.quaternion!==void 0&&a.quaternion.fromArray(e.quaternion),e.scale!==void 0&&a.scale.fromArray(e.scale)),e.up!==void 0&&a.up.fromArray(e.up),e.castShadow!==void 0&&(a.castShadow=e.castShadow),e.receiveShadow!==void 0&&(a.receiveShadow=e.receiveShadow),e.shadow&&(e.shadow.bias!==void 0&&(a.shadow.bias=e.shadow.bias),e.shadow.normalBias!==void 0&&(a.shadow.normalBias=e.shadow.normalBias),e.shadow.radius!==void 0&&(a.shadow.radius=e.shadow.radius),e.shadow.mapSize!==void 0&&a.shadow.mapSize.fromArray(e.shadow.mapSize),e.shadow.camera!==void 0&&(a.shadow.camera=this.parseObject(e.shadow.camera))),e.visible!==void 0&&(a.visible=e.visible),e.frustumCulled!==void 0&&(a.frustumCulled=e.frustumCulled),e.renderOrder!==void 0&&(a.renderOrder=e.renderOrder),e.userData!==void 0&&(a.userData=e.userData),e.layers!==void 0&&(a.layers.mask=e.layers),e.children!==void 0){const y=e.children;for(let v=0;v<y.length;v++)a.add(this.parseObject(y[v],t,n,i,s))}if(e.animations!==void 0){const y=e.animations;for(let v=0;v<y.length;v++){const S=y[v];a.animations.push(s[S])}}if(e.type==="LOD"){e.autoUpdate!==void 0&&(a.autoUpdate=e.autoUpdate);const y=e.levels;for(let v=0;v<y.length;v++){const S=y[v],T=a.getObjectByProperty("uuid",S.object);T!==void 0&&a.addLevel(T,S.distance,S.hysteresis)}}return a}bindSkeletons(e,t){Object.keys(t).length!==0&&e.traverse(function(n){if(n.isSkinnedMesh===!0&&n.skeleton!==void 0){const i=t[n.skeleton];i===void 0?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",n.skeleton):n.bind(i,n.bindMatrix)}})}}const _B={UVMapping:w0,CubeReflectionMapping:ul,CubeRefractionMapping:du,EquirectangularReflectionMapping:Up,EquirectangularRefractionMapping:zp,CubeUVReflectionMapping:ad},Sb={RepeatWrapping:Bp,ClampToEdgeWrapping:Mi,MirroredRepeatWrapping:Vp},wb={NearestFilter:Sr,NearestMipmapNearestFilter:Qy,NearestMipmapLinearFilter:Rp,LinearFilter:wr,LinearMipmapNearestFilter:ES,LinearMipmapLinearFilter:pu};class xB extends ms{constructor(e){super(e),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,t,n,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=this,a=Yc.get(e);if(a!==void 0)return s.manager.itemStart(e),setTimeout(function(){t&&t(a),s.manager.itemEnd(e)},0),a;const o={};o.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",o.headers=this.requestHeader,fetch(e,o).then(function(u){return u.blob()}).then(function(u){return createImageBitmap(u,Object.assign(s.options,{colorSpaceConversion:"none"}))}).then(function(u){Yc.add(e,u),t&&t(u),s.manager.itemEnd(e)}).catch(function(u){i&&i(u),s.manager.itemError(e),s.manager.itemEnd(e)}),s.manager.itemStart(e)}}let _y;class r1{static getContext(){return _y===void 0&&(_y=new(window.AudioContext||window.webkitAudioContext)),_y}static setContext(e){_y=e}}class SB extends ms{constructor(e){super(e)}load(e,t,n,i){const s=this,a=new cl(this.manager);a.setResponseType("arraybuffer"),a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(u){try{const h=u.slice(0);r1.getContext().decodeAudioData(h,function(m){t(m)},o)}catch(h){o(h)}},n,i);function o(u){i?i(u):console.error(u),s.manager.itemError(e)}}}const Eb=new Jt,bb=new Jt,xc=new Jt;class wB{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new Er,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new Er,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(e){const t=this._cache;if(t.focus!==e.focus||t.fov!==e.fov||t.aspect!==e.aspect*this.aspect||t.near!==e.near||t.far!==e.far||t.zoom!==e.zoom||t.eyeSep!==this.eyeSep){t.focus=e.focus,t.fov=e.fov,t.aspect=e.aspect*this.aspect,t.near=e.near,t.far=e.far,t.zoom=e.zoom,t.eyeSep=this.eyeSep,xc.copy(e.projectionMatrix);const i=t.eyeSep/2,s=i*t.near/t.focus,a=t.near*Math.tan(Vc*t.fov*.5)/t.zoom;let o,u;bb.elements[12]=-i,Eb.elements[12]=i,o=-a*t.aspect+s,u=a*t.aspect+s,xc.elements[0]=2*t.near/(u-o),xc.elements[8]=(u+o)/(u-o),this.cameraL.projectionMatrix.copy(xc),o=-a*t.aspect-s,u=a*t.aspect-s,xc.elements[0]=2*t.near/(u-o),xc.elements[8]=(u+o)/(u-o),this.cameraR.projectionMatrix.copy(xc)}this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(bb),this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Eb)}}class i1{constructor(e=!0){this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=Tb(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=Tb();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}function Tb(){return(typeof performance>"u"?Date:performance).now()}const Sc=new X,Mb=new Ni,EB=new X,wc=new X;class bB extends Sn{constructor(){super(),this.type="AudioListener",this.context=r1.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new i1}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(e){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=e,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}updateMatrixWorld(e){super.updateMatrixWorld(e);const t=this.context.listener,n=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(Sc,Mb,EB),wc.set(0,0,-1).applyQuaternion(Mb),t.positionX){const i=this.context.currentTime+this.timeDelta;t.positionX.linearRampToValueAtTime(Sc.x,i),t.positionY.linearRampToValueAtTime(Sc.y,i),t.positionZ.linearRampToValueAtTime(Sc.z,i),t.forwardX.linearRampToValueAtTime(wc.x,i),t.forwardY.linearRampToValueAtTime(wc.y,i),t.forwardZ.linearRampToValueAtTime(wc.z,i),t.upX.linearRampToValueAtTime(n.x,i),t.upY.linearRampToValueAtTime(n.y,i),t.upZ.linearRampToValueAtTime(n.z,i)}else t.setPosition(Sc.x,Sc.y,Sc.z),t.setOrientation(wc.x,wc.y,wc.z,n.x,n.y,n.z)}}class YA extends Sn{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source!==null&&(this.source.stop(),this.source.onended=null),this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this._connected!==!1){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){if(this.detune=e,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}const Ec=new X,Ab=new Ni,TB=new X,bc=new X;class MB extends YA{constructor(e){super(e),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}connect(){super.connect(),this.panner.connect(this.gain)}disconnect(){super.disconnect(),this.panner.disconnect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(e){return this.panner.refDistance=e,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(e){return this.panner.rolloffFactor=e,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(e){return this.panner.distanceModel=e,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(e){return this.panner.maxDistance=e,this}setDirectionalCone(e,t,n){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=t,this.panner.coneOuterGain=n,this}updateMatrixWorld(e){if(super.updateMatrixWorld(e),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(Ec,Ab,TB),bc.set(0,0,1).applyQuaternion(Ab);const t=this.panner;if(t.positionX){const n=this.context.currentTime+this.listener.timeDelta;t.positionX.linearRampToValueAtTime(Ec.x,n),t.positionY.linearRampToValueAtTime(Ec.y,n),t.positionZ.linearRampToValueAtTime(Ec.z,n),t.orientationX.linearRampToValueAtTime(bc.x,n),t.orientationY.linearRampToValueAtTime(bc.y,n),t.orientationZ.linearRampToValueAtTime(bc.z,n)}else t.setPosition(Ec.x,Ec.y,Ec.z),t.setOrientation(bc.x,bc.y,bc.z)}}class AB{constructor(e,t=2048){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=t,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0;const t=this.getFrequencyData();for(let n=0;n<t.length;n++)e+=t[n];return e/t.length}}class ZA{constructor(e,t,n){this.binding=e,this.valueSize=n;let i,s,a;switch(t){case"quaternion":i=this._slerp,s=this._slerpAdditive,a=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(n*6),this._workIndex=5;break;case"string":case"bool":i=this._select,s=this._select,a=this._setAdditiveIdentityOther,this.buffer=new Array(n*5);break;default:i=this._lerp,s=this._lerpAdditive,a=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(n*5)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=s,this._setIdentity=a,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(e,t){const n=this.buffer,i=this.valueSize,s=e*i+i;let a=this.cumulativeWeight;if(a===0){for(let o=0;o!==i;++o)n[s+o]=n[o];a=t}else{a+=t;const o=t/a;this._mixBufferRegion(n,s,0,o,i)}this.cumulativeWeight=a}accumulateAdditive(e){const t=this.buffer,n=this.valueSize,i=n*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(t,i,0,e,n),this.cumulativeWeightAdditive+=e}apply(e){const t=this.valueSize,n=this.buffer,i=e*t+t,s=this.cumulativeWeight,a=this.cumulativeWeightAdditive,o=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,s<1){const u=t*this._origIndex;this._mixBufferRegion(n,i,u,1-s,t)}a>0&&this._mixBufferRegionAdditive(n,i,this._addIndex*t,1,t);for(let u=t,h=t+t;u!==h;++u)if(n[u]!==n[u+t]){o.setValue(n,i);break}}saveOriginalState(){const e=this.binding,t=this.buffer,n=this.valueSize,i=n*this._origIndex;e.getValue(t,i);for(let s=n,a=i;s!==a;++s)t[s]=t[i+s%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const e=this.valueSize*3;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){const e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let n=e;n<t;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[t+n]=this.buffer[e+n]}_select(e,t,n,i,s){if(i>=.5)for(let a=0;a!==s;++a)e[t+a]=e[n+a]}_slerp(e,t,n,i){Ni.slerpFlat(e,t,e,t,e,n,i)}_slerpAdditive(e,t,n,i,s){const a=this._workIndex*s;Ni.multiplyQuaternionsFlat(e,a,e,t,e,n),Ni.slerpFlat(e,t,e,t,e,a,i)}_lerp(e,t,n,i,s){const a=1-i;for(let o=0;o!==s;++o){const u=t+o;e[u]=e[u]*a+e[n+o]*i}}_lerpAdditive(e,t,n,i,s){for(let a=0;a!==s;++a){const o=t+a;e[o]=e[o]+e[n+a]*i}}}const s1="\\[\\]\\.:\\/",NB=new RegExp("["+s1+"]","g"),a1="[^"+s1+"]",CB="[^"+s1.replace("\\.","")+"]",RB=/((?:WC+[\/:])*)/.source.replace("WC",a1),IB=/(WCOD+)?/.source.replace("WCOD",CB),PB=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",a1),LB=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",a1),kB=new RegExp("^"+RB+IB+PB+LB+"$"),DB=["material","materials","bones","map"];class OB{constructor(e,t,n){const i=n||_n.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,i)}getValue(e,t){this.bind();const n=this._targetGroup.nCachedObjects_,i=this._bindings[n];i!==void 0&&i.getValue(e,t)}setValue(e,t){const n=this._bindings;for(let i=this._targetGroup.nCachedObjects_,s=n.length;i!==s;++i)n[i].setValue(e,t)}bind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].bind()}unbind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].unbind()}}class _n{constructor(e,t,n){this.path=t,this.parsedPath=n||_n.parseTrackName(t),this.node=_n.findNode(e,this.parsedPath.nodeName),this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,n){return e&&e.isAnimationObjectGroup?new _n.Composite(e,t,n):new _n(e,t,n)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(NB,"")}static parseTrackName(e){const t=kB.exec(e);if(t===null)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const n={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},i=n.nodeName&&n.nodeName.lastIndexOf(".");if(i!==void 0&&i!==-1){const s=n.nodeName.substring(i+1);DB.indexOf(s)!==-1&&(n.nodeName=n.nodeName.substring(0,i),n.objectName=s)}if(n.propertyName===null||n.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return n}static findNode(e,t){if(t===void 0||t===""||t==="."||t===-1||t===e.name||t===e.uuid)return e;if(e.skeleton){const n=e.skeleton.getBoneByName(t);if(n!==void 0)return n}if(e.children){const n=function(s){for(let a=0;a<s.length;a++){const o=s[a];if(o.name===t||o.uuid===t)return o;const u=n(o.children);if(u)return u}return null},i=n(e.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.targetObject[this.propertyName]}_getValue_array(e,t){const n=this.resolvedProperty;for(let i=0,s=n.length;i!==s;++i)e[t++]=n[i]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){const n=this.resolvedProperty;for(let i=0,s=n.length;i!==s;++i)n[i]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const n=this.resolvedProperty;for(let i=0,s=n.length;i!==s;++i)n[i]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const n=this.resolvedProperty;for(let i=0,s=n.length;i!==s;++i)n[i]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath,n=t.objectName,i=t.propertyName;let s=t.propertyIndex;if(e||(e=_n.findNode(this.rootNode,t.nodeName),this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e){console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");return}if(n){let h=t.objectIndex;switch(n){case"materials":if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}e=e.skeleton.bones;for(let p=0;p<e.length;p++)if(e[p].name===h){h=p;break}break;case"map":if("map"in e){e=e.map;break}if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}e=e.material.map;break;default:if(e[n]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[n]}if(h!==void 0){if(e[h]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[h]}}const a=e[i];if(a===void 0){const h=t.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+h+"."+i+" but it wasn't found.",e);return}let o=this.Versioning.None;this.targetObject=e,e.needsUpdate!==void 0?o=this.Versioning.NeedsUpdate:e.matrixWorldNeedsUpdate!==void 0&&(o=this.Versioning.MatrixWorldNeedsUpdate);let u=this.BindingType.Direct;if(s!==void 0){if(i==="morphTargetInfluences"){if(!e.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!e.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}e.morphTargetDictionary[s]!==void 0&&(s=e.morphTargetDictionary[s])}u=this.BindingType.ArrayElement,this.resolvedProperty=a,this.propertyIndex=s}else a.fromArray!==void 0&&a.toArray!==void 0?(u=this.BindingType.HasFromToArray,this.resolvedProperty=a):Array.isArray(a)?(u=this.BindingType.EntireArray,this.resolvedProperty=a):this.propertyName=i;this.getValue=this.GetterByBindingType[u],this.setValue=this.SetterByBindingTypeAndVersioning[u][o]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}_n.Composite=OB;_n.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};_n.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};_n.prototype.GetterByBindingType=[_n.prototype._getValue_direct,_n.prototype._getValue_array,_n.prototype._getValue_arrayElement,_n.prototype._getValue_toArray];_n.prototype.SetterByBindingTypeAndVersioning=[[_n.prototype._setValue_direct,_n.prototype._setValue_direct_setNeedsUpdate,_n.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[_n.prototype._setValue_array,_n.prototype._setValue_array_setNeedsUpdate,_n.prototype._setValue_array_setMatrixWorldNeedsUpdate],[_n.prototype._setValue_arrayElement,_n.prototype._setValue_arrayElement_setNeedsUpdate,_n.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[_n.prototype._setValue_fromArray,_n.prototype._setValue_fromArray_setNeedsUpdate,_n.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class FB{constructor(){this.isAnimationObjectGroup=!0,this.uuid=Ps(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const e={};this._indicesByUUID=e;for(let n=0,i=arguments.length;n!==i;++n)e[arguments[n].uuid]=n;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const t=this;this.stats={objects:{get total(){return t._objects.length},get inUse(){return this.total-t.nCachedObjects_}},get bindingsPerObject(){return t._bindings.length}}}add(){const e=this._objects,t=this._indicesByUUID,n=this._paths,i=this._parsedPaths,s=this._bindings,a=s.length;let o,u=e.length,h=this.nCachedObjects_;for(let p=0,m=arguments.length;p!==m;++p){const y=arguments[p],v=y.uuid;let S=t[v];if(S===void 0){S=u++,t[v]=S,e.push(y);for(let T=0,E=a;T!==E;++T)s[T].push(new _n(y,n[T],i[T]))}else if(S<h){o=e[S];const T=--h,E=e[T];t[E.uuid]=S,e[S]=E,t[v]=T,e[T]=y;for(let w=0,C=a;w!==C;++w){const A=s[w],I=A[T];let F=A[S];A[S]=I,F===void 0&&(F=new _n(y,n[w],i[w])),A[T]=F}}else e[S]!==o&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=h}remove(){const e=this._objects,t=this._indicesByUUID,n=this._bindings,i=n.length;let s=this.nCachedObjects_;for(let a=0,o=arguments.length;a!==o;++a){const u=arguments[a],h=u.uuid,p=t[h];if(p!==void 0&&p>=s){const m=s++,y=e[m];t[y.uuid]=p,e[p]=y,t[h]=m,e[m]=u;for(let v=0,S=i;v!==S;++v){const T=n[v],E=T[m],w=T[p];T[p]=E,T[m]=w}}}this.nCachedObjects_=s}uncache(){const e=this._objects,t=this._indicesByUUID,n=this._bindings,i=n.length;let s=this.nCachedObjects_,a=e.length;for(let o=0,u=arguments.length;o!==u;++o){const h=arguments[o],p=h.uuid,m=t[p];if(m!==void 0)if(delete t[p],m<s){const y=--s,v=e[y],S=--a,T=e[S];t[v.uuid]=m,e[m]=v,t[T.uuid]=y,e[y]=T,e.pop();for(let E=0,w=i;E!==w;++E){const C=n[E],A=C[y],I=C[S];C[m]=A,C[y]=I,C.pop()}}else{const y=--a,v=e[y];y>0&&(t[v.uuid]=m),e[m]=v,e.pop();for(let S=0,T=i;S!==T;++S){const E=n[S];E[m]=E[y],E.pop()}}}this.nCachedObjects_=s}subscribe_(e,t){const n=this._bindingsIndicesByPath;let i=n[e];const s=this._bindings;if(i!==void 0)return s[i];const a=this._paths,o=this._parsedPaths,u=this._objects,h=u.length,p=this.nCachedObjects_,m=new Array(h);i=s.length,n[e]=i,a.push(e),o.push(t),s.push(m);for(let y=p,v=u.length;y!==v;++y){const S=u[y];m[y]=new _n(S,e,t)}return m}unsubscribe_(e){const t=this._bindingsIndicesByPath,n=t[e];if(n!==void 0){const i=this._paths,s=this._parsedPaths,a=this._bindings,o=a.length-1,u=a[o],h=e[o];t[h]=n,a[n]=u,a.pop(),s[n]=s[o],s.pop(),i[n]=i[o],i.pop()}}}class JA{constructor(e,t,n=null,i=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=n,this.blendMode=i;const s=t.tracks,a=s.length,o=new Array(a),u={endingStart:Dc,endingEnd:Dc};for(let h=0;h!==a;++h){const p=s[h].createInterpolant(null);o[h]=p,p.settings=u}this._interpolantSettings=u,this._interpolants=o,this._propertyBindings=new Array(a),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=IM,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,n){if(e.fadeOut(t),this.fadeIn(t),n){const i=this._clip.duration,s=e._clip.duration,a=s/i,o=i/s;e.warp(1,a,t),this.warp(o,1,t)}return this}crossFadeTo(e,t,n){return e.crossFadeFrom(this,t,n)}stopFading(){const e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,n){const i=this._mixer,s=i.time,a=this.timeScale;let o=this._timeScaleInterpolant;o===null&&(o=i._lendControlInterpolant(),this._timeScaleInterpolant=o);const u=o.parameterPositions,h=o.sampleValues;return u[0]=s,u[1]=s+n,h[0]=e/a,h[1]=t/a,this}stopWarping(){const e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,n,i){if(!this.enabled){this._updateWeight(e);return}const s=this._startTime;if(s!==null){const u=(e-s)*n;u<0||n===0?t=0:(this._startTime=null,t=n*u)}t*=this._updateTimeScale(e);const a=this._updateTime(t),o=this._updateWeight(e);if(o>0){const u=this._interpolants,h=this._propertyBindings;switch(this.blendMode){case RS:for(let p=0,m=u.length;p!==m;++p)u[p].evaluate(a),h[p].accumulateAdditive(o);break;case b0:default:for(let p=0,m=u.length;p!==m;++p)u[p].evaluate(a),h[p].accumulate(i,o)}}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const n=this._weightInterpolant;if(n!==null){const i=n.evaluate(e)[0];t*=i,e>n.parameterPositions[1]&&(this.stopFading(),i===0&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const n=this._timeScaleInterpolant;if(n!==null){const i=n.evaluate(e)[0];t*=i,e>n.parameterPositions[1]&&(this.stopWarping(),t===0?this.paused=!0:this.timeScale=t)}}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,n=this.loop;let i=this.time+e,s=this._loopCount;const a=n===PM;if(e===0)return s===-1?i:a&&(s&1)===1?t-i:i;if(n===RM){s===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(i>=t)i=t;else if(i<0)i=0;else{this.time=i;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(s===-1&&(e>=0?(s=0,this._setEndings(!0,this.repetitions===0,a)):this._setEndings(this.repetitions===0,!0,a)),i>=t||i<0){const o=Math.floor(i/t);i-=t*o,s+=Math.abs(o);const u=this.repetitions-s;if(u<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,i=e>0?t:0,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(u===1){const h=e<0;this._setEndings(h,!h,a)}else this._setEndings(!1,!1,a);this._loopCount=s,this.time=i,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:o})}}else this.time=i;if(a&&(s&1)===1)return t-i}return i}_setEndings(e,t,n){const i=this._interpolantSettings;n?(i.endingStart=Oc,i.endingEnd=Oc):(e?i.endingStart=this.zeroSlopeAtStart?Oc:Dc:i.endingStart=Gp,t?i.endingEnd=this.zeroSlopeAtEnd?Oc:Dc:i.endingEnd=Gp)}_scheduleFading(e,t,n){const i=this._mixer,s=i.time;let a=this._weightInterpolant;a===null&&(a=i._lendControlInterpolant(),this._weightInterpolant=a);const o=a.parameterPositions,u=a.sampleValues;return o[0]=s,u[0]=t,o[1]=s+e,u[1]=n,this}}const UB=new Float32Array(1);class zB extends hl{constructor(e){super(),this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,t){const n=e._localRoot||this._root,i=e._clip.tracks,s=i.length,a=e._propertyBindings,o=e._interpolants,u=n.uuid,h=this._bindingsByRootAndName;let p=h[u];p===void 0&&(p={},h[u]=p);for(let m=0;m!==s;++m){const y=i[m],v=y.name;let S=p[v];if(S!==void 0)++S.referenceCount,a[m]=S;else{if(S=a[m],S!==void 0){S._cacheIndex===null&&(++S.referenceCount,this._addInactiveBinding(S,u,v));continue}const T=t&&t._propertyBindings[m].binding.parsedPath;S=new ZA(_n.create(n,v,T),y.ValueTypeName,y.getValueSize()),++S.referenceCount,this._addInactiveBinding(S,u,v),a[m]=S}o[m].resultBuffer=S.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(e._cacheIndex===null){const n=(e._localRoot||this._root).uuid,i=e._clip.uuid,s=this._actionsByClip[i];this._bindAction(e,s&&s.knownActions[0]),this._addInactiveAction(e,i,n)}const t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){const s=t[n];s.useCount++===0&&(this._lendBinding(s),s.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){const s=t[n];--s.useCount===0&&(s.restoreOriginalState(),this._takeBackBinding(s))}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){const t=e._cacheIndex;return t!==null&&t<this._nActiveActions}_addInactiveAction(e,t,n){const i=this._actions,s=this._actionsByClip;let a=s[t];if(a===void 0)a={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,s[t]=a;else{const o=a.knownActions;e._byClipCacheIndex=o.length,o.push(e)}e._cacheIndex=i.length,i.push(e),a.actionByRoot[n]=e}_removeInactiveAction(e){const t=this._actions,n=t[t.length-1],i=e._cacheIndex;n._cacheIndex=i,t[i]=n,t.pop(),e._cacheIndex=null;const s=e._clip.uuid,a=this._actionsByClip,o=a[s],u=o.knownActions,h=u[u.length-1],p=e._byClipCacheIndex;h._byClipCacheIndex=p,u[p]=h,u.pop(),e._byClipCacheIndex=null;const m=o.actionByRoot,y=(e._localRoot||this._root).uuid;delete m[y],u.length===0&&delete a[s],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){const t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){const s=t[n];--s.referenceCount===0&&this._removeInactiveBinding(s)}}_lendAction(e){const t=this._actions,n=e._cacheIndex,i=this._nActiveActions++,s=t[i];e._cacheIndex=i,t[i]=e,s._cacheIndex=n,t[n]=s}_takeBackAction(e){const t=this._actions,n=e._cacheIndex,i=--this._nActiveActions,s=t[i];e._cacheIndex=i,t[i]=e,s._cacheIndex=n,t[n]=s}_addInactiveBinding(e,t,n){const i=this._bindingsByRootAndName,s=this._bindings;let a=i[t];a===void 0&&(a={},i[t]=a),a[n]=e,e._cacheIndex=s.length,s.push(e)}_removeInactiveBinding(e){const t=this._bindings,n=e.binding,i=n.rootNode.uuid,s=n.path,a=this._bindingsByRootAndName,o=a[i],u=t[t.length-1],h=e._cacheIndex;u._cacheIndex=h,t[h]=u,t.pop(),delete o[s],Object.keys(o).length===0&&delete a[i]}_lendBinding(e){const t=this._bindings,n=e._cacheIndex,i=this._nActiveBindings++,s=t[i];e._cacheIndex=i,t[i]=e,s._cacheIndex=n,t[n]=s}_takeBackBinding(e){const t=this._bindings,n=e._cacheIndex,i=--this._nActiveBindings,s=t[i];e._cacheIndex=i,t[i]=e,s._cacheIndex=n,t[n]=s}_lendControlInterpolant(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let n=e[t];return n===void 0&&(n=new QS(new Float32Array(2),new Float32Array(2),1,UB),n.__cacheIndex=t,e[t]=n),n}_takeBackControlInterpolant(e){const t=this._controlInterpolants,n=e.__cacheIndex,i=--this._nActiveControlInterpolants,s=t[i];e.__cacheIndex=i,t[i]=e,s.__cacheIndex=n,t[n]=s}clipAction(e,t,n){const i=t||this._root,s=i.uuid;let a=typeof e=="string"?rm.findByName(i,e):e;const o=a!==null?a.uuid:e,u=this._actionsByClip[o];let h=null;if(n===void 0&&(a!==null?n=a.blendMode:n=b0),u!==void 0){const m=u.actionByRoot[s];if(m!==void 0&&m.blendMode===n)return m;h=u.knownActions[0],a===null&&(a=h._clip)}if(a===null)return null;const p=new JA(this,a,t,n);return this._bindAction(p,h),this._addInactiveAction(p,o,s),p}existingAction(e,t){const n=t||this._root,i=n.uuid,s=typeof e=="string"?rm.findByName(n,e):e,a=s?s.uuid:e,o=this._actionsByClip[a];return o!==void 0&&o.actionByRoot[i]||null}stopAllAction(){const e=this._actions,t=this._nActiveActions;for(let n=t-1;n>=0;--n)e[n].stop();return this}update(e){e*=this.timeScale;const t=this._actions,n=this._nActiveActions,i=this.time+=e,s=Math.sign(e),a=this._accuIndex^=1;for(let h=0;h!==n;++h)t[h]._update(i,e,s,a);const o=this._bindings,u=this._nActiveBindings;for(let h=0;h!==u;++h)o[h].apply(a);return this}setTime(e){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){const t=this._actions,n=e.uuid,i=this._actionsByClip,s=i[n];if(s!==void 0){const a=s.knownActions;for(let o=0,u=a.length;o!==u;++o){const h=a[o];this._deactivateAction(h);const p=h._cacheIndex,m=t[t.length-1];h._cacheIndex=null,h._byClipCacheIndex=null,m._cacheIndex=p,t[p]=m,t.pop(),this._removeInactiveBindingsForAction(h)}delete i[n]}}uncacheRoot(e){const t=e.uuid,n=this._actionsByClip;for(const a in n){const o=n[a].actionByRoot,u=o[t];u!==void 0&&(this._deactivateAction(u),this._removeInactiveAction(u))}const i=this._bindingsByRootAndName,s=i[t];if(s!==void 0)for(const a in s){const o=s[a];o.restoreOriginalState(),this._removeInactiveBinding(o)}}uncacheAction(e,t){const n=this.existingAction(e,t);n!==null&&(this._deactivateAction(n),this._removeInactiveAction(n))}}class o1{constructor(e){this.value=e}clone(){return new o1(this.value.clone===void 0?this.value:this.value.clone())}}let BB=0;class VB extends hl{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:BB++}),this.name="",this.usage=Xp,this.uniforms=[]}add(e){return this.uniforms.push(e),this}remove(e){const t=this.uniforms.indexOf(e);return t!==-1&&this.uniforms.splice(t,1),this}setName(e){return this.name=e,this}setUsage(e){return this.usage=e,this}dispose(){return this.dispatchEvent({type:"dispose"}),this}copy(e){this.name=e.name,this.usage=e.usage;const t=e.uniforms;this.uniforms.length=0;for(let n=0,i=t.length;n<i;n++)this.uniforms.push(t[n].clone());return this}clone(){return new this.constructor().copy(this)}}class HB extends I0{constructor(e,t,n=1){super(e,t),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=n}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}clone(e){const t=super.clone(e);return t.meshPerAttribute=this.meshPerAttribute,t}toJSON(e){const t=super.toJSON(e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}class $B{constructor(e,t,n,i,s){this.isGLBufferAttribute=!0,this.name="",this.buffer=e,this.type=t,this.itemSize=n,this.elementSize=i,this.count=s,this.version=0}set needsUpdate(e){e===!0&&this.version++}setBuffer(e){return this.buffer=e,this}setType(e,t){return this.type=e,this.elementSize=t,this}setItemSize(e){return this.itemSize=e,this}setCount(e){return this.count=e,this}}class QA{constructor(e,t,n=0,i=1/0){this.ray=new sf(e,t),this.near=n,this.far=i,this.camera=null,this.layers=new Hc,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(e,t){this.ray.set(e,t)}setFromCamera(e,t){t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):console.error("THREE.Raycaster: Unsupported camera type: "+t.type)}intersectObject(e,t=!0,n=[]){return zx(e,this,n,t),n.sort(Nb),n}intersectObjects(e,t=!0,n=[]){for(let i=0,s=e.length;i<s;i++)zx(e[i],this,n,t);return n.sort(Nb),n}}function Nb(r,e){return r.distance-e.distance}function zx(r,e,t,n){if(r.layers.test(e.layers)&&r.raycast(e,t),n===!0){const i=r.children;for(let s=0,a=i.length;s<a;s++)zx(i[s],e,t,!0)}}class Bx{constructor(e=1,t=0,n=0){return this.radius=e,this.phi=t,this.theta=n,this}set(e,t,n){return this.radius=e,this.phi=t,this.theta=n,this}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,n){return this.radius=Math.sqrt(e*e+t*t+n*n),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,n),this.phi=Math.acos(mr(t/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}class GB{constructor(e=1,t=0,n=0){return this.radius=e,this.theta=t,this.y=n,this}set(e,t,n){return this.radius=e,this.theta=t,this.y=n,this}copy(e){return this.radius=e.radius,this.theta=e.theta,this.y=e.y,this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,n){return this.radius=Math.sqrt(e*e+n*n),this.theta=Math.atan2(e,n),this.y=t,this}clone(){return new this.constructor().copy(this)}}const Cb=new Pe;class WB{constructor(e=new Pe(1/0,1/0),t=new Pe(-1/0,-1/0)){this.isBox2=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=Cb.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y)}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,Cb).distanceTo(e)}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const Rb=new X,xy=new X;class jB{constructor(e=new X,t=new X){this.start=e,this.end=t}set(e,t){return this.start.copy(e),this.end.copy(t),this}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){Rb.subVectors(e,this.start),xy.subVectors(this.end,this.start);const n=xy.dot(xy);let s=xy.dot(Rb)/n;return t&&(s=mr(s,0,1)),s}closestPointToPoint(e,t,n){const i=this.closestPointToPointParameter(e,t);return this.delta(n).multiplyScalar(i).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}const Ib=new X;class qB extends Sn{constructor(e,t){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=t,this.type="SpotLightHelper";const n=new ln,i=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let a=0,o=1,u=32;a<u;a++,o++){const h=a/u*Math.PI*2,p=o/u*Math.PI*2;i.push(Math.cos(h),Math.sin(h),1,Math.cos(p),Math.sin(p),1)}n.setAttribute("position",new At(i,3));const s=new qi({fog:!1,toneMapped:!1});this.cone=new fo(n,s),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1);const e=this.light.distance?this.light.distance:1e3,t=e*Math.tan(this.light.angle);this.cone.scale.set(t,t,e),Ib.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(Ib),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const eu=new X,Sy=new Jt,A_=new Jt;class XB extends fo{constructor(e){const t=e2(e),n=new ln,i=[],s=[],a=new yt(0,0,1),o=new yt(0,1,0);for(let h=0;h<t.length;h++){const p=t[h];p.parent&&p.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),s.push(a.r,a.g,a.b),s.push(o.r,o.g,o.b))}n.setAttribute("position",new At(i,3)),n.setAttribute("color",new At(s,3));const u=new qi({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(n,u),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const t=this.bones,n=this.geometry,i=n.getAttribute("position");A_.copy(this.root.matrixWorld).invert();for(let s=0,a=0;s<t.length;s++){const o=t[s];o.parent&&o.parent.isBone&&(Sy.multiplyMatrices(A_,o.matrixWorld),eu.setFromMatrixPosition(Sy),i.setXYZ(a,eu.x,eu.y,eu.z),Sy.multiplyMatrices(A_,o.parent.matrixWorld),eu.setFromMatrixPosition(Sy),i.setXYZ(a+1,eu.x,eu.y,eu.z),a+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}dispose(){this.geometry.dispose(),this.material.dispose()}}function e2(r){const e=[];r.isBone===!0&&e.push(r);for(let t=0;t<r.children.length;t++)e.push.apply(e,e2(r.children[t]));return e}class KB extends hi{constructor(e,t,n){const i=new Am(t,4,2),s=new Eu({wireframe:!0,fog:!1,toneMapped:!1});super(i,s),this.light=e,this.color=n,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const YB=new X,Pb=new yt,Lb=new yt;class ZB extends Sn{constructor(e,t,n){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=n,this.type="HemisphereLightHelper";const i=new Mm(t);i.rotateY(Math.PI*.5),this.material=new Eu({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const s=i.getAttribute("position"),a=new Float32Array(s.count*3);i.setAttribute("color",new Hn(a,3)),this.add(new hi(i,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const e=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const t=e.geometry.getAttribute("color");Pb.copy(this.light.color),Lb.copy(this.light.groundColor);for(let n=0,i=t.count;n<i;n++){const s=n<i/2?Pb:Lb;t.setXYZ(n,s.r,s.g,s.b)}t.needsUpdate=!0}this.light.updateWorldMatrix(!0,!1),e.lookAt(YB.setFromMatrixPosition(this.light.matrixWorld).negate())}}class JB extends fo{constructor(e=10,t=10,n=4473924,i=8947848){n=new yt(n),i=new yt(i);const s=t/2,a=e/t,o=e/2,u=[],h=[];for(let y=0,v=0,S=-o;y<=t;y++,S+=a){u.push(-o,0,S,o,0,S),u.push(S,0,-o,S,0,o);const T=y===s?n:i;T.toArray(h,v),v+=3,T.toArray(h,v),v+=3,T.toArray(h,v),v+=3,T.toArray(h,v),v+=3}const p=new ln;p.setAttribute("position",new At(u,3)),p.setAttribute("color",new At(h,3));const m=new qi({vertexColors:!0,toneMapped:!1});super(p,m),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}class QB extends fo{constructor(e=10,t=16,n=8,i=64,s=4473924,a=8947848){s=new yt(s),a=new yt(a);const o=[],u=[];if(t>1)for(let m=0;m<t;m++){const y=m/t*(Math.PI*2),v=Math.sin(y)*e,S=Math.cos(y)*e;o.push(0,0,0),o.push(v,0,S);const T=m&1?s:a;u.push(T.r,T.g,T.b),u.push(T.r,T.g,T.b)}for(let m=0;m<n;m++){const y=m&1?s:a,v=e-e/n*m;for(let S=0;S<i;S++){let T=S/i*(Math.PI*2),E=Math.sin(T)*v,w=Math.cos(T)*v;o.push(E,0,w),u.push(y.r,y.g,y.b),T=(S+1)/i*(Math.PI*2),E=Math.sin(T)*v,w=Math.cos(T)*v,o.push(E,0,w),u.push(y.r,y.g,y.b)}}const h=new ln;h.setAttribute("position",new At(o,3)),h.setAttribute("color",new At(u,3));const p=new qi({vertexColors:!0,toneMapped:!1});super(h,p),this.type="PolarGridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}const kb=new X,wy=new X,Db=new X;class e4 extends Sn{constructor(e,t,n){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=n,this.type="DirectionalLightHelper",t===void 0&&(t=1);let i=new ln;i.setAttribute("position",new At([-t,t,0,t,t,0,t,-t,0,-t,-t,0,-t,t,0],3));const s=new qi({fog:!1,toneMapped:!1});this.lightPlane=new mu(i,s),this.add(this.lightPlane),i=new ln,i.setAttribute("position",new At([0,0,0,0,0,1],3)),this.targetLine=new mu(i,s),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),kb.setFromMatrixPosition(this.light.matrixWorld),wy.setFromMatrixPosition(this.light.target.matrixWorld),Db.subVectors(wy,kb),this.lightPlane.lookAt(wy),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(wy),this.targetLine.scale.z=Db.length()}}const Ey=new X,pr=new wm;class t4 extends fo{constructor(e){const t=new ln,n=new qi({color:16777215,vertexColors:!0,toneMapped:!1}),i=[],s=[],a={};o("n1","n2"),o("n2","n4"),o("n4","n3"),o("n3","n1"),o("f1","f2"),o("f2","f4"),o("f4","f3"),o("f3","f1"),o("n1","f1"),o("n2","f2"),o("n3","f3"),o("n4","f4"),o("p","n1"),o("p","n2"),o("p","n3"),o("p","n4"),o("u1","u2"),o("u2","u3"),o("u3","u1"),o("c","t"),o("p","c"),o("cn1","cn2"),o("cn3","cn4"),o("cf1","cf2"),o("cf3","cf4");function o(S,T){u(S),u(T)}function u(S){i.push(0,0,0),s.push(0,0,0),a[S]===void 0&&(a[S]=[]),a[S].push(i.length/3-1)}t.setAttribute("position",new At(i,3)),t.setAttribute("color",new At(s,3)),super(t,n),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=a,this.update();const h=new yt(16755200),p=new yt(16711680),m=new yt(43775),y=new yt(16777215),v=new yt(3355443);this.setColors(h,p,m,y,v)}setColors(e,t,n,i,s){const o=this.geometry.getAttribute("color");o.setXYZ(0,e.r,e.g,e.b),o.setXYZ(1,e.r,e.g,e.b),o.setXYZ(2,e.r,e.g,e.b),o.setXYZ(3,e.r,e.g,e.b),o.setXYZ(4,e.r,e.g,e.b),o.setXYZ(5,e.r,e.g,e.b),o.setXYZ(6,e.r,e.g,e.b),o.setXYZ(7,e.r,e.g,e.b),o.setXYZ(8,e.r,e.g,e.b),o.setXYZ(9,e.r,e.g,e.b),o.setXYZ(10,e.r,e.g,e.b),o.setXYZ(11,e.r,e.g,e.b),o.setXYZ(12,e.r,e.g,e.b),o.setXYZ(13,e.r,e.g,e.b),o.setXYZ(14,e.r,e.g,e.b),o.setXYZ(15,e.r,e.g,e.b),o.setXYZ(16,e.r,e.g,e.b),o.setXYZ(17,e.r,e.g,e.b),o.setXYZ(18,e.r,e.g,e.b),o.setXYZ(19,e.r,e.g,e.b),o.setXYZ(20,e.r,e.g,e.b),o.setXYZ(21,e.r,e.g,e.b),o.setXYZ(22,e.r,e.g,e.b),o.setXYZ(23,e.r,e.g,e.b),o.setXYZ(24,t.r,t.g,t.b),o.setXYZ(25,t.r,t.g,t.b),o.setXYZ(26,t.r,t.g,t.b),o.setXYZ(27,t.r,t.g,t.b),o.setXYZ(28,t.r,t.g,t.b),o.setXYZ(29,t.r,t.g,t.b),o.setXYZ(30,t.r,t.g,t.b),o.setXYZ(31,t.r,t.g,t.b),o.setXYZ(32,n.r,n.g,n.b),o.setXYZ(33,n.r,n.g,n.b),o.setXYZ(34,n.r,n.g,n.b),o.setXYZ(35,n.r,n.g,n.b),o.setXYZ(36,n.r,n.g,n.b),o.setXYZ(37,n.r,n.g,n.b),o.setXYZ(38,i.r,i.g,i.b),o.setXYZ(39,i.r,i.g,i.b),o.setXYZ(40,s.r,s.g,s.b),o.setXYZ(41,s.r,s.g,s.b),o.setXYZ(42,s.r,s.g,s.b),o.setXYZ(43,s.r,s.g,s.b),o.setXYZ(44,s.r,s.g,s.b),o.setXYZ(45,s.r,s.g,s.b),o.setXYZ(46,s.r,s.g,s.b),o.setXYZ(47,s.r,s.g,s.b),o.setXYZ(48,s.r,s.g,s.b),o.setXYZ(49,s.r,s.g,s.b),o.needsUpdate=!0}update(){const e=this.geometry,t=this.pointMap,n=1,i=1;pr.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),xr("c",t,e,pr,0,0,-1),xr("t",t,e,pr,0,0,1),xr("n1",t,e,pr,-1,-1,-1),xr("n2",t,e,pr,n,-1,-1),xr("n3",t,e,pr,-1,i,-1),xr("n4",t,e,pr,n,i,-1),xr("f1",t,e,pr,-1,-1,1),xr("f2",t,e,pr,n,-1,1),xr("f3",t,e,pr,-1,i,1),xr("f4",t,e,pr,n,i,1),xr("u1",t,e,pr,n*.7,i*1.1,-1),xr("u2",t,e,pr,-1*.7,i*1.1,-1),xr("u3",t,e,pr,0,i*2,-1),xr("cf1",t,e,pr,-1,0,1),xr("cf2",t,e,pr,n,0,1),xr("cf3",t,e,pr,0,-1,1),xr("cf4",t,e,pr,0,i,1),xr("cn1",t,e,pr,-1,0,-1),xr("cn2",t,e,pr,n,0,-1),xr("cn3",t,e,pr,0,-1,-1),xr("cn4",t,e,pr,0,i,-1),e.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function xr(r,e,t,n,i,s,a){Ey.set(i,s,a).unproject(n);const o=e[r];if(o!==void 0){const u=t.getAttribute("position");for(let h=0,p=o.length;h<p;h++)u.setXYZ(o[h],Ey.x,Ey.y,Ey.z)}}const by=new co;class n4 extends fo{constructor(e,t=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new Float32Array(8*3),s=new ln;s.setIndex(new Hn(n,1)),s.setAttribute("position",new Hn(i,3)),super(s,new qi({color:t,toneMapped:!1})),this.object=e,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(e){if(e!==void 0&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),this.object!==void 0&&by.setFromObject(this.object),by.isEmpty())return;const t=by.min,n=by.max,i=this.geometry.attributes.position,s=i.array;s[0]=n.x,s[1]=n.y,s[2]=n.z,s[3]=t.x,s[4]=n.y,s[5]=n.z,s[6]=t.x,s[7]=t.y,s[8]=n.z,s[9]=n.x,s[10]=t.y,s[11]=n.z,s[12]=n.x,s[13]=n.y,s[14]=t.z,s[15]=t.x,s[16]=n.y,s[17]=t.z,s[18]=t.x,s[19]=t.y,s[20]=t.z,s[21]=n.x,s[22]=t.y,s[23]=t.z,i.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(e){return this.object=e,this.update(),this}copy(e,t){return super.copy(e,t),this.object=e.object,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class r4 extends fo{constructor(e,t=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],s=new ln;s.setIndex(new Hn(n,1)),s.setAttribute("position",new At(i,3)),super(s,new qi({color:t,toneMapped:!1})),this.box=e,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(e){const t=this.box;t.isEmpty()||(t.getCenter(this.position),t.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(e))}dispose(){this.geometry.dispose(),this.material.dispose()}}class i4 extends mu{constructor(e,t=1,n=16776960){const i=n,s=[1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],a=new ln;a.setAttribute("position",new At(s,3)),a.computeBoundingSphere(),super(a,new qi({color:i,toneMapped:!1})),this.type="PlaneHelper",this.plane=e,this.size=t;const o=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],u=new ln;u.setAttribute("position",new At(o,3)),u.computeBoundingSphere(),this.add(new hi(u,new Eu({color:i,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(e){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(e)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}const Ob=new X;let Ty,N_;class s4 extends Sn{constructor(e=new X(0,0,1),t=new X(0,0,0),n=1,i=16776960,s=n*.2,a=s*.2){super(),this.type="ArrowHelper",Ty===void 0&&(Ty=new ln,Ty.setAttribute("position",new At([0,0,0,0,1,0],3)),N_=new ld(0,.5,1,5,1),N_.translate(0,-.5,0)),this.position.copy(t),this.line=new mu(Ty,new qi({color:i,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new hi(N_,new Eu({color:i,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e),this.setLength(n,s,a)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{Ob.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(Ob,t)}}setLength(e,t=e*.2,n=t*.2){this.line.scale.set(1,Math.max(1e-4,e-t),1),this.line.updateMatrix(),this.cone.scale.set(n,t,n),this.cone.position.y=e,this.cone.updateMatrix()}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class a4 extends fo{constructor(e=1){const t=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],n=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],i=new ln;i.setAttribute("position",new At(t,3)),i.setAttribute("color",new At(n,3));const s=new qi({vertexColors:!0,toneMapped:!1});super(i,s),this.type="AxesHelper"}setColors(e,t,n){const i=new yt,s=this.geometry.attributes.color.array;return i.set(e),i.toArray(s,0),i.toArray(s,3),i.set(t),i.toArray(s,6),i.toArray(s,9),i.set(n),i.toArray(s,12),i.toArray(s,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class o4{constructor(){this.type="ShapePath",this.color=new yt,this.subPaths=[],this.currentPath=null}moveTo(e,t){return this.currentPath=new Zp,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,t),this}lineTo(e,t){return this.currentPath.lineTo(e,t),this}quadraticCurveTo(e,t,n,i){return this.currentPath.quadraticCurveTo(e,t,n,i),this}bezierCurveTo(e,t,n,i,s,a){return this.currentPath.bezierCurveTo(e,t,n,i,s,a),this}splineThru(e){return this.currentPath.splineThru(e),this}toShapes(e){function t(w){const C=[];for(let A=0,I=w.length;A<I;A++){const F=w[A],U=new $c;U.curves=F.curves,C.push(U)}return C}function n(w,C){const A=C.length;let I=!1;for(let F=A-1,U=0;U<A;F=U++){let V=C[F],G=C[U],L=G.x-V.x,k=G.y-V.y;if(Math.abs(k)>Number.EPSILON){if(k<0&&(V=C[U],L=-L,G=C[F],k=-k),w.y<V.y||w.y>G.y)continue;if(w.y===V.y){if(w.x===V.x)return!0}else{const O=k*(w.x-V.x)-L*(w.y-V.y);if(O===0)return!0;if(O<0)continue;I=!I}}else{if(w.y!==V.y)continue;if(G.x<=w.x&&w.x<=V.x||V.x<=w.x&&w.x<=G.x)return!0}}return I}const i=no.isClockWise,s=this.subPaths;if(s.length===0)return[];let a,o,u;const h=[];if(s.length===1)return o=s[0],u=new $c,u.curves=o.curves,h.push(u),h;let p=!i(s[0].getPoints());p=e?!p:p;const m=[],y=[];let v=[],S=0,T;y[S]=void 0,v[S]=[];for(let w=0,C=s.length;w<C;w++)o=s[w],T=o.getPoints(),a=i(T),a=e?!a:a,a?(!p&&y[S]&&S++,y[S]={s:new $c,p:T},y[S].s.curves=o.curves,p&&S++,v[S]=[]):v[S].push({h:o,p:T[0]});if(!y[0])return t(s);if(y.length>1){let w=!1,C=0;for(let A=0,I=y.length;A<I;A++)m[A]=[];for(let A=0,I=y.length;A<I;A++){const F=v[A];for(let U=0;U<F.length;U++){const V=F[U];let G=!0;for(let L=0;L<y.length;L++)n(V.p,y[L].p)&&(A!==L&&C++,G?(G=!1,m[L].push(V)):w=!0);G&&m[A].push(V)}}C>0&&w===!1&&(v=m)}let E;for(let w=0,C=y.length;w<C;w++){u=y[w].s,h.push(u),E=v[w];for(let A=0,I=E.length;A<I;A++)u.holes.push(E[A].h)}return h}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:x0}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=x0);const l4=Object.freeze(Object.defineProperty({__proto__:null,ACESFilmicToneMapping:wS,AddEquation:nu,AddOperation:mM,AdditiveAnimationBlendMode:RS,AdditiveBlending:J_,AlphaFormat:EM,AlwaysCompare:$M,AlwaysDepth:lM,AlwaysStencilFunc:Cx,AmbientLight:GA,AnimationAction:JA,AnimationClip:rm,AnimationLoader:cB,AnimationMixer:zB,AnimationObjectGroup:FB,AnimationUtils:aB,ArcCurve:mA,ArrayCamera:sA,ArrowHelper:s4,AttachedBindMode:rx,Audio:YA,AudioAnalyser:AB,AudioContext:r1,AudioListener:bB,AudioLoader:SB,AxesHelper:a4,BackSide:Wi,BasicDepthPacking:LM,BasicShadowMap:GT,Bone:$S,BooleanKeyframeTrack:of,Box2:WB,Box3:co,Box3Helper:r4,BoxGeometry:af,BoxHelper:n4,BufferAttribute:Hn,BufferGeometry:ln,BufferGeometryLoader:KA,ByteType:SM,Cache:Yc,Camera:wm,CameraHelper:t4,CanvasTexture:Rz,CapsuleGeometry:D0,CatmullRomCurve3:gA,CineonToneMapping:vM,CircleGeometry:O0,ClampToEdgeWrapping:Mi,Clock:i1,Color:yt,ColorKeyframeTrack:e1,ColorManagement:Nn,CompressedArrayTexture:Nz,CompressedCubeTexture:Cz,CompressedTexture:L0,CompressedTextureLoader:fB,ConeGeometry:F0,ConstantAlphaFactor:sM,ConstantColorFactor:rM,CubeCamera:ZM,CubeReflectionMapping:ul,CubeRefractionMapping:du,CubeTexture:Em,CubeTextureLoader:hB,CubeUVReflectionMapping:ad,CubicBezierCurve:jS,CubicBezierCurve3:yA,CubicInterpolant:OA,CullFaceBack:Z_,CullFaceFront:$T,CullFaceFrontBack:ML,CullFaceNone:HT,Curve:Pa,CurvePath:_A,CustomBlending:WT,CustomToneMapping:_M,CylinderGeometry:ld,Cylindrical:GB,Data3DTexture:kS,DataArrayTexture:M0,DataTexture:Hh,DataTextureLoader:dB,DataUtils:Dk,DecrementStencilOp:UL,DecrementWrapStencilOp:BL,DefaultLoadingManager:zA,DepthFormat:uu,DepthStencilFormat:qc,DepthTexture:aA,DetachedBindMode:xM,DirectionalLight:$A,DirectionalLightHelper:e4,DiscreteInterpolant:FA,DisplayP3ColorSpace:T0,DodecahedronGeometry:U0,DoubleSide:Za,DstAlphaFactor:JT,DstColorFactor:eM,DynamicCopyUsage:tk,DynamicDrawUsage:KL,DynamicReadUsage:JL,EdgesGeometry:xA,EllipseCurve:k0,EqualCompare:UM,EqualDepth:cM,EqualStencilFunc:GL,EquirectangularReflectionMapping:Up,EquirectangularRefractionMapping:zp,Euler:Sm,EventDispatcher:hl,ExtrudeGeometry:B0,FileLoader:cl,Float16BufferAttribute:Vk,Float32BufferAttribute:At,Float64BufferAttribute:Hk,FloatType:Ja,Fog:R0,FogExp2:C0,FramebufferTexture:Az,FrontSide:ll,Frustum:A0,GLBufferAttribute:$B,GLSL1:rk,GLSL3:Rx,GreaterCompare:BM,GreaterDepth:hM,GreaterEqualCompare:HM,GreaterEqualDepth:fM,GreaterEqualStencilFunc:XL,GreaterStencilFunc:jL,GridHelper:JB,Group:Uh,HalfFloatType:qh,HemisphereLight:BA,HemisphereLightHelper:ZB,IcosahedronGeometry:V0,ImageBitmapLoader:xB,ImageLoader:im,ImageUtils:LS,IncrementStencilOp:FL,IncrementWrapStencilOp:zL,InstancedBufferAttribute:Yh,InstancedBufferGeometry:XA,InstancedInterleavedBuffer:HB,InstancedMesh:hA,Int16BufferAttribute:zk,Int32BufferAttribute:Bk,Int8BufferAttribute:Ok,IntType:bS,InterleavedBuffer:I0,InterleavedBufferAttribute:Xc,Interpolant:Nm,InterpolateDiscrete:Hp,InterpolateLinear:$p,InterpolateSmooth:Fy,InvertStencilOp:VL,KeepStencilOp:Nc,KeyframeTrack:La,LOD:cA,LatheGeometry:Tm,Layers:Hc,LessCompare:FM,LessDepth:uM,LessEqualCompare:zM,LessEqualDepth:Fp,LessEqualStencilFunc:WL,LessStencilFunc:$L,Light:Tu,LightProbe:qA,Line:mu,Line3:jB,LineBasicMaterial:qi,LineCurve:qS,LineCurve3:vA,LineDashedMaterial:LA,LineLoop:dA,LineSegments:fo,LinearDisplayP3ColorSpace:xm,LinearEncoding:IS,LinearFilter:wr,LinearInterpolant:QS,LinearMipMapLinearFilter:IL,LinearMipMapNearestFilter:RL,LinearMipmapLinearFilter:pu,LinearMipmapNearestFilter:ES,LinearSRGBColorSpace:ro,LinearToneMapping:gM,LinearTransfer:Wp,Loader:ms,LoaderUtils:Ux,LoadingManager:t1,LoopOnce:RM,LoopPingPong:PM,LoopRepeat:IM,LuminanceAlphaFormat:TM,LuminanceFormat:bM,MOUSE:Mc,Material:Ri,MaterialLoader:X0,MathUtils:yk,Matrix3:rn,Matrix4:Jt,MaxEquation:nx,Mesh:hi,MeshBasicMaterial:Eu,MeshDepthMaterial:US,MeshDistanceMaterial:zS,MeshLambertMaterial:IA,MeshMatcapMaterial:PA,MeshNormalMaterial:RA,MeshPhongMaterial:NA,MeshPhysicalMaterial:AA,MeshStandardMaterial:ZS,MeshToonMaterial:CA,MinEquation:tx,MirroredRepeatWrapping:Vp,MixOperation:pM,MultiplyBlending:ex,MultiplyOperation:_m,NearestFilter:Sr,NearestMipMapLinearFilter:CL,NearestMipMapNearestFilter:NL,NearestMipmapLinearFilter:Rp,NearestMipmapNearestFilter:Qy,NeverCompare:OM,NeverDepth:oM,NeverStencilFunc:HL,NoBlending:sl,NoColorSpace:Rs,NoToneMapping:eo,NormalAnimationBlendMode:b0,NormalBlending:Bc,NotEqualCompare:VM,NotEqualDepth:dM,NotEqualStencilFunc:qL,NumberKeyframeTrack:tm,Object3D:Sn,ObjectLoader:vB,ObjectSpaceNormalMap:DM,OctahedronGeometry:Mm,OneFactor:KT,OneMinusConstantAlphaFactor:aM,OneMinusConstantColorFactor:iM,OneMinusDstAlphaFactor:QT,OneMinusDstColorFactor:tM,OneMinusSrcAlphaFactor:Jy,OneMinusSrcColorFactor:ZT,OrthographicCamera:fu,P3Primaries:qp,PCFShadowMap:S0,PCFSoftShadowMap:Cp,PMREMGenerator:Px,Path:Zp,PerspectiveCamera:Er,Plane:Jo,PlaneGeometry:bm,PlaneHelper:i4,PointLight:HA,PointLightHelper:KB,Points:pA,PointsMaterial:GS,PolarGridHelper:QB,PolyhedronGeometry:bu,PositionalAudio:MB,PropertyBinding:_n,PropertyMixer:ZA,QuadraticBezierCurve:XS,QuadraticBezierCurve3:KS,Quaternion:Ni,QuaternionKeyframeTrack:ud,QuaternionLinearInterpolant:UA,RED_GREEN_RGTC2_Format:Ax,RED_RGTC1_Format:CM,REVISION:x0,RGBADepthPacking:kM,RGBAFormat:hs,RGBAIntegerFormat:CS,RGBA_ASTC_10x10_Format:Sx,RGBA_ASTC_10x5_Format:vx,RGBA_ASTC_10x6_Format:_x,RGBA_ASTC_10x8_Format:xx,RGBA_ASTC_12x10_Format:wx,RGBA_ASTC_12x12_Format:Ex,RGBA_ASTC_4x4_Format:cx,RGBA_ASTC_5x4_Format:fx,RGBA_ASTC_5x5_Format:hx,RGBA_ASTC_6x5_Format:dx,RGBA_ASTC_6x6_Format:px,RGBA_ASTC_8x5_Format:mx,RGBA_ASTC_8x6_Format:gx,RGBA_ASTC_8x8_Format:yx,RGBA_BPTC_Format:Oy,RGBA_ETC2_EAC_Format:ux,RGBA_PVRTC_2BPPV1_Format:ox,RGBA_PVRTC_4BPPV1_Format:ax,RGBA_S3TC_DXT1_Format:Ly,RGBA_S3TC_DXT3_Format:ky,RGBA_S3TC_DXT5_Format:Dy,RGB_BPTC_SIGNED_Format:bx,RGB_BPTC_UNSIGNED_Format:Tx,RGB_ETC1_Format:NM,RGB_ETC2_Format:lx,RGB_PVRTC_2BPPV1_Format:sx,RGB_PVRTC_4BPPV1_Format:ix,RGB_S3TC_DXT1_Format:Py,RGFormat:AM,RGIntegerFormat:NS,RawShaderMaterial:MA,Ray:sf,Raycaster:QA,Rec709Primaries:jp,RectAreaLight:WA,RedFormat:MM,RedIntegerFormat:AS,ReinhardToneMapping:yM,RenderTarget:qM,RepeatWrapping:Bp,ReplaceStencilOp:OL,ReverseSubtractEquation:qT,RingGeometry:H0,SIGNED_RED_GREEN_RGTC2_Format:Nx,SIGNED_RED_RGTC1_Format:Mx,SRGBColorSpace:Hr,SRGBTransfer:qn,Scene:VS,ShaderChunk:tn,ShaderLib:ba,ShaderMaterial:io,ShadowMaterial:TA,Shape:$c,ShapeGeometry:$0,ShapePath:o4,ShapeUtils:no,ShortType:wM,Skeleton:P0,SkeletonHelper:XB,SkinnedMesh:fA,Source:Fc,Sphere:Ia,SphereGeometry:Am,Spherical:Bx,SphericalHarmonics3:jA,SplineCurve:YS,SpotLight:VA,SpotLightHelper:qB,Sprite:uA,SpriteMaterial:HS,SrcAlphaFactor:Zy,SrcAlphaSaturateFactor:nM,SrcColorFactor:YT,StaticCopyUsage:ek,StaticDrawUsage:Xp,StaticReadUsage:ZL,StereoCamera:wB,StreamCopyUsage:nk,StreamDrawUsage:YL,StreamReadUsage:QL,StringKeyframeTrack:lf,SubtractEquation:jT,SubtractiveBlending:Q_,TOUCH:Ac,TangentSpaceNormalMap:wu,TetrahedronGeometry:G0,Texture:br,TextureLoader:pB,TorusGeometry:W0,TorusKnotGeometry:j0,Triangle:fs,TriangleFanDrawMode:kL,TriangleStripDrawMode:LL,TrianglesDrawMode:PL,TubeGeometry:q0,TwoPassDoubleSide:AL,UVMapping:w0,Uint16BufferAttribute:DS,Uint32BufferAttribute:OS,Uint8BufferAttribute:Fk,Uint8ClampedBufferAttribute:Uk,Uniform:o1,UniformsGroup:VB,UniformsLib:it,UniformsUtils:YM,UnsignedByteType:to,UnsignedInt248Type:lu,UnsignedIntType:il,UnsignedShort4444Type:TS,UnsignedShort5551Type:MS,UnsignedShortType:E0,VSMShadowMap:Ea,Vector2:Pe,Vector3:X,Vector4:Cn,VectorKeyframeTrack:nm,VideoTexture:Mz,WebGL1Renderer:oA,WebGL3DRenderTarget:Ek,WebGLArrayRenderTarget:wk,WebGLCoordinateSystem:Qa,WebGLCubeRenderTarget:JM,WebGLMultipleRenderTargets:bk,WebGLRenderTarget:Ca,WebGLRenderer:BS,WebGLUtils:iA,WebGPUCoordinateSystem:Kp,WireframeGeometry:bA,WrapAroundEnding:Gp,ZeroCurvatureEnding:Dc,ZeroFactor:XT,ZeroSlopeEnding:Oc,ZeroStencilOp:DL,_SRGBAFormat:e0,createCanvasElement:jM,sRGBEncoding:cu},Symbol.toStringTag,{value:"Module"}));var C_={exports:{}},tu={};/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Fb;function u4(){return Fb||(Fb=1,tu.ConcurrentRoot=1,tu.ContinuousEventPriority=4,tu.DefaultEventPriority=16,tu.DiscreteEventPriority=1,tu.IdleEventPriority=536870912,tu.LegacyRoot=0),tu}var Ub;function c4(){return Ub||(Ub=1,C_.exports=u4()),C_.exports}var Bh=c4();function f4(r){let e;const t=new Set,n=(h,p)=>{const m=typeof h=="function"?h(e):h;if(m!==e){const y=e;e=p?m:Object.assign({},e,m),t.forEach(v=>v(e,y))}},i=()=>e,s=(h,p=i,m=Object.is)=>{console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");let y=p(e);function v(){const S=p(e);if(!m(y,S)){const T=y;h(y=S,T)}}return t.add(v),()=>t.delete(v)},u={setState:n,getState:i,subscribe:(h,p,m)=>p||m?s(h,p,m):(t.add(h),()=>t.delete(h)),destroy:()=>t.clear()};return e=r(n,i,u),u}const h4=typeof window>"u"||!window.navigator||/ServerSideRendering|^Deno\//.test(window.navigator.userAgent),zb=h4?gt.useEffect:gt.useLayoutEffect;function d4(r){const e=typeof r=="function"?f4(r):r,t=(n=e.getState,i=Object.is)=>{const[,s]=gt.useReducer(E=>E+1,0),a=e.getState(),o=gt.useRef(a),u=gt.useRef(n),h=gt.useRef(i),p=gt.useRef(!1),m=gt.useRef();m.current===void 0&&(m.current=n(a));let y,v=!1;(o.current!==a||u.current!==n||h.current!==i||p.current)&&(y=n(a),v=!i(m.current,y)),zb(()=>{v&&(m.current=y),o.current=a,u.current=n,h.current=i,p.current=!1});const S=gt.useRef(a);zb(()=>{const E=()=>{try{const C=e.getState(),A=u.current(C);h.current(m.current,A)||(o.current=C,m.current=A,s())}catch{p.current=!0,s()}},w=e.subscribe(E);return e.getState()!==S.current&&E(),w},[]);const T=v?y:m.current;return gt.useDebugValue(T),T};return Object.assign(t,e),t[Symbol.iterator]=function(){console.warn("[useStore, api] = create() is deprecated and will be removed in v4");const n=[t,e];return{next(){const i=n.length<=0;return{value:n.shift(),done:i}}}},t}var R_={exports:{}},I_={exports:{}},P_={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Bb;function p4(){return Bb||(Bb=1,function(r){function e(Z,re){var ee=Z.length;Z.push(re);e:for(;0<ee;){var z=ee-1>>>1,q=Z[z];if(0<i(q,re))Z[z]=re,Z[ee]=q,ee=z;else break e}}function t(Z){return Z.length===0?null:Z[0]}function n(Z){if(Z.length===0)return null;var re=Z[0],ee=Z.pop();if(ee!==re){Z[0]=ee;e:for(var z=0,q=Z.length,ve=q>>>1;z<ve;){var Ce=2*(z+1)-1,ke=Z[Ce],We=Ce+1,tt=Z[We];if(0>i(ke,ee))We<q&&0>i(tt,ke)?(Z[z]=tt,Z[We]=ee,z=We):(Z[z]=ke,Z[Ce]=ee,z=Ce);else if(We<q&&0>i(tt,ee))Z[z]=tt,Z[We]=ee,z=We;else break e}}return re}function i(Z,re){var ee=Z.sortIndex-re.sortIndex;return ee!==0?ee:Z.id-re.id}if(typeof performance=="object"&&typeof performance.now=="function"){var s=performance;r.unstable_now=function(){return s.now()}}else{var a=Date,o=a.now();r.unstable_now=function(){return a.now()-o}}var u=[],h=[],p=1,m=null,y=3,v=!1,S=!1,T=!1,E=typeof setTimeout=="function"?setTimeout:null,w=typeof clearTimeout=="function"?clearTimeout:null,C=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function A(Z){for(var re=t(h);re!==null;){if(re.callback===null)n(h);else if(re.startTime<=Z)n(h),re.sortIndex=re.expirationTime,e(u,re);else break;re=t(h)}}function I(Z){if(T=!1,A(Z),!S)if(t(u)!==null)S=!0,de(F);else{var re=t(h);re!==null&&me(I,re.startTime-Z)}}function F(Z,re){S=!1,T&&(T=!1,w(G),G=-1),v=!0;var ee=y;try{for(A(re),m=t(u);m!==null&&(!(m.expirationTime>re)||Z&&!O());){var z=m.callback;if(typeof z=="function"){m.callback=null,y=m.priorityLevel;var q=z(m.expirationTime<=re);re=r.unstable_now(),typeof q=="function"?m.callback=q:m===t(u)&&n(u),A(re)}else n(u);m=t(u)}if(m!==null)var ve=!0;else{var Ce=t(h);Ce!==null&&me(I,Ce.startTime-re),ve=!1}return ve}finally{m=null,y=ee,v=!1}}var U=!1,V=null,G=-1,L=5,k=-1;function O(){return!(r.unstable_now()-k<L)}function Q(){if(V!==null){var Z=r.unstable_now();k=Z;var re=!0;try{re=V(!0,Z)}finally{re?le():(U=!1,V=null)}}else U=!1}var le;if(typeof C=="function")le=function(){C(Q)};else if(typeof MessageChannel<"u"){var K=new MessageChannel,ce=K.port2;K.port1.onmessage=Q,le=function(){ce.postMessage(null)}}else le=function(){E(Q,0)};function de(Z){V=Z,U||(U=!0,le())}function me(Z,re){G=E(function(){Z(r.unstable_now())},re)}r.unstable_IdlePriority=5,r.unstable_ImmediatePriority=1,r.unstable_LowPriority=4,r.unstable_NormalPriority=3,r.unstable_Profiling=null,r.unstable_UserBlockingPriority=2,r.unstable_cancelCallback=function(Z){Z.callback=null},r.unstable_continueExecution=function(){S||v||(S=!0,de(F))},r.unstable_forceFrameRate=function(Z){0>Z||125<Z?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):L=0<Z?Math.floor(1e3/Z):5},r.unstable_getCurrentPriorityLevel=function(){return y},r.unstable_getFirstCallbackNode=function(){return t(u)},r.unstable_next=function(Z){switch(y){case 1:case 2:case 3:var re=3;break;default:re=y}var ee=y;y=re;try{return Z()}finally{y=ee}},r.unstable_pauseExecution=function(){},r.unstable_requestPaint=function(){},r.unstable_runWithPriority=function(Z,re){switch(Z){case 1:case 2:case 3:case 4:case 5:break;default:Z=3}var ee=y;y=Z;try{return re()}finally{y=ee}},r.unstable_scheduleCallback=function(Z,re,ee){var z=r.unstable_now();switch(typeof ee=="object"&&ee!==null?(ee=ee.delay,ee=typeof ee=="number"&&0<ee?z+ee:z):ee=z,Z){case 1:var q=-1;break;case 2:q=250;break;case 5:q=1073741823;break;case 4:q=1e4;break;default:q=5e3}return q=ee+q,Z={id:p++,callback:re,priorityLevel:Z,startTime:ee,expirationTime:q,sortIndex:-1},ee>z?(Z.sortIndex=ee,e(h,Z),t(u)===null&&Z===t(h)&&(T?(w(G),G=-1):T=!0,me(I,ee-z))):(Z.sortIndex=q,e(u,Z),S||v||(S=!0,de(F))),Z},r.unstable_shouldYield=O,r.unstable_wrapCallback=function(Z){var re=y;return function(){var ee=y;y=re;try{return Z.apply(this,arguments)}finally{y=ee}}}}(P_)),P_}var Vb;function t2(){return Vb||(Vb=1,I_.exports=p4()),I_.exports}/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var L_,Hb;function m4(){return Hb||(Hb=1,L_=function(e){var t={},n=_0(),i=t2(),s=Object.assign;function a(f){for(var d="https://reactjs.org/docs/error-decoder.html?invariant="+f,_=1;_<arguments.length;_++)d+="&args[]="+encodeURIComponent(arguments[_]);return"Minified React error #"+f+"; visit "+d+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var o=n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,u=Symbol.for("react.element"),h=Symbol.for("react.portal"),p=Symbol.for("react.fragment"),m=Symbol.for("react.strict_mode"),y=Symbol.for("react.profiler"),v=Symbol.for("react.provider"),S=Symbol.for("react.context"),T=Symbol.for("react.forward_ref"),E=Symbol.for("react.suspense"),w=Symbol.for("react.suspense_list"),C=Symbol.for("react.memo"),A=Symbol.for("react.lazy"),I=Symbol.for("react.offscreen"),F=Symbol.iterator;function U(f){return f===null||typeof f!="object"?null:(f=F&&f[F]||f["@@iterator"],typeof f=="function"?f:null)}function V(f){if(f==null)return null;if(typeof f=="function")return f.displayName||f.name||null;if(typeof f=="string")return f;switch(f){case p:return"Fragment";case h:return"Portal";case y:return"Profiler";case m:return"StrictMode";case E:return"Suspense";case w:return"SuspenseList"}if(typeof f=="object")switch(f.$$typeof){case S:return(f.displayName||"Context")+".Consumer";case v:return(f._context.displayName||"Context")+".Provider";case T:var d=f.render;return f=f.displayName,f||(f=d.displayName||d.name||"",f=f!==""?"ForwardRef("+f+")":"ForwardRef"),f;case C:return d=f.displayName||null,d!==null?d:V(f.type)||"Memo";case A:d=f._payload,f=f._init;try{return V(f(d))}catch{}}return null}function G(f){var d=f.type;switch(f.tag){case 24:return"Cache";case 9:return(d.displayName||"Context")+".Consumer";case 10:return(d._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return f=d.render,f=f.displayName||f.name||"",d.displayName||(f!==""?"ForwardRef("+f+")":"ForwardRef");case 7:return"Fragment";case 5:return d;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return V(d);case 8:return d===m?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof d=="function")return d.displayName||d.name||null;if(typeof d=="string")return d}return null}function L(f){var d=f,_=f;if(f.alternate)for(;d.return;)d=d.return;else{f=d;do d=f,(d.flags&4098)!==0&&(_=d.return),f=d.return;while(f)}return d.tag===3?_:null}function k(f){if(L(f)!==f)throw Error(a(188))}function O(f){var d=f.alternate;if(!d){if(d=L(f),d===null)throw Error(a(188));return d!==f?null:f}for(var _=f,b=d;;){var N=_.return;if(N===null)break;var D=N.alternate;if(D===null){if(b=N.return,b!==null){_=b;continue}break}if(N.child===D.child){for(D=N.child;D;){if(D===_)return k(N),f;if(D===b)return k(N),d;D=D.sibling}throw Error(a(188))}if(_.return!==b.return)_=N,b=D;else{for(var Y=!1,he=N.child;he;){if(he===_){Y=!0,_=N,b=D;break}if(he===b){Y=!0,b=N,_=D;break}he=he.sibling}if(!Y){for(he=D.child;he;){if(he===_){Y=!0,_=D,b=N;break}if(he===b){Y=!0,b=D,_=N;break}he=he.sibling}if(!Y)throw Error(a(189))}}if(_.alternate!==b)throw Error(a(190))}if(_.tag!==3)throw Error(a(188));return _.stateNode.current===_?f:d}function Q(f){return f=O(f),f!==null?le(f):null}function le(f){if(f.tag===5||f.tag===6)return f;for(f=f.child;f!==null;){var d=le(f);if(d!==null)return d;f=f.sibling}return null}function K(f){if(f.tag===5||f.tag===6)return f;for(f=f.child;f!==null;){if(f.tag!==4){var d=K(f);if(d!==null)return d}f=f.sibling}return null}var ce=Array.isArray,de=e.getPublicInstance,me=e.getRootHostContext,Z=e.getChildHostContext,re=e.prepareForCommit,ee=e.resetAfterCommit,z=e.createInstance,q=e.appendInitialChild,ve=e.finalizeInitialChildren,Ce=e.prepareUpdate,ke=e.shouldSetTextContent,We=e.createTextInstance,tt=e.scheduleTimeout,nt=e.cancelTimeout,ut=e.noTimeout,kt=e.isPrimaryRenderer,vt=e.supportsMutation,se=e.supportsPersistence,Ve=e.supportsHydration,Ie=e.getInstanceFromNode,je=e.preparePortalMount,De=e.getCurrentEventPriority,bt=e.detachDeletedInstance,at=e.supportsMicrotasks,dt=e.scheduleMicrotask,Pt=e.supportsTestSelectors,Gt=e.findFiberRoot,wn=e.getBoundingRect,J=e.getTextContent,$=e.isHiddenSubtree,Se=e.matchAccessibilityRole,qe=e.setFocusIfFocusable,Oe=e.setupIntersectionObserver,He=e.appendChild,St=e.appendChildToContainer,Ke=e.commitTextUpdate,rt=e.commitMount,zt=e.commitUpdate,un=e.insertBefore,Xe=e.insertInContainerBefore,fn=e.removeChild,ae=e.removeChildFromContainer,Ne=e.resetTextContent,ze=e.hideInstance,Fe=e.hideTextInstance,Ct=e.unhideInstance,ue=e.unhideTextInstance,Qe=e.clearContainer,Ze=e.cloneInstance,Re=e.createContainerChildSet,$e=e.appendChildToContainerChildSet,Et=e.finalizeContainerChildren,Yt=e.replaceContainerChildren,yn=e.cloneHiddenInstance,Zn=e.cloneHiddenTextInstance,an=e.canHydrateInstance,gr=e.canHydrateTextInstance,qr=e.canHydrateSuspenseInstance,Cu=e.isSuspenseInstancePending,Xs=e.isSuspenseInstanceFallback,Ks=e.registerSuspenseInstanceRetry,ys=e.getNextHydratableSibling,Da=e.getFirstHydratableChild,cf=e.getFirstHydratableChildWithinContainer,ff=e.getFirstHydratableChildWithinSuspenseInstance,pd=e.hydrateInstance,Ys=e.hydrateTextInstance,hf=e.hydrateSuspenseInstance,W=e.getNextHydratableInstanceAfterSuspenseInstance,ge=e.commitHydratedContainer,Ee=e.commitHydratedSuspenseInstance,Te=e.clearSuspenseBoundary,Me=e.clearSuspenseBoundaryFromContainer,ft=e.shouldDeleteUnhydratedTailInstances,Rt=e.didNotMatchHydratedContainerTextInstance,Dt=e.didNotMatchHydratedTextInstance,ht;function Wt(f){if(ht===void 0)try{throw Error()}catch(_){var d=_.stack.trim().match(/\n( *(at )?)/);ht=d&&d[1]||""}return`
`+ht+f}var Bt=!1;function $t(f,d){if(!f||Bt)return"";Bt=!0;var _=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(d)if(d=function(){throw Error()},Object.defineProperty(d.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(d,[])}catch(Ye){var b=Ye}Reflect.construct(f,[],d)}else{try{d.call()}catch(Ye){b=Ye}f.call(d.prototype)}else{try{throw Error()}catch(Ye){b=Ye}f()}}catch(Ye){if(Ye&&b&&typeof Ye.stack=="string"){for(var N=Ye.stack.split(`
`),D=b.stack.split(`
`),Y=N.length-1,he=D.length-1;1<=Y&&0<=he&&N[Y]!==D[he];)he--;for(;1<=Y&&0<=he;Y--,he--)if(N[Y]!==D[he]){if(Y!==1||he!==1)do if(Y--,he--,0>he||N[Y]!==D[he]){var Ae=`
`+N[Y].replace(" at new "," at ");return f.displayName&&Ae.includes("<anonymous>")&&(Ae=Ae.replace("<anonymous>",f.displayName)),Ae}while(1<=Y&&0<=he);break}}}finally{Bt=!1,Error.prepareStackTrace=_}return(f=f?f.displayName||f.name:"")?Wt(f):""}var In=Object.prototype.hasOwnProperty,kr=[],Pn=-1;function sr(f){return{current:f}}function It(f){0>Pn||(f.current=kr[Pn],kr[Pn]=null,Pn--)}function xt(f,d){Pn++,kr[Pn]=f.current,f.current=d}var Jn={},on=sr(Jn),Qn=sr(!1),Ls=Jn;function ni(f,d){var _=f.type.contextTypes;if(!_)return Jn;var b=f.stateNode;if(b&&b.__reactInternalMemoizedUnmaskedChildContext===d)return b.__reactInternalMemoizedMaskedChildContext;var N={},D;for(D in _)N[D]=d[D];return b&&(f=f.stateNode,f.__reactInternalMemoizedUnmaskedChildContext=d,f.__reactInternalMemoizedMaskedChildContext=N),N}function ar(f){return f=f.childContextTypes,f!=null}function Gn(){It(Qn),It(on)}function Pi(f,d,_){if(on.current!==Jn)throw Error(a(168));xt(on,d),xt(Qn,_)}function ml(f,d,_){var b=f.stateNode;if(d=d.childContextTypes,typeof b.getChildContext!="function")return _;b=b.getChildContext();for(var N in b)if(!(N in d))throw Error(a(108,G(f)||"Unknown",N));return s({},_,b)}function Mr(f){return f=(f=f.stateNode)&&f.__reactInternalMemoizedMergedChildContext||Jn,Ls=on.current,xt(on,f),xt(Qn,Qn.current),!0}function Oa(f,d,_){var b=f.stateNode;if(!b)throw Error(a(169));_?(f=ml(f,d,Ls),b.__reactInternalMemoizedMergedChildContext=f,It(Qn),It(on),xt(on,f)):It(Qn),xt(Qn,_)}var pi=Math.clz32?Math.clz32:dv,gl=Math.log,Ru=Math.LN2;function dv(f){return f>>>=0,f===0?32:31-(gl(f)/Ru|0)|0}var yl=64,mn=4194304;function vl(f){switch(f&-f){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return f&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return f&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return f}}function Iu(f,d){var _=f.pendingLanes;if(_===0)return 0;var b=0,N=f.suspendedLanes,D=f.pingedLanes,Y=_&268435455;if(Y!==0){var he=Y&~N;he!==0?b=vl(he):(D&=Y,D!==0&&(b=vl(D)))}else Y=_&~N,Y!==0?b=vl(Y):D!==0&&(b=vl(D));if(b===0)return 0;if(d!==0&&d!==b&&(d&N)===0&&(N=b&-b,D=d&-d,N>=D||N===16&&(D&4194240)!==0))return d;if((b&4)!==0&&(b|=_&16),d=f.entangledLanes,d!==0)for(f=f.entanglements,d&=b;0<d;)_=31-pi(d),N=1<<_,b|=f[_],d&=~N;return b}function md(f,d){switch(f){case 1:case 2:case 4:return d+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return d+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function $m(f,d){for(var _=f.suspendedLanes,b=f.pingedLanes,N=f.expirationTimes,D=f.pendingLanes;0<D;){var Y=31-pi(D),he=1<<Y,Ae=N[Y];Ae===-1?((he&_)===0||(he&b)!==0)&&(N[Y]=md(he,d)):Ae<=d&&(f.expiredLanes|=he),D&=~he}}function df(f){return f=f.pendingLanes&-1073741825,f!==0?f:f&1073741824?1073741824:0}function pf(f){for(var d=[],_=0;31>_;_++)d.push(f);return d}function ho(f,d,_){f.pendingLanes|=d,d!==536870912&&(f.suspendedLanes=0,f.pingedLanes=0),f=f.eventTimes,d=31-pi(d),f[d]=_}function mf(f,d){var _=f.pendingLanes&~d;f.pendingLanes=d,f.suspendedLanes=0,f.pingedLanes=0,f.expiredLanes&=d,f.mutableReadLanes&=d,f.entangledLanes&=d,d=f.entanglements;var b=f.eventTimes;for(f=f.expirationTimes;0<_;){var N=31-pi(_),D=1<<N;d[N]=0,b[N]=-1,f[N]=-1,_&=~D}}function ks(f,d){var _=f.entangledLanes|=d;for(f=f.entanglements;_;){var b=31-pi(_),N=1<<b;N&d|f[b]&d&&(f[b]|=d),_&=~N}}var en=0;function Zs(f){return f&=-f,1<f?4<f?(f&268435455)!==0?16:536870912:4:1}var po=i.unstable_scheduleCallback,_l=i.unstable_cancelCallback,Fa=i.unstable_shouldYield,pv=i.unstable_requestPaint,yr=i.unstable_now,mo=i.unstable_ImmediatePriority,mv=i.unstable_UserBlockingPriority,gf=i.unstable_NormalPriority,yf=i.unstable_IdlePriority,Pu=null,Ds=null;function Lu(f){if(Ds&&typeof Ds.onCommitFiberRoot=="function")try{Ds.onCommitFiberRoot(Pu,f,void 0,(f.current.flags&128)===128)}catch{}}function ku(f,d){return f===d&&(f!==0||1/f===1/d)||f!==f&&d!==d}var ri=typeof Object.is=="function"?Object.is:ku,Xi=null,vf=!1,gd=!1;function _f(f){Xi===null?Xi=[f]:Xi.push(f)}function xf(f){vf=!0,_f(f)}function Ki(){if(!gd&&Xi!==null){gd=!0;var f=0,d=en;try{var _=Xi;for(en=1;f<_.length;f++){var b=_[f];do b=b(!0);while(b!==null)}Xi=null,vf=!1}catch(N){throw Xi!==null&&(Xi=Xi.slice(f+1)),po(mo,Ki),N}finally{en=d,gd=!1}}return null}var Gm=o.ReactCurrentBatchConfig;function vs(f,d){if(ri(f,d))return!0;if(typeof f!="object"||f===null||typeof d!="object"||d===null)return!1;var _=Object.keys(f),b=Object.keys(d);if(_.length!==b.length)return!1;for(b=0;b<_.length;b++){var N=_[b];if(!In.call(d,N)||!ri(f[N],d[N]))return!1}return!0}function yd(f){switch(f.tag){case 5:return Wt(f.type);case 16:return Wt("Lazy");case 13:return Wt("Suspense");case 19:return Wt("SuspenseList");case 0:case 2:case 15:return f=$t(f.type,!1),f;case 11:return f=$t(f.type.render,!1),f;case 1:return f=$t(f.type,!0),f;default:return""}}function mi(f,d){if(f&&f.defaultProps){d=s({},d),f=f.defaultProps;for(var _ in f)d[_]===void 0&&(d[_]=f[_]);return d}return d}var Du=sr(null),go=null,Js=null,Sf=null;function ii(){Sf=Js=go=null}function yo(f,d,_){kt?(xt(Du,d._currentValue),d._currentValue=_):(xt(Du,d._currentValue2),d._currentValue2=_)}function Ou(f){var d=Du.current;It(Du),kt?f._currentValue=d:f._currentValue2=d}function vo(f,d,_){for(;f!==null;){var b=f.alternate;if((f.childLanes&d)!==d?(f.childLanes|=d,b!==null&&(b.childLanes|=d)):b!==null&&(b.childLanes&d)!==d&&(b.childLanes|=d),f===_)break;f=f.return}}function xl(f,d){go=f,Sf=Js=null,f=f.dependencies,f!==null&&f.firstContext!==null&&((f.lanes&d)!==0&&(Rr=!0),f.firstContext=null)}function gi(f){var d=kt?f._currentValue:f._currentValue2;if(Sf!==f)if(f={context:f,memoizedValue:d,next:null},Js===null){if(go===null)throw Error(a(308));Js=f,go.dependencies={lanes:0,firstContext:f}}else Js=Js.next=f;return d}var Yi=null,Zi=!1;function Sl(f){f.updateQueue={baseState:f.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function vd(f,d){f=f.updateQueue,d.updateQueue===f&&(d.updateQueue={baseState:f.baseState,firstBaseUpdate:f.firstBaseUpdate,lastBaseUpdate:f.lastBaseUpdate,shared:f.shared,effects:f.effects})}function Qs(f,d){return{eventTime:f,lane:d,tag:0,payload:null,callback:null,next:null}}function Ua(f,d){var _=f.updateQueue;_!==null&&(_=_.shared,lr!==null&&(f.mode&1)!==0&&(Zt&2)===0?(f=_.interleaved,f===null?(d.next=d,Yi===null?Yi=[_]:Yi.push(_)):(d.next=f.next,f.next=d),_.interleaved=d):(f=_.pending,f===null?d.next=d:(d.next=f.next,f.next=d),_.pending=d))}function wf(f,d,_){if(d=d.updateQueue,d!==null&&(d=d.shared,(_&4194240)!==0)){var b=d.lanes;b&=f.pendingLanes,_|=b,d.lanes=_,ks(f,_)}}function Ef(f,d){var _=f.updateQueue,b=f.alternate;if(b!==null&&(b=b.updateQueue,_===b)){var N=null,D=null;if(_=_.firstBaseUpdate,_!==null){do{var Y={eventTime:_.eventTime,lane:_.lane,tag:_.tag,payload:_.payload,callback:_.callback,next:null};D===null?N=D=Y:D=D.next=Y,_=_.next}while(_!==null);D===null?N=D=d:D=D.next=d}else N=D=d;_={baseState:b.baseState,firstBaseUpdate:N,lastBaseUpdate:D,shared:b.shared,effects:b.effects},f.updateQueue=_;return}f=_.lastBaseUpdate,f===null?_.firstBaseUpdate=d:f.next=d,_.lastBaseUpdate=d}function bf(f,d,_,b){var N=f.updateQueue;Zi=!1;var D=N.firstBaseUpdate,Y=N.lastBaseUpdate,he=N.shared.pending;if(he!==null){N.shared.pending=null;var Ae=he,Ye=Ae.next;Ae.next=null,Y===null?D=Ye:Y.next=Ye,Y=Ae;var mt=f.alternate;mt!==null&&(mt=mt.updateQueue,he=mt.lastBaseUpdate,he!==Y&&(he===null?mt.firstBaseUpdate=Ye:he.next=Ye,mt.lastBaseUpdate=Ae))}if(D!==null){var qt=N.baseState;Y=0,mt=Ye=Ae=null,he=D;do{var Lt=he.lane,Qt=he.eventTime;if((b&Lt)===Lt){mt!==null&&(mt=mt.next={eventTime:Qt,lane:0,tag:he.tag,payload:he.payload,callback:he.callback,next:null});e:{var ct=f,Br=he;switch(Lt=d,Qt=_,Br.tag){case 1:if(ct=Br.payload,typeof ct=="function"){qt=ct.call(Qt,qt,Lt);break e}qt=ct;break e;case 3:ct.flags=ct.flags&-65537|128;case 0:if(ct=Br.payload,Lt=typeof ct=="function"?ct.call(Qt,qt,Lt):ct,Lt==null)break e;qt=s({},qt,Lt);break e;case 2:Zi=!0}}he.callback!==null&&he.lane!==0&&(f.flags|=64,Lt=N.effects,Lt===null?N.effects=[he]:Lt.push(he))}else Qt={eventTime:Qt,lane:Lt,tag:he.tag,payload:he.payload,callback:he.callback,next:null},mt===null?(Ye=mt=Qt,Ae=qt):mt=mt.next=Qt,Y|=Lt;if(he=he.next,he===null){if(he=N.shared.pending,he===null)break;Lt=he,he=Lt.next,Lt.next=null,N.lastBaseUpdate=Lt,N.shared.pending=null}}while(!0);if(mt===null&&(Ae=qt),N.baseState=Ae,N.firstBaseUpdate=Ye,N.lastBaseUpdate=mt,d=N.shared.interleaved,d!==null){N=d;do Y|=N.lane,N=N.next;while(N!==d)}else D===null&&(N.shared.lanes=0);zs|=Y,f.lanes=Y,f.memoizedState=qt}}function Wm(f,d,_){if(f=d.effects,d.effects=null,f!==null)for(d=0;d<f.length;d++){var b=f[d],N=b.callback;if(N!==null){if(b.callback=null,b=_,typeof N!="function")throw Error(a(191,N));N.call(b)}}}var jm=new n.Component().refs;function _d(f,d,_,b){d=f.memoizedState,_=_(b,d),_=_==null?d:s({},d,_),f.memoizedState=_,f.lanes===0&&(f.updateQueue.baseState=_)}var Tf={isMounted:function(f){return(f=f._reactInternals)?L(f)===f:!1},enqueueSetState:function(f,d,_){f=f._reactInternals;var b=gn(),N=Ts(f),D=Qs(b,N);D.payload=d,_!=null&&(D.callback=_),Ua(f,D),d=Yr(f,N,b),d!==null&&wf(d,f,N)},enqueueReplaceState:function(f,d,_){f=f._reactInternals;var b=gn(),N=Ts(f),D=Qs(b,N);D.tag=1,D.payload=d,_!=null&&(D.callback=_),Ua(f,D),d=Yr(f,N,b),d!==null&&wf(d,f,N)},enqueueForceUpdate:function(f,d){f=f._reactInternals;var _=gn(),b=Ts(f),N=Qs(_,b);N.tag=2,d!=null&&(N.callback=d),Ua(f,N),d=Yr(f,b,_),d!==null&&wf(d,f,b)}};function xd(f,d,_,b,N,D,Y){return f=f.stateNode,typeof f.shouldComponentUpdate=="function"?f.shouldComponentUpdate(b,D,Y):d.prototype&&d.prototype.isPureReactComponent?!vs(_,b)||!vs(N,D):!0}function qm(f,d,_){var b=!1,N=Jn,D=d.contextType;return typeof D=="object"&&D!==null?D=gi(D):(N=ar(d)?Ls:on.current,b=d.contextTypes,D=(b=b!=null)?ni(f,N):Jn),d=new d(_,D),f.memoizedState=d.state!==null&&d.state!==void 0?d.state:null,d.updater=Tf,f.stateNode=d,d._reactInternals=f,b&&(f=f.stateNode,f.__reactInternalMemoizedUnmaskedChildContext=N,f.__reactInternalMemoizedMaskedChildContext=D),d}function Xm(f,d,_,b){f=d.state,typeof d.componentWillReceiveProps=="function"&&d.componentWillReceiveProps(_,b),typeof d.UNSAFE_componentWillReceiveProps=="function"&&d.UNSAFE_componentWillReceiveProps(_,b),d.state!==f&&Tf.enqueueReplaceState(d,d.state,null)}function Sd(f,d,_,b){var N=f.stateNode;N.props=_,N.state=f.memoizedState,N.refs=jm,Sl(f);var D=d.contextType;typeof D=="object"&&D!==null?N.context=gi(D):(D=ar(d)?Ls:on.current,N.context=ni(f,D)),N.state=f.memoizedState,D=d.getDerivedStateFromProps,typeof D=="function"&&(_d(f,d,D,_),N.state=f.memoizedState),typeof d.getDerivedStateFromProps=="function"||typeof N.getSnapshotBeforeUpdate=="function"||typeof N.UNSAFE_componentWillMount!="function"&&typeof N.componentWillMount!="function"||(d=N.state,typeof N.componentWillMount=="function"&&N.componentWillMount(),typeof N.UNSAFE_componentWillMount=="function"&&N.UNSAFE_componentWillMount(),d!==N.state&&Tf.enqueueReplaceState(N,N.state,null),bf(f,_,N,b),N.state=f.memoizedState),typeof N.componentDidMount=="function"&&(f.flags|=4194308)}var wl=[],za=0,Mf=null,Af=0,Ji=[],Li=0,_o=null,ea=1,ta="";function xo(f,d){wl[za++]=Af,wl[za++]=Mf,Mf=f,Af=d}function Km(f,d,_){Ji[Li++]=ea,Ji[Li++]=ta,Ji[Li++]=_o,_o=f;var b=ea;f=ta;var N=32-pi(b)-1;b&=~(1<<N),_+=1;var D=32-pi(d)+N;if(30<D){var Y=N-N%5;D=(b&(1<<Y)-1).toString(32),b>>=Y,N-=Y,ea=1<<32-pi(d)+N|_<<N|b,ta=D+f}else ea=1<<D|_<<N|b,ta=f}function wd(f){f.return!==null&&(xo(f,1),Km(f,1,0))}function Ed(f){for(;f===Mf;)Mf=wl[--za],wl[za]=null,Af=wl[--za],wl[za]=null;for(;f===_o;)_o=Ji[--Li],Ji[Li]=null,ta=Ji[--Li],Ji[Li]=null,ea=Ji[--Li],Ji[Li]=null}var si=null,Dr=null,Wn=!1,El=!1,Qi=null;function bd(f,d){var _=Bi(5,null,null,0);_.elementType="DELETED",_.stateNode=d,_.return=f,d=f.deletions,d===null?(f.deletions=[_],f.flags|=16):d.push(_)}function Td(f,d){switch(f.tag){case 5:return d=an(d,f.type,f.pendingProps),d!==null?(f.stateNode=d,si=f,Dr=Da(d),!0):!1;case 6:return d=gr(d,f.pendingProps),d!==null?(f.stateNode=d,si=f,Dr=null,!0):!1;case 13:if(d=qr(d),d!==null){var _=_o!==null?{id:ea,overflow:ta}:null;return f.memoizedState={dehydrated:d,treeContext:_,retryLane:1073741824},_=Bi(18,null,null,0),_.stateNode=d,_.return=f,f.child=_,si=f,Dr=null,!0}return!1;default:return!1}}function Nf(f){return(f.mode&1)!==0&&(f.flags&128)===0}function Ba(f){if(Wn){var d=Dr;if(d){var _=d;if(!Td(f,d)){if(Nf(f))throw Error(a(418));d=ys(_);var b=si;d&&Td(f,d)?bd(b,_):(f.flags=f.flags&-4097|2,Wn=!1,si=f)}}else{if(Nf(f))throw Error(a(418));f.flags=f.flags&-4097|2,Wn=!1,si=f}}}function Ym(f){for(f=f.return;f!==null&&f.tag!==5&&f.tag!==3&&f.tag!==13;)f=f.return;si=f}function Fu(f){if(!Ve||f!==si)return!1;if(!Wn)return Ym(f),Wn=!0,!1;if(f.tag!==3&&(f.tag!==5||ft(f.type)&&!ke(f.type,f.memoizedProps))){var d=Dr;if(d){if(Nf(f)){for(f=Dr;f;)f=ys(f);throw Error(a(418))}for(;d;)bd(f,d),d=ys(d)}}if(Ym(f),f.tag===13){if(!Ve)throw Error(a(316));if(f=f.memoizedState,f=f!==null?f.dehydrated:null,!f)throw Error(a(317));Dr=W(f)}else Dr=si?ys(f.stateNode):null;return!0}function bl(){Ve&&(Dr=si=null,El=Wn=!1)}function Cf(f){Qi===null?Qi=[f]:Qi.push(f)}function Tl(f,d,_){if(f=_.ref,f!==null&&typeof f!="function"&&typeof f!="object"){if(_._owner){if(_=_._owner,_){if(_.tag!==1)throw Error(a(309));var b=_.stateNode}if(!b)throw Error(a(147,f));var N=b,D=""+f;return d!==null&&d.ref!==null&&typeof d.ref=="function"&&d.ref._stringRef===D?d.ref:(d=function(Y){var he=N.refs;he===jm&&(he=N.refs={}),Y===null?delete he[D]:he[D]=Y},d._stringRef=D,d)}if(typeof f!="string")throw Error(a(284));if(!_._owner)throw Error(a(290,f))}return f}function Va(f,d){throw f=Object.prototype.toString.call(d),Error(a(31,f==="[object Object]"?"object with keys {"+Object.keys(d).join(", ")+"}":f))}function Ml(f){var d=f._init;return d(f._payload)}function Zm(f){function d(xe,pe){if(f){var be=xe.deletions;be===null?(xe.deletions=[pe],xe.flags|=16):be.push(pe)}}function _(xe,pe){if(!f)return null;for(;pe!==null;)d(xe,pe),pe=pe.sibling;return null}function b(xe,pe){for(xe=new Map;pe!==null;)pe.key!==null?xe.set(pe.key,pe):xe.set(pe.index,pe),pe=pe.sibling;return xe}function N(xe,pe){return xe=ma(xe,pe),xe.index=0,xe.sibling=null,xe}function D(xe,pe,be){return xe.index=be,f?(be=xe.alternate,be!==null?(be=be.index,be<pe?(xe.flags|=2,pe):be):(xe.flags|=2,pe)):(xe.flags|=1048576,pe)}function Y(xe){return f&&xe.alternate===null&&(xe.flags|=2),xe}function he(xe,pe,be,ot){return pe===null||pe.tag!==6?(pe=nh(be,xe.mode,ot),pe.return=xe,pe):(pe=N(pe,be),pe.return=xe,pe)}function Ae(xe,pe,be,ot){var Mt=be.type;return Mt===p?mt(xe,pe,be.props.children,ot,be.key):pe!==null&&(pe.elementType===Mt||typeof Mt=="object"&&Mt!==null&&Mt.$$typeof===A&&Ml(Mt)===pe.type)?(ot=N(pe,be.props),ot.ref=Tl(xe,pe,be),ot.return=xe,ot):(ot=th(be.type,be.key,be.props,null,xe.mode,ot),ot.ref=Tl(xe,pe,be),ot.return=xe,ot)}function Ye(xe,pe,be,ot){return pe===null||pe.tag!==4||pe.stateNode.containerInfo!==be.containerInfo||pe.stateNode.implementation!==be.implementation?(pe=rh(be,xe.mode,ot),pe.return=xe,pe):(pe=N(pe,be.children||[]),pe.return=xe,pe)}function mt(xe,pe,be,ot,Mt){return pe===null||pe.tag!==7?(pe=Ho(be,xe.mode,ot,Mt),pe.return=xe,pe):(pe=N(pe,be),pe.return=xe,pe)}function qt(xe,pe,be){if(typeof pe=="string"&&pe!==""||typeof pe=="number")return pe=nh(""+pe,xe.mode,be),pe.return=xe,pe;if(typeof pe=="object"&&pe!==null){switch(pe.$$typeof){case u:return be=th(pe.type,pe.key,pe.props,null,xe.mode,be),be.ref=Tl(xe,null,pe),be.return=xe,be;case h:return pe=rh(pe,xe.mode,be),pe.return=xe,pe;case A:var ot=pe._init;return qt(xe,ot(pe._payload),be)}if(ce(pe)||U(pe))return pe=Ho(pe,xe.mode,be,null),pe.return=xe,pe;Va(xe,pe)}return null}function Lt(xe,pe,be,ot){var Mt=pe!==null?pe.key:null;if(typeof be=="string"&&be!==""||typeof be=="number")return Mt!==null?null:he(xe,pe,""+be,ot);if(typeof be=="object"&&be!==null){switch(be.$$typeof){case u:return be.key===Mt?Ae(xe,pe,be,ot):null;case h:return be.key===Mt?Ye(xe,pe,be,ot):null;case A:return Mt=be._init,Lt(xe,pe,Mt(be._payload),ot)}if(ce(be)||U(be))return Mt!==null?null:mt(xe,pe,be,ot,null);Va(xe,be)}return null}function Qt(xe,pe,be,ot,Mt){if(typeof ot=="string"&&ot!==""||typeof ot=="number")return xe=xe.get(be)||null,he(pe,xe,""+ot,Mt);if(typeof ot=="object"&&ot!==null){switch(ot.$$typeof){case u:return xe=xe.get(ot.key===null?be:ot.key)||null,Ae(pe,xe,ot,Mt);case h:return xe=xe.get(ot.key===null?be:ot.key)||null,Ye(pe,xe,ot,Mt);case A:var Kt=ot._init;return Qt(xe,pe,be,Kt(ot._payload),Mt)}if(ce(ot)||U(ot))return xe=xe.get(be)||null,mt(pe,xe,ot,Mt,null);Va(pe,ot)}return null}function ct(xe,pe,be,ot){for(var Mt=null,Kt=null,Xt=pe,pn=pe=0,hr=null;Xt!==null&&pn<be.length;pn++){Xt.index>pn?(hr=Xt,Xt=null):hr=Xt.sibling;var hn=Lt(xe,Xt,be[pn],ot);if(hn===null){Xt===null&&(Xt=hr);break}f&&Xt&&hn.alternate===null&&d(xe,Xt),pe=D(hn,pe,pn),Kt===null?Mt=hn:Kt.sibling=hn,Kt=hn,Xt=hr}if(pn===be.length)return _(xe,Xt),Wn&&xo(xe,pn),Mt;if(Xt===null){for(;pn<be.length;pn++)Xt=qt(xe,be[pn],ot),Xt!==null&&(pe=D(Xt,pe,pn),Kt===null?Mt=Xt:Kt.sibling=Xt,Kt=Xt);return Wn&&xo(xe,pn),Mt}for(Xt=b(xe,Xt);pn<be.length;pn++)hr=Qt(Xt,xe,pn,be[pn],ot),hr!==null&&(f&&hr.alternate!==null&&Xt.delete(hr.key===null?pn:hr.key),pe=D(hr,pe,pn),Kt===null?Mt=hr:Kt.sibling=hr,Kt=hr);return f&&Xt.forEach(function(ga){return d(xe,ga)}),Wn&&xo(xe,pn),Mt}function Br(xe,pe,be,ot){var Mt=U(be);if(typeof Mt!="function")throw Error(a(150));if(be=Mt.call(be),be==null)throw Error(a(151));for(var Kt=Mt=null,Xt=pe,pn=pe=0,hr=null,hn=be.next();Xt!==null&&!hn.done;pn++,hn=be.next()){Xt.index>pn?(hr=Xt,Xt=null):hr=Xt.sibling;var ga=Lt(xe,Xt,hn.value,ot);if(ga===null){Xt===null&&(Xt=hr);break}f&&Xt&&ga.alternate===null&&d(xe,Xt),pe=D(ga,pe,pn),Kt===null?Mt=ga:Kt.sibling=ga,Kt=ga,Xt=hr}if(hn.done)return _(xe,Xt),Wn&&xo(xe,pn),Mt;if(Xt===null){for(;!hn.done;pn++,hn=be.next())hn=qt(xe,hn.value,ot),hn!==null&&(pe=D(hn,pe,pn),Kt===null?Mt=hn:Kt.sibling=hn,Kt=hn);return Wn&&xo(xe,pn),Mt}for(Xt=b(xe,Xt);!hn.done;pn++,hn=be.next())hn=Qt(Xt,xe,pn,hn.value,ot),hn!==null&&(f&&hn.alternate!==null&&Xt.delete(hn.key===null?pn:hn.key),pe=D(hn,pe,pn),Kt===null?Mt=hn:Kt.sibling=hn,Kt=hn);return f&&Xt.forEach(function(np){return d(xe,np)}),Wn&&xo(xe,pn),Mt}function Vi(xe,pe,be,ot){if(typeof be=="object"&&be!==null&&be.type===p&&be.key===null&&(be=be.props.children),typeof be=="object"&&be!==null){switch(be.$$typeof){case u:e:{for(var Mt=be.key,Kt=pe;Kt!==null;){if(Kt.key===Mt){if(Mt=be.type,Mt===p){if(Kt.tag===7){_(xe,Kt.sibling),pe=N(Kt,be.props.children),pe.return=xe,xe=pe;break e}}else if(Kt.elementType===Mt||typeof Mt=="object"&&Mt!==null&&Mt.$$typeof===A&&Ml(Mt)===Kt.type){_(xe,Kt.sibling),pe=N(Kt,be.props),pe.ref=Tl(xe,Kt,be),pe.return=xe,xe=pe;break e}_(xe,Kt);break}else d(xe,Kt);Kt=Kt.sibling}be.type===p?(pe=Ho(be.props.children,xe.mode,ot,be.key),pe.return=xe,xe=pe):(ot=th(be.type,be.key,be.props,null,xe.mode,ot),ot.ref=Tl(xe,pe,be),ot.return=xe,xe=ot)}return Y(xe);case h:e:{for(Kt=be.key;pe!==null;){if(pe.key===Kt)if(pe.tag===4&&pe.stateNode.containerInfo===be.containerInfo&&pe.stateNode.implementation===be.implementation){_(xe,pe.sibling),pe=N(pe,be.children||[]),pe.return=xe,xe=pe;break e}else{_(xe,pe);break}else d(xe,pe);pe=pe.sibling}pe=rh(be,xe.mode,ot),pe.return=xe,xe=pe}return Y(xe);case A:return Kt=be._init,Vi(xe,pe,Kt(be._payload),ot)}if(ce(be))return ct(xe,pe,be,ot);if(U(be))return Br(xe,pe,be,ot);Va(xe,be)}return typeof be=="string"&&be!==""||typeof be=="number"?(be=""+be,pe!==null&&pe.tag===6?(_(xe,pe.sibling),pe=N(pe,be),pe.return=xe,xe=pe):(_(xe,pe),pe=nh(be,xe.mode,ot),pe.return=xe,xe=pe),Y(xe)):_(xe,pe)}return Vi}var na=Zm(!0),Jm=Zm(!1),Al={},yi=sr(Al),So=sr(Al),wo=sr(Al);function _s(f){if(f===Al)throw Error(a(174));return f}function Rf(f,d){xt(wo,d),xt(So,f),xt(yi,Al),f=me(d),It(yi),xt(yi,f)}function Nl(){It(yi),It(So),It(wo)}function Qm(f){var d=_s(wo.current),_=_s(yi.current);d=Z(_,f.type,d),_!==d&&(xt(So,f),xt(yi,d))}function Md(f){So.current===f&&(It(yi),It(So))}var Xn=sr(0);function If(f){for(var d=f;d!==null;){if(d.tag===13){var _=d.memoizedState;if(_!==null&&(_=_.dehydrated,_===null||Cu(_)||Xs(_)))return d}else if(d.tag===19&&d.memoizedProps.revealOrder!==void 0){if((d.flags&128)!==0)return d}else if(d.child!==null){d.child.return=d,d=d.child;continue}if(d===f)break;for(;d.sibling===null;){if(d.return===null||d.return===f)return null;d=d.return}d.sibling.return=d.return,d=d.sibling}return null}var ki=[];function Eo(){for(var f=0;f<ki.length;f++){var d=ki[f];kt?d._workInProgressVersionPrimary=null:d._workInProgressVersionSecondary=null}ki.length=0}var Uu=o.ReactCurrentDispatcher,Di=o.ReactCurrentBatchConfig,bo=0,Kn=null,Ar=null,Nr=null,Pf=!1,Os=!1,To=0,zu=0;function Cr(){throw Error(a(321))}function Lf(f,d){if(d===null)return!1;for(var _=0;_<d.length&&_<f.length;_++)if(!ri(f[_],d[_]))return!1;return!0}function Cl(f,d,_,b,N,D){if(bo=D,Kn=d,d.memoizedState=null,d.updateQueue=null,d.lanes=0,Uu.current=f===null||f.memoizedState===null?Pd:Ld,f=_(b,N),Os){D=0;do{if(Os=!1,To=0,25<=D)throw Error(a(301));D+=1,Nr=Ar=null,d.updateQueue=null,Uu.current=kd,f=_(b,N)}while(Os)}if(Uu.current=Ll,d=Ar!==null&&Ar.next!==null,bo=0,Nr=Ar=Kn=null,Pf=!1,d)throw Error(a(300));return f}function Ha(){var f=To!==0;return To=0,f}function xs(){var f={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Nr===null?Kn.memoizedState=Nr=f:Nr=Nr.next=f,Nr}function Ss(){if(Ar===null){var f=Kn.alternate;f=f!==null?f.memoizedState:null}else f=Ar.next;var d=Nr===null?Kn.memoizedState:Nr.next;if(d!==null)Nr=d,Ar=f;else{if(f===null)throw Error(a(310));Ar=f,f={memoizedState:Ar.memoizedState,baseState:Ar.baseState,baseQueue:Ar.baseQueue,queue:Ar.queue,next:null},Nr===null?Kn.memoizedState=Nr=f:Nr=Nr.next=f}return Nr}function Fs(f,d){return typeof d=="function"?d(f):d}function Bu(f){var d=Ss(),_=d.queue;if(_===null)throw Error(a(311));_.lastRenderedReducer=f;var b=Ar,N=b.baseQueue,D=_.pending;if(D!==null){if(N!==null){var Y=N.next;N.next=D.next,D.next=Y}b.baseQueue=N=D,_.pending=null}if(N!==null){D=N.next,b=b.baseState;var he=Y=null,Ae=null,Ye=D;do{var mt=Ye.lane;if((bo&mt)===mt)Ae!==null&&(Ae=Ae.next={lane:0,action:Ye.action,hasEagerState:Ye.hasEagerState,eagerState:Ye.eagerState,next:null}),b=Ye.hasEagerState?Ye.eagerState:f(b,Ye.action);else{var qt={lane:mt,action:Ye.action,hasEagerState:Ye.hasEagerState,eagerState:Ye.eagerState,next:null};Ae===null?(he=Ae=qt,Y=b):Ae=Ae.next=qt,Kn.lanes|=mt,zs|=mt}Ye=Ye.next}while(Ye!==null&&Ye!==D);Ae===null?Y=b:Ae.next=he,ri(b,d.memoizedState)||(Rr=!0),d.memoizedState=b,d.baseState=Y,d.baseQueue=Ae,_.lastRenderedState=b}if(f=_.interleaved,f!==null){N=f;do D=N.lane,Kn.lanes|=D,zs|=D,N=N.next;while(N!==f)}else N===null&&(_.lanes=0);return[d.memoizedState,_.dispatch]}function Vu(f){var d=Ss(),_=d.queue;if(_===null)throw Error(a(311));_.lastRenderedReducer=f;var b=_.dispatch,N=_.pending,D=d.memoizedState;if(N!==null){_.pending=null;var Y=N=N.next;do D=f(D,Y.action),Y=Y.next;while(Y!==N);ri(D,d.memoizedState)||(Rr=!0),d.memoizedState=D,d.baseQueue===null&&(d.baseState=D),_.lastRenderedState=D}return[D,b]}function Ad(){}function Nd(f,d){var _=Kn,b=Ss(),N=d(),D=!ri(b.memoizedState,N);if(D&&(b.memoizedState=N,Rr=!0),b=b.queue,Rl(ra.bind(null,_,b,f),[f]),b.getSnapshot!==d||D||Nr!==null&&Nr.memoizedState.tag&1){if(_.flags|=2048,$u(9,Rd.bind(null,_,b,N,d),void 0,null),lr===null)throw Error(a(349));(bo&30)!==0||Cd(_,d,N)}return N}function Cd(f,d,_){f.flags|=16384,f={getSnapshot:d,value:_},d=Kn.updateQueue,d===null?(d={lastEffect:null,stores:null},Kn.updateQueue=d,d.stores=[f]):(_=d.stores,_===null?d.stores=[f]:_.push(f))}function Rd(f,d,_,b){d.value=_,d.getSnapshot=b,kf(d)&&Yr(f,1,-1)}function ra(f,d,_){return _(function(){kf(d)&&Yr(f,1,-1)})}function kf(f){var d=f.getSnapshot;f=f.value;try{var _=d();return!ri(f,_)}catch{return!0}}function Hu(f){var d=xs();return typeof f=="function"&&(f=f()),d.memoizedState=d.baseState=f,f={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Fs,lastRenderedState:f},d.queue=f,f=f.dispatch=gv.bind(null,Kn,f),[d.memoizedState,f]}function $u(f,d,_,b){return f={tag:f,create:d,destroy:_,deps:b,next:null},d=Kn.updateQueue,d===null?(d={lastEffect:null,stores:null},Kn.updateQueue=d,d.lastEffect=f.next=f):(_=d.lastEffect,_===null?d.lastEffect=f.next=f:(b=_.next,_.next=f,f.next=b,d.lastEffect=f)),f}function eg(){return Ss().memoizedState}function $a(f,d,_,b){var N=xs();Kn.flags|=f,N.memoizedState=$u(1|d,_,void 0,b===void 0?null:b)}function Df(f,d,_,b){var N=Ss();b=b===void 0?null:b;var D=void 0;if(Ar!==null){var Y=Ar.memoizedState;if(D=Y.destroy,b!==null&&Lf(b,Y.deps)){N.memoizedState=$u(d,_,D,b);return}}Kn.flags|=f,N.memoizedState=$u(1|d,_,D,b)}function Of(f,d){return $a(8390656,8,f,d)}function Rl(f,d){return Df(2048,8,f,d)}function Ln(f,d){return Df(4,2,f,d)}function Ff(f,d){return Df(4,4,f,d)}function Gu(f,d){if(typeof d=="function")return f=f(),d(f),function(){d(null)};if(d!=null)return f=f(),d.current=f,function(){d.current=null}}function Il(f,d,_){return _=_!=null?_.concat([f]):null,Df(4,4,Gu.bind(null,d,f),_)}function Uf(){}function zf(f,d){var _=Ss();d=d===void 0?null:d;var b=_.memoizedState;return b!==null&&d!==null&&Lf(d,b[1])?b[0]:(_.memoizedState=[f,d],f)}function Pl(f,d){var _=Ss();d=d===void 0?null:d;var b=_.memoizedState;return b!==null&&d!==null&&Lf(d,b[1])?b[0]:(f=f(),_.memoizedState=[f,d],f)}function Bf(f,d){var _=en;en=_!==0&&4>_?_:4,f(!0);var b=Di.transition;Di.transition={};try{f(!1),d()}finally{en=_,Di.transition=b}}function Mo(){return Ss().memoizedState}function tg(f,d,_){var b=Ts(f);_={lane:b,action:_,hasEagerState:!1,eagerState:null,next:null},ng(f)?Id(d,_):(Wu(f,d,_),_=gn(),f=Yr(f,b,_),f!==null&&ju(f,d,b))}function gv(f,d,_){var b=Ts(f),N={lane:b,action:_,hasEagerState:!1,eagerState:null,next:null};if(ng(f))Id(d,N);else{Wu(f,d,N);var D=f.alternate;if(f.lanes===0&&(D===null||D.lanes===0)&&(D=d.lastRenderedReducer,D!==null))try{var Y=d.lastRenderedState,he=D(Y,_);if(N.hasEagerState=!0,N.eagerState=he,ri(he,Y))return}catch{}finally{}_=gn(),f=Yr(f,b,_),f!==null&&ju(f,d,b)}}function ng(f){var d=f.alternate;return f===Kn||d!==null&&d===Kn}function Id(f,d){Os=Pf=!0;var _=f.pending;_===null?d.next=d:(d.next=_.next,_.next=d),f.pending=d}function Wu(f,d,_){lr!==null&&(f.mode&1)!==0&&(Zt&2)===0?(f=d.interleaved,f===null?(_.next=_,Yi===null?Yi=[d]:Yi.push(d)):(_.next=f.next,f.next=_),d.interleaved=_):(f=d.pending,f===null?_.next=_:(_.next=f.next,f.next=_),d.pending=_)}function ju(f,d,_){if((_&4194240)!==0){var b=d.lanes;b&=f.pendingLanes,_|=b,d.lanes=_,ks(f,_)}}var Ll={readContext:gi,useCallback:Cr,useContext:Cr,useEffect:Cr,useImperativeHandle:Cr,useInsertionEffect:Cr,useLayoutEffect:Cr,useMemo:Cr,useReducer:Cr,useRef:Cr,useState:Cr,useDebugValue:Cr,useDeferredValue:Cr,useTransition:Cr,useMutableSource:Cr,useSyncExternalStore:Cr,useId:Cr,unstable_isNewReconciler:!1},Pd={readContext:gi,useCallback:function(f,d){return xs().memoizedState=[f,d===void 0?null:d],f},useContext:gi,useEffect:Of,useImperativeHandle:function(f,d,_){return _=_!=null?_.concat([f]):null,$a(4194308,4,Gu.bind(null,d,f),_)},useLayoutEffect:function(f,d){return $a(4194308,4,f,d)},useInsertionEffect:function(f,d){return $a(4,2,f,d)},useMemo:function(f,d){var _=xs();return d=d===void 0?null:d,f=f(),_.memoizedState=[f,d],f},useReducer:function(f,d,_){var b=xs();return d=_!==void 0?_(d):d,b.memoizedState=b.baseState=d,f={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:f,lastRenderedState:d},b.queue=f,f=f.dispatch=tg.bind(null,Kn,f),[b.memoizedState,f]},useRef:function(f){var d=xs();return f={current:f},d.memoizedState=f},useState:Hu,useDebugValue:Uf,useDeferredValue:function(f){var d=Hu(f),_=d[0],b=d[1];return Of(function(){var N=Di.transition;Di.transition={};try{b(f)}finally{Di.transition=N}},[f]),_},useTransition:function(){var f=Hu(!1),d=f[0];return f=Bf.bind(null,f[1]),xs().memoizedState=f,[d,f]},useMutableSource:function(){},useSyncExternalStore:function(f,d,_){var b=Kn,N=xs();if(Wn){if(_===void 0)throw Error(a(407));_=_()}else{if(_=d(),lr===null)throw Error(a(349));(bo&30)!==0||Cd(b,d,_)}N.memoizedState=_;var D={value:_,getSnapshot:d};return N.queue=D,Of(ra.bind(null,b,D,f),[f]),b.flags|=2048,$u(9,Rd.bind(null,b,D,_,d),void 0,null),_},useId:function(){var f=xs(),d=lr.identifierPrefix;if(Wn){var _=ta,b=ea;_=(b&~(1<<32-pi(b)-1)).toString(32)+_,d=":"+d+"R"+_,_=To++,0<_&&(d+="H"+_.toString(32)),d+=":"}else _=zu++,d=":"+d+"r"+_.toString(32)+":";return f.memoizedState=d},unstable_isNewReconciler:!1},Ld={readContext:gi,useCallback:zf,useContext:gi,useEffect:Rl,useImperativeHandle:Il,useInsertionEffect:Ln,useLayoutEffect:Ff,useMemo:Pl,useReducer:Bu,useRef:eg,useState:function(){return Bu(Fs)},useDebugValue:Uf,useDeferredValue:function(f){var d=Bu(Fs),_=d[0],b=d[1];return Rl(function(){var N=Di.transition;Di.transition={};try{b(f)}finally{Di.transition=N}},[f]),_},useTransition:function(){var f=Bu(Fs)[0],d=Ss().memoizedState;return[f,d]},useMutableSource:Ad,useSyncExternalStore:Nd,useId:Mo,unstable_isNewReconciler:!1},kd={readContext:gi,useCallback:zf,useContext:gi,useEffect:Rl,useImperativeHandle:Il,useInsertionEffect:Ln,useLayoutEffect:Ff,useMemo:Pl,useReducer:Vu,useRef:eg,useState:function(){return Vu(Fs)},useDebugValue:Uf,useDeferredValue:function(f){var d=Vu(Fs),_=d[0],b=d[1];return Rl(function(){var N=Di.transition;Di.transition={};try{b(f)}finally{Di.transition=N}},[f]),_},useTransition:function(){var f=Vu(Fs)[0],d=Ss().memoizedState;return[f,d]},useMutableSource:Ad,useSyncExternalStore:Nd,useId:Mo,unstable_isNewReconciler:!1};function Dd(f,d){try{var _="",b=d;do _+=yd(b),b=b.return;while(b);var N=_}catch(D){N=`
Error generating stack: `+D.message+`
`+D.stack}return{value:f,source:d,stack:N}}function Vf(f,d){try{console.error(d.value)}catch(_){setTimeout(function(){throw _})}}var yv=typeof WeakMap=="function"?WeakMap:Map;function rg(f,d,_){_=Qs(-1,_),_.tag=3,_.payload={element:null};var b=d.value;return _.callback=function(){zl||(zl=!0,Un=b),Vf(f,d)},_}function Hf(f,d,_){_=Qs(-1,_),_.tag=3;var b=f.type.getDerivedStateFromError;if(typeof b=="function"){var N=d.value;_.payload=function(){return b(N)},_.callback=function(){Vf(f,d)}}var D=f.stateNode;return D!==null&&typeof D.componentDidCatch=="function"&&(_.callback=function(){Vf(f,d),typeof b!="function"&&(bs===null?bs=new Set([this]):bs.add(this));var Y=d.stack;this.componentDidCatch(d.value,{componentStack:Y!==null?Y:""})}),_}function ia(f,d,_){var b=f.pingCache;if(b===null){b=f.pingCache=new yv;var N=new Set;b.set(d,N)}else N=b.get(d),N===void 0&&(N=new Set,b.set(d,N));N.has(_)||(N.add(_),f=Qd.bind(null,f,d,_),d.then(f,f))}function Od(f){do{var d;if((d=f.tag===13)&&(d=f.memoizedState,d=d!==null?d.dehydrated!==null:!0),d)return f;f=f.return}while(f!==null);return null}function Ao(f,d,_,b,N){return(f.mode&1)===0?(f===d?f.flags|=65536:(f.flags|=128,_.flags|=131072,_.flags&=-52805,_.tag===1&&(_.alternate===null?_.tag=17:(d=Qs(-1,1),d.tag=2,Ua(_,d))),_.lanes|=1),f):(f.flags|=65536,f.lanes=N,f)}function vr(f){f.flags|=4}function kl(f,d){if(f!==null&&f.child===d.child)return!0;if((d.flags&16)!==0)return!1;for(f=d.child;f!==null;){if((f.flags&12854)!==0||(f.subtreeFlags&12854)!==0)return!1;f=f.sibling}return!0}var Oi,No,$f,Gf;if(vt)Oi=function(f,d){for(var _=d.child;_!==null;){if(_.tag===5||_.tag===6)q(f,_.stateNode);else if(_.tag!==4&&_.child!==null){_.child.return=_,_=_.child;continue}if(_===d)break;for(;_.sibling===null;){if(_.return===null||_.return===d)return;_=_.return}_.sibling.return=_.return,_=_.sibling}},No=function(){},$f=function(f,d,_,b,N){if(f=f.memoizedProps,f!==b){var D=d.stateNode,Y=_s(yi.current);_=Ce(D,_,f,b,N,Y),(d.updateQueue=_)&&vr(d)}},Gf=function(f,d,_,b){_!==b&&vr(d)};else if(se){Oi=function(f,d,_,b){for(var N=d.child;N!==null;){if(N.tag===5){var D=N.stateNode;_&&b&&(D=yn(D,N.type,N.memoizedProps,N)),q(f,D)}else if(N.tag===6)D=N.stateNode,_&&b&&(D=Zn(D,N.memoizedProps,N)),q(f,D);else if(N.tag!==4){if(N.tag===22&&N.memoizedState!==null)D=N.child,D!==null&&(D.return=N),Oi(f,N,!0,!0);else if(N.child!==null){N.child.return=N,N=N.child;continue}}if(N===d)break;for(;N.sibling===null;){if(N.return===null||N.return===d)return;N=N.return}N.sibling.return=N.return,N=N.sibling}};var Ga=function(f,d,_,b){for(var N=d.child;N!==null;){if(N.tag===5){var D=N.stateNode;_&&b&&(D=yn(D,N.type,N.memoizedProps,N)),$e(f,D)}else if(N.tag===6)D=N.stateNode,_&&b&&(D=Zn(D,N.memoizedProps,N)),$e(f,D);else if(N.tag!==4){if(N.tag===22&&N.memoizedState!==null)D=N.child,D!==null&&(D.return=N),Ga(f,N,!0,!0);else if(N.child!==null){N.child.return=N,N=N.child;continue}}if(N===d)break;for(;N.sibling===null;){if(N.return===null||N.return===d)return;N=N.return}N.sibling.return=N.return,N=N.sibling}};No=function(f,d){var _=d.stateNode;if(!kl(f,d)){f=_.containerInfo;var b=Re(f);Ga(b,d,!1,!1),_.pendingChildren=b,vr(d),Et(f,b)}},$f=function(f,d,_,b,N){var D=f.stateNode,Y=f.memoizedProps;if((f=kl(f,d))&&Y===b)d.stateNode=D;else{var he=d.stateNode,Ae=_s(yi.current),Ye=null;Y!==b&&(Ye=Ce(he,_,Y,b,N,Ae)),f&&Ye===null?d.stateNode=D:(D=Ze(D,Ye,_,Y,b,d,f,he),ve(D,_,b,N,Ae)&&vr(d),d.stateNode=D,f?vr(d):Oi(D,d,!1,!1))}},Gf=function(f,d,_,b){_!==b?(f=_s(wo.current),_=_s(yi.current),d.stateNode=We(b,f,_,d),vr(d)):d.stateNode=f.stateNode}}else No=function(){},$f=function(){},Gf=function(){};function sa(f,d){if(!Wn)switch(f.tailMode){case"hidden":d=f.tail;for(var _=null;d!==null;)d.alternate!==null&&(_=d),d=d.sibling;_===null?f.tail=null:_.sibling=null;break;case"collapsed":_=f.tail;for(var b=null;_!==null;)_.alternate!==null&&(b=_),_=_.sibling;b===null?d||f.tail===null?f.tail=null:f.tail.sibling=null:b.sibling=null}}function or(f){var d=f.alternate!==null&&f.alternate.child===f.child,_=0,b=0;if(d)for(var N=f.child;N!==null;)_|=N.lanes|N.childLanes,b|=N.subtreeFlags&14680064,b|=N.flags&14680064,N.return=f,N=N.sibling;else for(N=f.child;N!==null;)_|=N.lanes|N.childLanes,b|=N.subtreeFlags,b|=N.flags,N.return=f,N=N.sibling;return f.subtreeFlags|=b,f.childLanes=_,d}function Wf(f,d,_){var b=d.pendingProps;switch(Ed(d),d.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return or(d),null;case 1:return ar(d.type)&&Gn(),or(d),null;case 3:return b=d.stateNode,Nl(),It(Qn),It(on),Eo(),b.pendingContext&&(b.context=b.pendingContext,b.pendingContext=null),(f===null||f.child===null)&&(Fu(d)?vr(d):f===null||f.memoizedState.isDehydrated&&(d.flags&256)===0||(d.flags|=1024,Qi!==null&&(sc(Qi),Qi=null))),No(f,d),or(d),null;case 5:Md(d),_=_s(wo.current);var N=d.type;if(f!==null&&d.stateNode!=null)$f(f,d,N,b,_),f.ref!==d.ref&&(d.flags|=512,d.flags|=2097152);else{if(!b){if(d.stateNode===null)throw Error(a(166));return or(d),null}if(f=_s(yi.current),Fu(d)){if(!Ve)throw Error(a(175));f=pd(d.stateNode,d.type,d.memoizedProps,_,f,d,!El),d.updateQueue=f,f!==null&&vr(d)}else{var D=z(N,b,_,f,d);Oi(D,d,!1,!1),d.stateNode=D,ve(D,N,b,_,f)&&vr(d)}d.ref!==null&&(d.flags|=512,d.flags|=2097152)}return or(d),null;case 6:if(f&&d.stateNode!=null)Gf(f,d,f.memoizedProps,b);else{if(typeof b!="string"&&d.stateNode===null)throw Error(a(166));if(f=_s(wo.current),_=_s(yi.current),Fu(d)){if(!Ve)throw Error(a(176));if(f=d.stateNode,b=d.memoizedProps,(_=Ys(f,b,d,!El))&&(N=si,N!==null))switch(D=(N.mode&1)!==0,N.tag){case 3:Rt(N.stateNode.containerInfo,f,b,D);break;case 5:Dt(N.type,N.memoizedProps,N.stateNode,f,b,D)}_&&vr(d)}else d.stateNode=We(b,f,_,d)}return or(d),null;case 13:if(It(Xn),b=d.memoizedState,Wn&&Dr!==null&&(d.mode&1)!==0&&(d.flags&128)===0){for(f=Dr;f;)f=ys(f);return bl(),d.flags|=98560,d}if(b!==null&&b.dehydrated!==null){if(b=Fu(d),f===null){if(!b)throw Error(a(318));if(!Ve)throw Error(a(344));if(f=d.memoizedState,f=f!==null?f.dehydrated:null,!f)throw Error(a(317));hf(f,d)}else bl(),(d.flags&128)===0&&(d.memoizedState=null),d.flags|=4;return or(d),null}return Qi!==null&&(sc(Qi),Qi=null),(d.flags&128)!==0?(d.lanes=_,d):(b=b!==null,_=!1,f===null?Fu(d):_=f.memoizedState!==null,b&&!_&&(d.child.flags|=8192,(d.mode&1)!==0&&(f===null||(Xn.current&1)!==0?tr===0&&(tr=3):Jf())),d.updateQueue!==null&&(d.flags|=4),or(d),null);case 4:return Nl(),No(f,d),f===null&&je(d.stateNode.containerInfo),or(d),null;case 10:return Ou(d.type._context),or(d),null;case 17:return ar(d.type)&&Gn(),or(d),null;case 19:if(It(Xn),N=d.memoizedState,N===null)return or(d),null;if(b=(d.flags&128)!==0,D=N.rendering,D===null)if(b)sa(N,!1);else{if(tr!==0||f!==null&&(f.flags&128)!==0)for(f=d.child;f!==null;){if(D=If(f),D!==null){for(d.flags|=128,sa(N,!1),f=D.updateQueue,f!==null&&(d.updateQueue=f,d.flags|=4),d.subtreeFlags=0,f=_,b=d.child;b!==null;)_=b,N=f,_.flags&=14680066,D=_.alternate,D===null?(_.childLanes=0,_.lanes=N,_.child=null,_.subtreeFlags=0,_.memoizedProps=null,_.memoizedState=null,_.updateQueue=null,_.dependencies=null,_.stateNode=null):(_.childLanes=D.childLanes,_.lanes=D.lanes,_.child=D.child,_.subtreeFlags=0,_.deletions=null,_.memoizedProps=D.memoizedProps,_.memoizedState=D.memoizedState,_.updateQueue=D.updateQueue,_.type=D.type,N=D.dependencies,_.dependencies=N===null?null:{lanes:N.lanes,firstContext:N.firstContext}),b=b.sibling;return xt(Xn,Xn.current&1|2),d.child}f=f.sibling}N.tail!==null&&yr()>qa&&(d.flags|=128,b=!0,sa(N,!1),d.lanes=4194304)}else{if(!b)if(f=If(D),f!==null){if(d.flags|=128,b=!0,f=f.updateQueue,f!==null&&(d.updateQueue=f,d.flags|=4),sa(N,!0),N.tail===null&&N.tailMode==="hidden"&&!D.alternate&&!Wn)return or(d),null}else 2*yr()-N.renderingStartTime>qa&&_!==1073741824&&(d.flags|=128,b=!0,sa(N,!1),d.lanes=4194304);N.isBackwards?(D.sibling=d.child,d.child=D):(f=N.last,f!==null?f.sibling=D:d.child=D,N.last=D)}return N.tail!==null?(d=N.tail,N.rendering=d,N.tail=d.sibling,N.renderingStartTime=yr(),d.sibling=null,f=Xn.current,xt(Xn,b?f&1|2:f&1),d):(or(d),null);case 22:case 23:return ac(),b=d.memoizedState!==null,f!==null&&f.memoizedState!==null!==b&&(d.flags|=8192),b&&(d.mode&1)!==0?(Kr&1073741824)!==0&&(or(d),vt&&d.subtreeFlags&6&&(d.flags|=8192)):or(d),null;case 24:return null;case 25:return null}throw Error(a(156,d.tag))}var Fd=o.ReactCurrentOwner,Rr=!1;function er(f,d,_,b){d.child=f===null?Jm(d,null,_,b):na(d,f.child,_,b)}function kn(f,d,_,b,N){_=_.render;var D=d.ref;return xl(d,N),b=Cl(f,d,_,b,D,N),_=Ha(),f!==null&&!Rr?(d.updateQueue=f.updateQueue,d.flags&=-2053,f.lanes&=~N,vi(f,d,N)):(Wn&&_&&wd(d),d.flags|=1,er(f,d,b,N),d.child)}function An(f,d,_,b,N){if(f===null){var D=_.type;return typeof D=="function"&&!eh(D)&&D.defaultProps===void 0&&_.compare===null&&_.defaultProps===void 0?(d.tag=15,d.type=D,aa(f,d,D,b,N)):(f=th(_.type,null,b,d,d.mode,N),f.ref=d.ref,f.return=d,d.child=f)}if(D=f.child,(f.lanes&N)===0){var Y=D.memoizedProps;if(_=_.compare,_=_!==null?_:vs,_(Y,b)&&f.ref===d.ref)return vi(f,d,N)}return d.flags|=1,f=ma(D,b),f.ref=d.ref,f.return=d,d.child=f}function aa(f,d,_,b,N){if(f!==null&&vs(f.memoizedProps,b)&&f.ref===d.ref)if(Rr=!1,(f.lanes&N)!==0)(f.flags&131072)!==0&&(Rr=!0);else return d.lanes=f.lanes,vi(f,d,N);return oa(f,d,_,b,N)}function Or(f,d,_){var b=d.pendingProps,N=b.children,D=f!==null?f.memoizedState:null;if(b.mode==="hidden")if((d.mode&1)===0)d.memoizedState={baseLanes:0,cachePool:null},xt(Fo,Kr),Kr|=_;else if((_&1073741824)!==0)d.memoizedState={baseLanes:0,cachePool:null},b=D!==null?D.baseLanes:_,xt(Fo,Kr),Kr|=b;else return f=D!==null?D.baseLanes|_:_,d.lanes=d.childLanes=1073741824,d.memoizedState={baseLanes:f,cachePool:null},d.updateQueue=null,xt(Fo,Kr),Kr|=f,null;else D!==null?(b=D.baseLanes|_,d.memoizedState=null):b=_,xt(Fo,Kr),Kr|=b;return er(f,d,N,_),d.child}function ai(f,d){var _=d.ref;(f===null&&_!==null||f!==null&&f.ref!==_)&&(d.flags|=512,d.flags|=2097152)}function oa(f,d,_,b,N){var D=ar(_)?Ls:on.current;return D=ni(d,D),xl(d,N),_=Cl(f,d,_,b,D,N),b=Ha(),f!==null&&!Rr?(d.updateQueue=f.updateQueue,d.flags&=-2053,f.lanes&=~N,vi(f,d,N)):(Wn&&b&&wd(d),d.flags|=1,er(f,d,_,N),d.child)}function Co(f,d,_,b,N){if(ar(_)){var D=!0;Mr(d)}else D=!1;if(xl(d,N),d.stateNode===null)f!==null&&(f.alternate=null,d.alternate=null,d.flags|=2),qm(d,_,b),Sd(d,_,b,N),b=!0;else if(f===null){var Y=d.stateNode,he=d.memoizedProps;Y.props=he;var Ae=Y.context,Ye=_.contextType;typeof Ye=="object"&&Ye!==null?Ye=gi(Ye):(Ye=ar(_)?Ls:on.current,Ye=ni(d,Ye));var mt=_.getDerivedStateFromProps,qt=typeof mt=="function"||typeof Y.getSnapshotBeforeUpdate=="function";qt||typeof Y.UNSAFE_componentWillReceiveProps!="function"&&typeof Y.componentWillReceiveProps!="function"||(he!==b||Ae!==Ye)&&Xm(d,Y,b,Ye),Zi=!1;var Lt=d.memoizedState;Y.state=Lt,bf(d,b,Y,N),Ae=d.memoizedState,he!==b||Lt!==Ae||Qn.current||Zi?(typeof mt=="function"&&(_d(d,_,mt,b),Ae=d.memoizedState),(he=Zi||xd(d,_,he,b,Lt,Ae,Ye))?(qt||typeof Y.UNSAFE_componentWillMount!="function"&&typeof Y.componentWillMount!="function"||(typeof Y.componentWillMount=="function"&&Y.componentWillMount(),typeof Y.UNSAFE_componentWillMount=="function"&&Y.UNSAFE_componentWillMount()),typeof Y.componentDidMount=="function"&&(d.flags|=4194308)):(typeof Y.componentDidMount=="function"&&(d.flags|=4194308),d.memoizedProps=b,d.memoizedState=Ae),Y.props=b,Y.state=Ae,Y.context=Ye,b=he):(typeof Y.componentDidMount=="function"&&(d.flags|=4194308),b=!1)}else{Y=d.stateNode,vd(f,d),he=d.memoizedProps,Ye=d.type===d.elementType?he:mi(d.type,he),Y.props=Ye,qt=d.pendingProps,Lt=Y.context,Ae=_.contextType,typeof Ae=="object"&&Ae!==null?Ae=gi(Ae):(Ae=ar(_)?Ls:on.current,Ae=ni(d,Ae));var Qt=_.getDerivedStateFromProps;(mt=typeof Qt=="function"||typeof Y.getSnapshotBeforeUpdate=="function")||typeof Y.UNSAFE_componentWillReceiveProps!="function"&&typeof Y.componentWillReceiveProps!="function"||(he!==qt||Lt!==Ae)&&Xm(d,Y,b,Ae),Zi=!1,Lt=d.memoizedState,Y.state=Lt,bf(d,b,Y,N);var ct=d.memoizedState;he!==qt||Lt!==ct||Qn.current||Zi?(typeof Qt=="function"&&(_d(d,_,Qt,b),ct=d.memoizedState),(Ye=Zi||xd(d,_,Ye,b,Lt,ct,Ae)||!1)?(mt||typeof Y.UNSAFE_componentWillUpdate!="function"&&typeof Y.componentWillUpdate!="function"||(typeof Y.componentWillUpdate=="function"&&Y.componentWillUpdate(b,ct,Ae),typeof Y.UNSAFE_componentWillUpdate=="function"&&Y.UNSAFE_componentWillUpdate(b,ct,Ae)),typeof Y.componentDidUpdate=="function"&&(d.flags|=4),typeof Y.getSnapshotBeforeUpdate=="function"&&(d.flags|=1024)):(typeof Y.componentDidUpdate!="function"||he===f.memoizedProps&&Lt===f.memoizedState||(d.flags|=4),typeof Y.getSnapshotBeforeUpdate!="function"||he===f.memoizedProps&&Lt===f.memoizedState||(d.flags|=1024),d.memoizedProps=b,d.memoizedState=ct),Y.props=b,Y.state=ct,Y.context=Ae,b=Ye):(typeof Y.componentDidUpdate!="function"||he===f.memoizedProps&&Lt===f.memoizedState||(d.flags|=4),typeof Y.getSnapshotBeforeUpdate!="function"||he===f.memoizedProps&&Lt===f.memoizedState||(d.flags|=1024),b=!1)}return Xr(f,d,_,b,D,N)}function Xr(f,d,_,b,N,D){ai(f,d);var Y=(d.flags&128)!==0;if(!b&&!Y)return N&&Oa(d,_,!1),vi(f,d,D);b=d.stateNode,Fd.current=d;var he=Y&&typeof _.getDerivedStateFromError!="function"?null:b.render();return d.flags|=1,f!==null&&Y?(d.child=na(d,f.child,null,D),d.child=na(d,null,he,D)):er(f,d,he,D),d.memoizedState=b.state,N&&Oa(d,_,!0),d.child}function qu(f){var d=f.stateNode;d.pendingContext?Pi(f,d.pendingContext,d.pendingContext!==d.context):d.context&&Pi(f,d.context,!1),Rf(f,d.containerInfo)}function Ud(f,d,_,b,N){return bl(),Cf(N),d.flags|=256,er(f,d,_,b),d.child}var Xu={dehydrated:null,treeContext:null,retryLane:0};function Ro(f){return{baseLanes:f,cachePool:null}}function zd(f,d,_){var b=d.pendingProps,N=Xn.current,D=!1,Y=(d.flags&128)!==0,he;if((he=Y)||(he=f!==null&&f.memoizedState===null?!1:(N&2)!==0),he?(D=!0,d.flags&=-129):(f===null||f.memoizedState!==null)&&(N|=1),xt(Xn,N&1),f===null)return Ba(d),f=d.memoizedState,f!==null&&(f=f.dehydrated,f!==null)?((d.mode&1)===0?d.lanes=1:Xs(f)?d.lanes=8:d.lanes=1073741824,null):(N=b.children,f=b.fallback,D?(b=d.mode,D=d.child,N={mode:"hidden",children:N},(b&1)===0&&D!==null?(D.childLanes=0,D.pendingProps=N):D=uc(N,b,0,null),f=Ho(f,b,_,null),D.return=d,f.return=d,D.sibling=f,d.child=D,d.child.memoizedState=Ro(_),d.memoizedState=Xu,f):ws(d,N));if(N=f.memoizedState,N!==null){if(he=N.dehydrated,he!==null){if(Y)return d.flags&256?(d.flags&=-257,Yu(f,d,_,Error(a(422)))):d.memoizedState!==null?(d.child=f.child,d.flags|=128,null):(D=b.fallback,N=d.mode,b=uc({mode:"visible",children:b.children},N,0,null),D=Ho(D,N,_,null),D.flags|=2,b.return=d,D.return=d,b.sibling=D,d.child=b,(d.mode&1)!==0&&na(d,f.child,null,_),d.child.memoizedState=Ro(_),d.memoizedState=Xu,D);if((d.mode&1)===0)d=Yu(f,d,_,null);else if(Xs(he))d=Yu(f,d,_,Error(a(419)));else if(b=(_&f.childLanes)!==0,Rr||b){if(b=lr,b!==null){switch(_&-_){case 4:D=2;break;case 16:D=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:D=32;break;case 536870912:D=268435456;break;default:D=0}b=(D&(b.suspendedLanes|_))!==0?0:D,b!==0&&b!==N.retryLane&&(N.retryLane=b,Yr(f,b,-1))}Jf(),d=Yu(f,d,_,Error(a(421)))}else Cu(he)?(d.flags|=128,d.child=f.child,d=lg.bind(null,f),Ks(he,d),d=null):(_=N.treeContext,Ve&&(Dr=ff(he),si=d,Wn=!0,Qi=null,El=!1,_!==null&&(Ji[Li++]=ea,Ji[Li++]=ta,Ji[Li++]=_o,ea=_.id,ta=_.overflow,_o=d)),d=ws(d,d.pendingProps.children),d.flags|=4096);return d}return D?(b=jf(f,d,b.children,b.fallback,_),D=d.child,N=f.child.memoizedState,D.memoizedState=N===null?Ro(_):{baseLanes:N.baseLanes|_,cachePool:null},D.childLanes=f.childLanes&~_,d.memoizedState=Xu,b):(_=Ku(f,d,b.children,_),d.memoizedState=null,_)}return D?(b=jf(f,d,b.children,b.fallback,_),D=d.child,N=f.child.memoizedState,D.memoizedState=N===null?Ro(_):{baseLanes:N.baseLanes|_,cachePool:null},D.childLanes=f.childLanes&~_,d.memoizedState=Xu,b):(_=Ku(f,d,b.children,_),d.memoizedState=null,_)}function ws(f,d){return d=uc({mode:"visible",children:d},f.mode,0,null),d.return=f,f.child=d}function Ku(f,d,_,b){var N=f.child;return f=N.sibling,_=ma(N,{mode:"visible",children:_}),(d.mode&1)===0&&(_.lanes=b),_.return=d,_.sibling=null,f!==null&&(b=d.deletions,b===null?(d.deletions=[f],d.flags|=16):b.push(f)),d.child=_}function jf(f,d,_,b,N){var D=d.mode;f=f.child;var Y=f.sibling,he={mode:"hidden",children:_};return(D&1)===0&&d.child!==f?(_=d.child,_.childLanes=0,_.pendingProps=he,d.deletions=null):(_=ma(f,he),_.subtreeFlags=f.subtreeFlags&14680064),Y!==null?b=ma(Y,b):(b=Ho(b,D,N,null),b.flags|=2),b.return=d,_.return=d,_.sibling=b,d.child=_,b}function Yu(f,d,_,b){return b!==null&&Cf(b),na(d,f.child,null,_),f=ws(d,d.pendingProps.children),f.flags|=2,d.memoizedState=null,f}function ig(f,d,_){f.lanes|=d;var b=f.alternate;b!==null&&(b.lanes|=d),vo(f.return,d,_)}function Us(f,d,_,b,N){var D=f.memoizedState;D===null?f.memoizedState={isBackwards:d,rendering:null,renderingStartTime:0,last:b,tail:_,tailMode:N}:(D.isBackwards=d,D.rendering=null,D.renderingStartTime=0,D.last=b,D.tail=_,D.tailMode=N)}function Io(f,d,_){var b=d.pendingProps,N=b.revealOrder,D=b.tail;if(er(f,d,b.children,_),b=Xn.current,(b&2)!==0)b=b&1|2,d.flags|=128;else{if(f!==null&&(f.flags&128)!==0)e:for(f=d.child;f!==null;){if(f.tag===13)f.memoizedState!==null&&ig(f,_,d);else if(f.tag===19)ig(f,_,d);else if(f.child!==null){f.child.return=f,f=f.child;continue}if(f===d)break e;for(;f.sibling===null;){if(f.return===null||f.return===d)break e;f=f.return}f.sibling.return=f.return,f=f.sibling}b&=1}if(xt(Xn,b),(d.mode&1)===0)d.memoizedState=null;else switch(N){case"forwards":for(_=d.child,N=null;_!==null;)f=_.alternate,f!==null&&If(f)===null&&(N=_),_=_.sibling;_=N,_===null?(N=d.child,d.child=null):(N=_.sibling,_.sibling=null),Us(d,!1,N,_,D);break;case"backwards":for(_=null,N=d.child,d.child=null;N!==null;){if(f=N.alternate,f!==null&&If(f)===null){d.child=N;break}f=N.sibling,N.sibling=_,_=N,N=f}Us(d,!0,_,null,D);break;case"together":Us(d,!1,null,null,void 0);break;default:d.memoizedState=null}return d.child}function vi(f,d,_){if(f!==null&&(d.dependencies=f.dependencies),zs|=d.lanes,(_&d.childLanes)===0)return null;if(f!==null&&d.child!==f.child)throw Error(a(153));if(d.child!==null){for(f=d.child,_=ma(f,f.pendingProps),d.child=_,_.return=d;f.sibling!==null;)f=f.sibling,_=_.sibling=ma(f,f.pendingProps),_.return=d;_.sibling=null}return d.child}function qf(f,d,_){switch(d.tag){case 3:qu(d),bl();break;case 5:Qm(d);break;case 1:ar(d.type)&&Mr(d);break;case 4:Rf(d,d.stateNode.containerInfo);break;case 10:yo(d,d.type._context,d.memoizedProps.value);break;case 13:var b=d.memoizedState;if(b!==null)return b.dehydrated!==null?(xt(Xn,Xn.current&1),d.flags|=128,null):(_&d.child.childLanes)!==0?zd(f,d,_):(xt(Xn,Xn.current&1),f=vi(f,d,_),f!==null?f.sibling:null);xt(Xn,Xn.current&1);break;case 19:if(b=(_&d.childLanes)!==0,(f.flags&128)!==0){if(b)return Io(f,d,_);d.flags|=128}var N=d.memoizedState;if(N!==null&&(N.rendering=null,N.tail=null,N.lastEffect=null),xt(Xn,Xn.current),b)break;return null;case 22:case 23:return d.lanes=0,Or(f,d,_)}return vi(f,d,_)}function Xf(f,d){switch(Ed(d),d.tag){case 1:return ar(d.type)&&Gn(),f=d.flags,f&65536?(d.flags=f&-65537|128,d):null;case 3:return Nl(),It(Qn),It(on),Eo(),f=d.flags,(f&65536)!==0&&(f&128)===0?(d.flags=f&-65537|128,d):null;case 5:return Md(d),null;case 13:if(It(Xn),f=d.memoizedState,f!==null&&f.dehydrated!==null){if(d.alternate===null)throw Error(a(340));bl()}return f=d.flags,f&65536?(d.flags=f&-65537|128,d):null;case 19:return It(Xn),null;case 4:return Nl(),null;case 10:return Ou(d.type._context),null;case 22:case 23:return ac(),null;case 24:return null;default:return null}}var oi=!1,Ir=!1,Po=typeof WeakSet=="function"?WeakSet:Set,et=null;function es(f,d){var _=f.ref;if(_!==null)if(typeof _=="function")try{_(null)}catch(b){ui(f,d,b)}else _.current=null}function la(f,d,_){try{_()}catch(b){ui(f,d,b)}}var Bd=!1;function Vd(f,d){for(re(f.containerInfo),et=d;et!==null;)if(f=et,d=f.child,(f.subtreeFlags&1028)!==0&&d!==null)d.return=f,et=d;else for(;et!==null;){f=et;try{var _=f.alternate;if((f.flags&1024)!==0)switch(f.tag){case 0:case 11:case 15:break;case 1:if(_!==null){var b=_.memoizedProps,N=_.memoizedState,D=f.stateNode,Y=D.getSnapshotBeforeUpdate(f.elementType===f.type?b:mi(f.type,b),N);D.__reactInternalSnapshotBeforeUpdate=Y}break;case 3:vt&&Qe(f.stateNode.containerInfo);break;case 5:case 6:case 4:case 17:break;default:throw Error(a(163))}}catch(he){ui(f,f.return,he)}if(d=f.sibling,d!==null){d.return=f.return,et=d;break}et=f.return}return _=Bd,Bd=!1,_}function ua(f,d,_){var b=d.updateQueue;if(b=b!==null?b.lastEffect:null,b!==null){var N=b=b.next;do{if((N.tag&f)===f){var D=N.destroy;N.destroy=void 0,D!==void 0&&la(d,_,D)}N=N.next}while(N!==b)}}function Fr(f,d){if(d=d.updateQueue,d=d!==null?d.lastEffect:null,d!==null){var _=d=d.next;do{if((_.tag&f)===f){var b=_.create;_.destroy=b()}_=_.next}while(_!==d)}}function li(f){var d=f.ref;if(d!==null){var _=f.stateNode;switch(f.tag){case 5:f=de(_);break;default:f=_}typeof d=="function"?d(f):d.current=f}}function Fn(f,d,_){if(Ds&&typeof Ds.onCommitFiberUnmount=="function")try{Ds.onCommitFiberUnmount(Pu,d)}catch{}switch(d.tag){case 0:case 11:case 14:case 15:if(f=d.updateQueue,f!==null&&(f=f.lastEffect,f!==null)){var b=f=f.next;do{var N=b,D=N.destroy;N=N.tag,D!==void 0&&((N&2)!==0||(N&4)!==0)&&la(d,_,D),b=b.next}while(b!==f)}break;case 1:if(es(d,_),f=d.stateNode,typeof f.componentWillUnmount=="function")try{f.props=d.memoizedProps,f.state=d.memoizedState,f.componentWillUnmount()}catch(Y){ui(d,_,Y)}break;case 5:es(d,_);break;case 4:vt?Gd(f,d,_):se&&se&&(d=d.stateNode.containerInfo,_=Re(d),Yt(d,_))}}function ts(f,d,_){for(var b=d;;)if(Fn(f,b,_),b.child===null||vt&&b.tag===4){if(b===d)break;for(;b.sibling===null;){if(b.return===null||b.return===d)return;b=b.return}b.sibling.return=b.return,b=b.sibling}else b.child.return=b,b=b.child}function Hd(f){var d=f.alternate;d!==null&&(f.alternate=null,Hd(d)),f.child=null,f.deletions=null,f.sibling=null,f.tag===5&&(d=f.stateNode,d!==null&&bt(d)),f.stateNode=null,f.return=null,f.dependencies=null,f.memoizedProps=null,f.memoizedState=null,f.pendingProps=null,f.stateNode=null,f.updateQueue=null}function $d(f){return f.tag===5||f.tag===3||f.tag===4}function Kf(f){e:for(;;){for(;f.sibling===null;){if(f.return===null||$d(f.return))return null;f=f.return}for(f.sibling.return=f.return,f=f.sibling;f.tag!==5&&f.tag!==6&&f.tag!==18;){if(f.flags&2||f.child===null||f.tag===4)continue e;f.child.return=f,f=f.child}if(!(f.flags&2))return f.stateNode}}function Yf(f){if(vt){e:{for(var d=f.return;d!==null;){if($d(d))break e;d=d.return}throw Error(a(160))}var _=d;switch(_.tag){case 5:d=_.stateNode,_.flags&32&&(Ne(d),_.flags&=-33),_=Kf(f),Dl(f,_,d);break;case 3:case 4:d=_.stateNode.containerInfo,_=Kf(f),Zf(f,_,d);break;default:throw Error(a(161))}}}function Zf(f,d,_){var b=f.tag;if(b===5||b===6)f=f.stateNode,d?Xe(_,f,d):St(_,f);else if(b!==4&&(f=f.child,f!==null))for(Zf(f,d,_),f=f.sibling;f!==null;)Zf(f,d,_),f=f.sibling}function Dl(f,d,_){var b=f.tag;if(b===5||b===6)f=f.stateNode,d?un(_,f,d):He(_,f);else if(b!==4&&(f=f.child,f!==null))for(Dl(f,d,_),f=f.sibling;f!==null;)Dl(f,d,_),f=f.sibling}function Gd(f,d,_){for(var b=d,N=!1,D,Y;;){if(!N){N=b.return;e:for(;;){if(N===null)throw Error(a(160));switch(D=N.stateNode,N.tag){case 5:Y=!1;break e;case 3:D=D.containerInfo,Y=!0;break e;case 4:D=D.containerInfo,Y=!0;break e}N=N.return}N=!0}if(b.tag===5||b.tag===6)ts(f,b,_),Y?ae(D,b.stateNode):fn(D,b.stateNode);else if(b.tag===18)Y?Me(D,b.stateNode):Te(D,b.stateNode);else if(b.tag===4){if(b.child!==null){D=b.stateNode.containerInfo,Y=!0,b.child.return=b,b=b.child;continue}}else if(Fn(f,b,_),b.child!==null){b.child.return=b,b=b.child;continue}if(b===d)break;for(;b.sibling===null;){if(b.return===null||b.return===d)return;b=b.return,b.tag===4&&(N=!1)}b.sibling.return=b.return,b=b.sibling}}function Wa(f,d){if(vt){switch(d.tag){case 0:case 11:case 14:case 15:ua(3,d,d.return),Fr(3,d),ua(5,d,d.return);return;case 1:return;case 5:var _=d.stateNode;if(_!=null){var b=d.memoizedProps;f=f!==null?f.memoizedProps:b;var N=d.type,D=d.updateQueue;d.updateQueue=null,D!==null&&zt(_,D,N,f,b,d)}return;case 6:if(d.stateNode===null)throw Error(a(162));_=d.memoizedProps,Ke(d.stateNode,f!==null?f.memoizedProps:_,_);return;case 3:Ve&&f!==null&&f.memoizedState.isDehydrated&&ge(d.stateNode.containerInfo);return;case 12:return;case 13:Ol(d);return;case 19:Ol(d);return;case 17:return}throw Error(a(163))}switch(d.tag){case 0:case 11:case 14:case 15:ua(3,d,d.return),Fr(3,d),ua(5,d,d.return);return;case 12:return;case 13:Ol(d);return;case 19:Ol(d);return;case 3:Ve&&f!==null&&f.memoizedState.isDehydrated&&ge(d.stateNode.containerInfo);break;case 22:case 23:return}e:if(se){switch(d.tag){case 1:case 5:case 6:break e;case 3:case 4:d=d.stateNode,Yt(d.containerInfo,d.pendingChildren);break e}throw Error(a(163))}}function Ol(f){var d=f.updateQueue;if(d!==null){f.updateQueue=null;var _=f.stateNode;_===null&&(_=f.stateNode=new Po),d.forEach(function(b){var N=ug.bind(null,f,b);_.has(b)||(_.add(b),b.then(N,N))})}}function vv(f,d){for(et=d;et!==null;){d=et;var _=d.deletions;if(_!==null)for(var b=0;b<_.length;b++){var N=_[b];try{var D=f;vt?Gd(D,N,d):ts(D,N,d);var Y=N.alternate;Y!==null&&(Y.return=null),N.return=null}catch(Mt){ui(N,d,Mt)}}if(_=d.child,(d.subtreeFlags&12854)!==0&&_!==null)_.return=d,et=_;else for(;et!==null;){d=et;try{var he=d.flags;if(he&32&&vt&&Ne(d.stateNode),he&512){var Ae=d.alternate;if(Ae!==null){var Ye=Ae.ref;Ye!==null&&(typeof Ye=="function"?Ye(null):Ye.current=null)}}if(he&8192)switch(d.tag){case 13:if(d.memoizedState!==null){var mt=d.alternate;(mt===null||mt.memoizedState===null)&&(rc=yr())}break;case 22:var qt=d.memoizedState!==null,Lt=d.alternate,Qt=Lt!==null&&Lt.memoizedState!==null;if(_=d,vt){e:if(b=_,N=qt,D=null,vt)for(var ct=b;;){if(ct.tag===5){if(D===null){D=ct;var Br=ct.stateNode;N?ze(Br):Ct(ct.stateNode,ct.memoizedProps)}}else if(ct.tag===6){if(D===null){var Vi=ct.stateNode;N?Fe(Vi):ue(Vi,ct.memoizedProps)}}else if((ct.tag!==22&&ct.tag!==23||ct.memoizedState===null||ct===b)&&ct.child!==null){ct.child.return=ct,ct=ct.child;continue}if(ct===b)break;for(;ct.sibling===null;){if(ct.return===null||ct.return===b)break e;D===ct&&(D=null),ct=ct.return}D===ct&&(D=null),ct.sibling.return=ct.return,ct=ct.sibling}}if(qt&&!Qt&&(_.mode&1)!==0){et=_;for(var xe=_.child;xe!==null;){for(_=et=xe;et!==null;){b=et;var pe=b.child;switch(b.tag){case 0:case 11:case 14:case 15:ua(4,b,b.return);break;case 1:es(b,b.return);var be=b.stateNode;if(typeof be.componentWillUnmount=="function"){var ot=b.return;try{be.props=b.memoizedProps,be.state=b.memoizedState,be.componentWillUnmount()}catch(Mt){ui(b,ot,Mt)}}break;case 5:es(b,b.return);break;case 22:if(b.memoizedState!==null){jd(_);continue}}pe!==null?(pe.return=b,et=pe):jd(_)}xe=xe.sibling}}}switch(he&4102){case 2:Yf(d),d.flags&=-3;break;case 6:Yf(d),d.flags&=-3,Wa(d.alternate,d);break;case 4096:d.flags&=-4097;break;case 4100:d.flags&=-4097,Wa(d.alternate,d);break;case 4:Wa(d.alternate,d)}}catch(Mt){ui(d,d.return,Mt)}if(_=d.sibling,_!==null){_.return=d.return,et=_;break}et=d.return}}}function Zu(f,d,_){et=f,Ju(f)}function Ju(f,d,_){for(var b=(f.mode&1)!==0;et!==null;){var N=et,D=N.child;if(N.tag===22&&b){var Y=N.memoizedState!==null||oi;if(!Y){var he=N.alternate,Ae=he!==null&&he.memoizedState!==null||Ir;he=oi;var Ye=Ir;if(oi=Y,(Ir=Ae)&&!Ye)for(et=N;et!==null;)Y=et,Ae=Y.child,Y.tag===22&&Y.memoizedState!==null?Lo(N):Ae!==null?(Ae.return=Y,et=Ae):Lo(N);for(;D!==null;)et=D,Ju(D),D=D.sibling;et=N,oi=he,Ir=Ye}Wd(f)}else(N.subtreeFlags&8772)!==0&&D!==null?(D.return=N,et=D):Wd(f)}}function Wd(f){for(;et!==null;){var d=et;if((d.flags&8772)!==0){var _=d.alternate;try{if((d.flags&8772)!==0)switch(d.tag){case 0:case 11:case 15:Ir||Fr(5,d);break;case 1:var b=d.stateNode;if(d.flags&4&&!Ir)if(_===null)b.componentDidMount();else{var N=d.elementType===d.type?_.memoizedProps:mi(d.type,_.memoizedProps);b.componentDidUpdate(N,_.memoizedState,b.__reactInternalSnapshotBeforeUpdate)}var D=d.updateQueue;D!==null&&Wm(d,D,b);break;case 3:var Y=d.updateQueue;if(Y!==null){if(_=null,d.child!==null)switch(d.child.tag){case 5:_=de(d.child.stateNode);break;case 1:_=d.child.stateNode}Wm(d,Y,_)}break;case 5:var he=d.stateNode;_===null&&d.flags&4&&rt(he,d.type,d.memoizedProps,d);break;case 6:break;case 4:break;case 12:break;case 13:if(Ve&&d.memoizedState===null){var Ae=d.alternate;if(Ae!==null){var Ye=Ae.memoizedState;if(Ye!==null){var mt=Ye.dehydrated;mt!==null&&Ee(mt)}}}break;case 19:case 17:case 21:case 22:case 23:break;default:throw Error(a(163))}Ir||d.flags&512&&li(d)}catch(qt){ui(d,d.return,qt)}}if(d===f){et=null;break}if(_=d.sibling,_!==null){_.return=d.return,et=_;break}et=d.return}}function jd(f){for(;et!==null;){var d=et;if(d===f){et=null;break}var _=d.sibling;if(_!==null){_.return=d.return,et=_;break}et=d.return}}function Lo(f){for(;et!==null;){var d=et;try{switch(d.tag){case 0:case 11:case 15:var _=d.return;try{Fr(4,d)}catch(Ae){ui(d,_,Ae)}break;case 1:var b=d.stateNode;if(typeof b.componentDidMount=="function"){var N=d.return;try{b.componentDidMount()}catch(Ae){ui(d,N,Ae)}}var D=d.return;try{li(d)}catch(Ae){ui(d,D,Ae)}break;case 5:var Y=d.return;try{li(d)}catch(Ae){ui(d,Y,Ae)}}}catch(Ae){ui(d,d.return,Ae)}if(d===f){et=null;break}var he=d.sibling;if(he!==null){he.return=d.return,et=he;break}et=d.return}}var Qu=0,ko=1,Do=2,ca=3,Fl=4;if(typeof Symbol=="function"&&Symbol.for){var Oo=Symbol.for;Qu=Oo("selector.component"),ko=Oo("selector.has_pseudo_class"),Do=Oo("selector.role"),ca=Oo("selector.test_id"),Fl=Oo("selector.text")}function ec(f){var d=Ie(f);if(d!=null){if(typeof d.memoizedProps["data-testname"]!="string")throw Error(a(364));return d}if(f=Gt(f),f===null)throw Error(a(362));return f.stateNode.current}function tc(f,d){switch(d.$$typeof){case Qu:if(f.type===d.value)return!0;break;case ko:e:{d=d.value,f=[f,0];for(var _=0;_<f.length;){var b=f[_++],N=f[_++],D=d[N];if(b.tag!==5||!$(b)){for(;D!=null&&tc(b,D);)N++,D=d[N];if(N===d.length){d=!0;break e}else for(b=b.child;b!==null;)f.push(b,N),b=b.sibling}}d=!1}return d;case Do:if(f.tag===5&&Se(f.stateNode,d.value))return!0;break;case Fl:if((f.tag===5||f.tag===6)&&(f=J(f),f!==null&&0<=f.indexOf(d.value)))return!0;break;case ca:if(f.tag===5&&(f=f.memoizedProps["data-testname"],typeof f=="string"&&f.toLowerCase()===d.value.toLowerCase()))return!0;break;default:throw Error(a(365))}return!1}function ja(f){switch(f.$$typeof){case Qu:return"<"+(V(f.value)||"Unknown")+">";case ko:return":has("+(ja(f)||"")+")";case Do:return'[role="'+f.value+'"]';case Fl:return'"'+f.value+'"';case ca:return'[data-testname="'+f.value+'"]';default:throw Error(a(365))}}function Fi(f,d){var _=[];f=[f,0];for(var b=0;b<f.length;){var N=f[b++],D=f[b++],Y=d[D];if(N.tag!==5||!$(N)){for(;Y!=null&&tc(N,Y);)D++,Y=d[D];if(D===d.length)_.push(N);else for(N=N.child;N!==null;)f.push(N,D),N=N.sibling}}return _}function fa(f,d){if(!Pt)throw Error(a(363));f=ec(f),f=Fi(f,d),d=[],f=Array.from(f);for(var _=0;_<f.length;){var b=f[_++];if(b.tag===5)$(b)||d.push(b.stateNode);else for(b=b.child;b!==null;)f.push(b),b=b.sibling}return d}var qd=Math.ceil,nc=o.ReactCurrentDispatcher,Es=o.ReactCurrentOwner,Tn=o.ReactCurrentBatchConfig,Zt=0,lr=null,Mn=null,jn=0,Kr=0,Fo=sr(0),tr=0,Ul=null,zs=0,Ui=0,Uo=0,ha=null,fr=null,rc=0,qa=1/0;function zo(){qa=yr()+500}var zl=!1,Un=null,bs=null,Bl=!1,Bs=null,Bo=0,Vo=0,da=null,Dn=-1,nr=0;function gn(){return(Zt&6)!==0?yr():Dn!==-1?Dn:Dn=yr()}function Ts(f){return(f.mode&1)===0?1:(Zt&2)!==0&&jn!==0?jn&-jn:Gm.transition!==null?(nr===0&&(f=yl,yl<<=1,(yl&4194240)===0&&(yl=64),nr=f),nr):(f=en,f!==0?f:De())}function Yr(f,d,_){if(50<Vo)throw Vo=0,da=null,Error(a(185));var b=Xa(f,d);return b===null?null:(ho(b,d,_),((Zt&2)===0||b!==lr)&&(b===lr&&((Zt&2)===0&&(Ui|=d),tr===4&&zr(b,jn)),_i(b,_),d===1&&Zt===0&&(f.mode&1)===0&&(zo(),vf&&Ki())),b)}function Xa(f,d){f.lanes|=d;var _=f.alternate;for(_!==null&&(_.lanes|=d),_=f,f=f.return;f!==null;)f.childLanes|=d,_=f.alternate,_!==null&&(_.childLanes|=d),_=f,f=f.return;return _.tag===3?_.stateNode:null}function _i(f,d){var _=f.callbackNode;$m(f,d);var b=Iu(f,f===lr?jn:0);if(b===0)_!==null&&_l(_),f.callbackNode=null,f.callbackPriority=0;else if(d=b&-b,f.callbackPriority!==d){if(_!=null&&_l(_),d===1)f.tag===0?xf(zi.bind(null,f)):_f(zi.bind(null,f)),at?dt(function(){Zt===0&&Ki()}):po(mo,Ki),_=null;else{switch(Zs(b)){case 1:_=mo;break;case 4:_=mv;break;case 16:_=gf;break;case 536870912:_=yf;break;default:_=gf}_=Qf(_,Ur.bind(null,f))}f.callbackPriority=d,f.callbackNode=_}}function Ur(f,d){if(Dn=-1,nr=0,(Zt&6)!==0)throw Error(a(327));var _=f.callbackNode;if(Vs()&&f.callbackNode!==_)return null;var b=Iu(f,f===lr?jn:0);if(b===0)return null;if((b&30)!==0||(b&f.expiredLanes)!==0||d)d=oc(f,b);else{d=b;var N=Zt;Zt|=2;var D=Yd();(lr!==f||jn!==d)&&(zo(),pa(f,d));do try{ag();break}catch(he){Kd(f,he)}while(!0);ii(),nc.current=D,Zt=N,Mn!==null?d=0:(lr=null,jn=0,d=tr)}if(d!==0){if(d===2&&(N=df(f),N!==0&&(b=N,d=ic(f,N))),d===1)throw _=Ul,pa(f,0),zr(f,b),_i(f,yr()),_;if(d===6)zr(f,b);else{if(N=f.current.alternate,(b&30)===0&&!Xd(N)&&(d=oc(f,b),d===2&&(D=df(f),D!==0&&(b=D,d=ic(f,D))),d===1))throw _=Ul,pa(f,0),zr(f,b),_i(f,yr()),_;switch(f.finishedWork=N,f.finishedLanes=b,d){case 0:case 1:throw Error(a(345));case 2:Ms(f,fr);break;case 3:if(zr(f,b),(b&130023424)===b&&(d=rc+500-yr(),10<d)){if(Iu(f,0)!==0)break;if(N=f.suspendedLanes,(N&b)!==b){gn(),f.pingedLanes|=f.suspendedLanes&N;break}f.timeoutHandle=tt(Ms.bind(null,f,fr),d);break}Ms(f,fr);break;case 4:if(zr(f,b),(b&4194240)===b)break;for(d=f.eventTimes,N=-1;0<b;){var Y=31-pi(b);D=1<<Y,Y=d[Y],Y>N&&(N=Y),b&=~D}if(b=N,b=yr()-b,b=(120>b?120:480>b?480:1080>b?1080:1920>b?1920:3e3>b?3e3:4320>b?4320:1960*qd(b/1960))-b,10<b){f.timeoutHandle=tt(Ms.bind(null,f,fr),b);break}Ms(f,fr);break;case 5:Ms(f,fr);break;default:throw Error(a(329))}}}return _i(f,yr()),f.callbackNode===_?Ur.bind(null,f):null}function ic(f,d){var _=ha;return f.current.memoizedState.isDehydrated&&(pa(f,d).flags|=256),f=oc(f,d),f!==2&&(d=fr,fr=_,d!==null&&sc(d)),f}function sc(f){fr===null?fr=f:fr.push.apply(fr,f)}function Xd(f){for(var d=f;;){if(d.flags&16384){var _=d.updateQueue;if(_!==null&&(_=_.stores,_!==null))for(var b=0;b<_.length;b++){var N=_[b],D=N.getSnapshot;N=N.value;try{if(!ri(D(),N))return!1}catch{return!1}}}if(_=d.child,d.subtreeFlags&16384&&_!==null)_.return=d,d=_;else{if(d===f)break;for(;d.sibling===null;){if(d.return===null||d.return===f)return!0;d=d.return}d.sibling.return=d.return,d=d.sibling}}return!0}function zr(f,d){for(d&=~Uo,d&=~Ui,f.suspendedLanes|=d,f.pingedLanes&=~d,f=f.expirationTimes;0<d;){var _=31-pi(d),b=1<<_;f[_]=-1,d&=~b}}function zi(f){if((Zt&6)!==0)throw Error(a(327));Vs();var d=Iu(f,0);if((d&1)===0)return _i(f,yr()),null;var _=oc(f,d);if(f.tag!==0&&_===2){var b=df(f);b!==0&&(d=b,_=ic(f,b))}if(_===1)throw _=Ul,pa(f,0),zr(f,d),_i(f,yr()),_;if(_===6)throw Error(a(345));return f.finishedWork=f.current.alternate,f.finishedLanes=d,Ms(f,fr),_i(f,yr()),null}function Vl(f){Bs!==null&&Bs.tag===0&&(Zt&6)===0&&Vs();var d=Zt;Zt|=1;var _=Tn.transition,b=en;try{if(Tn.transition=null,en=1,f)return f()}finally{en=b,Tn.transition=_,Zt=d,(Zt&6)===0&&Ki()}}function ac(){Kr=Fo.current,It(Fo)}function pa(f,d){f.finishedWork=null,f.finishedLanes=0;var _=f.timeoutHandle;if(_!==ut&&(f.timeoutHandle=ut,nt(_)),Mn!==null)for(_=Mn.return;_!==null;){var b=_;switch(Ed(b),b.tag){case 1:b=b.type.childContextTypes,b!=null&&Gn();break;case 3:Nl(),It(Qn),It(on),Eo();break;case 5:Md(b);break;case 4:Nl();break;case 13:It(Xn);break;case 19:It(Xn);break;case 10:Ou(b.type._context);break;case 22:case 23:ac()}_=_.return}if(lr=f,Mn=f=ma(f.current,null),jn=Kr=d,tr=0,Ul=null,Uo=Ui=zs=0,fr=ha=null,Yi!==null){for(d=0;d<Yi.length;d++)if(_=Yi[d],b=_.interleaved,b!==null){_.interleaved=null;var N=b.next,D=_.pending;if(D!==null){var Y=D.next;D.next=N,b.next=Y}_.pending=b}Yi=null}return f}function Kd(f,d){do{var _=Mn;try{if(ii(),Uu.current=Ll,Pf){for(var b=Kn.memoizedState;b!==null;){var N=b.queue;N!==null&&(N.pending=null),b=b.next}Pf=!1}if(bo=0,Nr=Ar=Kn=null,Os=!1,To=0,Es.current=null,_===null||_.return===null){tr=1,Ul=d,Mn=null;break}e:{var D=f,Y=_.return,he=_,Ae=d;if(d=jn,he.flags|=32768,Ae!==null&&typeof Ae=="object"&&typeof Ae.then=="function"){var Ye=Ae,mt=he,qt=mt.tag;if((mt.mode&1)===0&&(qt===0||qt===11||qt===15)){var Lt=mt.alternate;Lt?(mt.updateQueue=Lt.updateQueue,mt.memoizedState=Lt.memoizedState,mt.lanes=Lt.lanes):(mt.updateQueue=null,mt.memoizedState=null)}var Qt=Od(Y);if(Qt!==null){Qt.flags&=-257,Ao(Qt,Y,he,D,d),Qt.mode&1&&ia(D,Ye,d),d=Qt,Ae=Ye;var ct=d.updateQueue;if(ct===null){var Br=new Set;Br.add(Ae),d.updateQueue=Br}else ct.add(Ae);break e}else{if((d&1)===0){ia(D,Ye,d),Jf();break e}Ae=Error(a(426))}}else if(Wn&&he.mode&1){var Vi=Od(Y);if(Vi!==null){(Vi.flags&65536)===0&&(Vi.flags|=256),Ao(Vi,Y,he,D,d),Cf(Ae);break e}}D=Ae,tr!==4&&(tr=2),ha===null?ha=[D]:ha.push(D),Ae=Dd(Ae,he),he=Y;do{switch(he.tag){case 3:he.flags|=65536,d&=-d,he.lanes|=d;var xe=rg(he,Ae,d);Ef(he,xe);break e;case 1:D=Ae;var pe=he.type,be=he.stateNode;if((he.flags&128)===0&&(typeof pe.getDerivedStateFromError=="function"||be!==null&&typeof be.componentDidCatch=="function"&&(bs===null||!bs.has(be)))){he.flags|=65536,d&=-d,he.lanes|=d;var ot=Hf(he,D,d);Ef(he,ot);break e}}he=he.return}while(he!==null)}Jd(_)}catch(Mt){d=Mt,Mn===_&&_!==null&&(Mn=_=_.return);continue}break}while(!0)}function Yd(){var f=nc.current;return nc.current=Ll,f===null?Ll:f}function Jf(){(tr===0||tr===3||tr===2)&&(tr=4),lr===null||(zs&268435455)===0&&(Ui&268435455)===0||zr(lr,jn)}function oc(f,d){var _=Zt;Zt|=2;var b=Yd();lr===f&&jn===d||pa(f,d);do try{sg();break}catch(N){Kd(f,N)}while(!0);if(ii(),Zt=_,nc.current=b,Mn!==null)throw Error(a(261));return lr=null,jn=0,tr}function sg(){for(;Mn!==null;)Zd(Mn)}function ag(){for(;Mn!==null&&!Fa();)Zd(Mn)}function Zd(f){var d=tp(f.alternate,f,Kr);f.memoizedProps=f.pendingProps,d===null?Jd(f):Mn=d,Es.current=null}function Jd(f){var d=f;do{var _=d.alternate;if(f=d.return,(d.flags&32768)===0){if(_=Wf(_,d,Kr),_!==null){Mn=_;return}}else{if(_=Xf(_,d),_!==null){_.flags&=32767,Mn=_;return}if(f!==null)f.flags|=32768,f.subtreeFlags=0,f.deletions=null;else{tr=6,Mn=null;return}}if(d=d.sibling,d!==null){Mn=d;return}Mn=d=f}while(d!==null);tr===0&&(tr=5)}function Ms(f,d){var _=en,b=Tn.transition;try{Tn.transition=null,en=1,og(f,d,_)}finally{Tn.transition=b,en=_}return null}function og(f,d,_){do Vs();while(Bs!==null);if((Zt&6)!==0)throw Error(a(327));var b=f.finishedWork,N=f.finishedLanes;if(b===null)return null;if(f.finishedWork=null,f.finishedLanes=0,b===f.current)throw Error(a(177));f.callbackNode=null,f.callbackPriority=0;var D=b.lanes|b.childLanes;if(mf(f,D),f===lr&&(Mn=lr=null,jn=0),(b.subtreeFlags&2064)===0&&(b.flags&2064)===0||Bl||(Bl=!0,Qf(gf,function(){return Vs(),null})),D=(b.flags&15990)!==0,(b.subtreeFlags&15990)!==0||D){D=Tn.transition,Tn.transition=null;var Y=en;en=1;var he=Zt;Zt|=4,Es.current=null,Vd(f,b),vv(f,b),ee(f.containerInfo),f.current=b,Zu(b),pv(),Zt=he,en=Y,Tn.transition=D}else f.current=b;if(Bl&&(Bl=!1,Bs=f,Bo=N),D=f.pendingLanes,D===0&&(bs=null),Lu(b.stateNode),_i(f,yr()),d!==null)for(_=f.onRecoverableError,b=0;b<d.length;b++)_(d[b]);if(zl)throw zl=!1,f=Un,Un=null,f;return(Bo&1)!==0&&f.tag!==0&&Vs(),D=f.pendingLanes,(D&1)!==0?f===da?Vo++:(Vo=0,da=f):Vo=0,Ki(),null}function Vs(){if(Bs!==null){var f=Zs(Bo),d=Tn.transition,_=en;try{if(Tn.transition=null,en=16>f?16:f,Bs===null)var b=!1;else{if(f=Bs,Bs=null,Bo=0,(Zt&6)!==0)throw Error(a(331));var N=Zt;for(Zt|=4,et=f.current;et!==null;){var D=et,Y=D.child;if((et.flags&16)!==0){var he=D.deletions;if(he!==null){for(var Ae=0;Ae<he.length;Ae++){var Ye=he[Ae];for(et=Ye;et!==null;){var mt=et;switch(mt.tag){case 0:case 11:case 15:ua(8,mt,D)}var qt=mt.child;if(qt!==null)qt.return=mt,et=qt;else for(;et!==null;){mt=et;var Lt=mt.sibling,Qt=mt.return;if(Hd(mt),mt===Ye){et=null;break}if(Lt!==null){Lt.return=Qt,et=Lt;break}et=Qt}}}var ct=D.alternate;if(ct!==null){var Br=ct.child;if(Br!==null){ct.child=null;do{var Vi=Br.sibling;Br.sibling=null,Br=Vi}while(Br!==null)}}et=D}}if((D.subtreeFlags&2064)!==0&&Y!==null)Y.return=D,et=Y;else e:for(;et!==null;){if(D=et,(D.flags&2048)!==0)switch(D.tag){case 0:case 11:case 15:ua(9,D,D.return)}var xe=D.sibling;if(xe!==null){xe.return=D.return,et=xe;break e}et=D.return}}var pe=f.current;for(et=pe;et!==null;){Y=et;var be=Y.child;if((Y.subtreeFlags&2064)!==0&&be!==null)be.return=Y,et=be;else e:for(Y=pe;et!==null;){if(he=et,(he.flags&2048)!==0)try{switch(he.tag){case 0:case 11:case 15:Fr(9,he)}}catch(Mt){ui(he,he.return,Mt)}if(he===Y){et=null;break e}var ot=he.sibling;if(ot!==null){ot.return=he.return,et=ot;break e}et=he.return}}if(Zt=N,Ki(),Ds&&typeof Ds.onPostCommitFiberRoot=="function")try{Ds.onPostCommitFiberRoot(Pu,f)}catch{}b=!0}return b}finally{en=_,Tn.transition=d}}return!1}function lc(f,d,_){d=Dd(_,d),d=rg(f,d,1),Ua(f,d),d=gn(),f=Xa(f,1),f!==null&&(ho(f,1,d),_i(f,d))}function ui(f,d,_){if(f.tag===3)lc(f,f,_);else for(;d!==null;){if(d.tag===3){lc(d,f,_);break}else if(d.tag===1){var b=d.stateNode;if(typeof d.type.getDerivedStateFromError=="function"||typeof b.componentDidCatch=="function"&&(bs===null||!bs.has(b))){f=Dd(_,f),f=Hf(d,f,1),Ua(d,f),f=gn(),d=Xa(d,1),d!==null&&(ho(d,1,f),_i(d,f));break}}d=d.return}}function Qd(f,d,_){var b=f.pingCache;b!==null&&b.delete(d),d=gn(),f.pingedLanes|=f.suspendedLanes&_,lr===f&&(jn&_)===_&&(tr===4||tr===3&&(jn&130023424)===jn&&500>yr()-rc?pa(f,0):Uo|=_),_i(f,d)}function ep(f,d){d===0&&((f.mode&1)===0?d=1:(d=mn,mn<<=1,(mn&130023424)===0&&(mn=4194304)));var _=gn();f=Xa(f,d),f!==null&&(ho(f,d,_),_i(f,_))}function lg(f){var d=f.memoizedState,_=0;d!==null&&(_=d.retryLane),ep(f,_)}function ug(f,d){var _=0;switch(f.tag){case 13:var b=f.stateNode,N=f.memoizedState;N!==null&&(_=N.retryLane);break;case 19:b=f.stateNode;break;default:throw Error(a(314))}b!==null&&b.delete(d),ep(f,_)}var tp;tp=function(f,d,_){if(f!==null)if(f.memoizedProps!==d.pendingProps||Qn.current)Rr=!0;else{if((f.lanes&_)===0&&(d.flags&128)===0)return Rr=!1,qf(f,d,_);Rr=(f.flags&131072)!==0}else Rr=!1,Wn&&(d.flags&1048576)!==0&&Km(d,Af,d.index);switch(d.lanes=0,d.tag){case 2:var b=d.type;f!==null&&(f.alternate=null,d.alternate=null,d.flags|=2),f=d.pendingProps;var N=ni(d,on.current);xl(d,_),N=Cl(null,d,b,f,N,_);var D=Ha();return d.flags|=1,typeof N=="object"&&N!==null&&typeof N.render=="function"&&N.$$typeof===void 0?(d.tag=1,d.memoizedState=null,d.updateQueue=null,ar(b)?(D=!0,Mr(d)):D=!1,d.memoizedState=N.state!==null&&N.state!==void 0?N.state:null,Sl(d),N.updater=Tf,d.stateNode=N,N._reactInternals=d,Sd(d,b,f,_),d=Xr(null,d,b,!0,D,_)):(d.tag=0,Wn&&D&&wd(d),er(null,d,N,_),d=d.child),d;case 16:b=d.elementType;e:{switch(f!==null&&(f.alternate=null,d.alternate=null,d.flags|=2),f=d.pendingProps,N=b._init,b=N(b._payload),d.type=b,N=d.tag=_v(b),f=mi(b,f),N){case 0:d=oa(null,d,b,f,_);break e;case 1:d=Co(null,d,b,f,_);break e;case 11:d=kn(null,d,b,f,_);break e;case 14:d=An(null,d,b,mi(b.type,f),_);break e}throw Error(a(306,b,""))}return d;case 0:return b=d.type,N=d.pendingProps,N=d.elementType===b?N:mi(b,N),oa(f,d,b,N,_);case 1:return b=d.type,N=d.pendingProps,N=d.elementType===b?N:mi(b,N),Co(f,d,b,N,_);case 3:e:{if(qu(d),f===null)throw Error(a(387));b=d.pendingProps,D=d.memoizedState,N=D.element,vd(f,d),bf(d,b,null,_);var Y=d.memoizedState;if(b=Y.element,Ve&&D.isDehydrated)if(D={element:b,isDehydrated:!1,cache:Y.cache,transitions:Y.transitions},d.updateQueue.baseState=D,d.memoizedState=D,d.flags&256){N=Error(a(423)),d=Ud(f,d,b,_,N);break e}else if(b!==N){N=Error(a(424)),d=Ud(f,d,b,_,N);break e}else for(Ve&&(Dr=cf(d.stateNode.containerInfo),si=d,Wn=!0,Qi=null,El=!1),_=Jm(d,null,b,_),d.child=_;_;)_.flags=_.flags&-3|4096,_=_.sibling;else{if(bl(),b===N){d=vi(f,d,_);break e}er(f,d,b,_)}d=d.child}return d;case 5:return Qm(d),f===null&&Ba(d),b=d.type,N=d.pendingProps,D=f!==null?f.memoizedProps:null,Y=N.children,ke(b,N)?Y=null:D!==null&&ke(b,D)&&(d.flags|=32),ai(f,d),er(f,d,Y,_),d.child;case 6:return f===null&&Ba(d),null;case 13:return zd(f,d,_);case 4:return Rf(d,d.stateNode.containerInfo),b=d.pendingProps,f===null?d.child=na(d,null,b,_):er(f,d,b,_),d.child;case 11:return b=d.type,N=d.pendingProps,N=d.elementType===b?N:mi(b,N),kn(f,d,b,N,_);case 7:return er(f,d,d.pendingProps,_),d.child;case 8:return er(f,d,d.pendingProps.children,_),d.child;case 12:return er(f,d,d.pendingProps.children,_),d.child;case 10:e:{if(b=d.type._context,N=d.pendingProps,D=d.memoizedProps,Y=N.value,yo(d,b,Y),D!==null)if(ri(D.value,Y)){if(D.children===N.children&&!Qn.current){d=vi(f,d,_);break e}}else for(D=d.child,D!==null&&(D.return=d);D!==null;){var he=D.dependencies;if(he!==null){Y=D.child;for(var Ae=he.firstContext;Ae!==null;){if(Ae.context===b){if(D.tag===1){Ae=Qs(-1,_&-_),Ae.tag=2;var Ye=D.updateQueue;if(Ye!==null){Ye=Ye.shared;var mt=Ye.pending;mt===null?Ae.next=Ae:(Ae.next=mt.next,mt.next=Ae),Ye.pending=Ae}}D.lanes|=_,Ae=D.alternate,Ae!==null&&(Ae.lanes|=_),vo(D.return,_,d),he.lanes|=_;break}Ae=Ae.next}}else if(D.tag===10)Y=D.type===d.type?null:D.child;else if(D.tag===18){if(Y=D.return,Y===null)throw Error(a(341));Y.lanes|=_,he=Y.alternate,he!==null&&(he.lanes|=_),vo(Y,_,d),Y=D.sibling}else Y=D.child;if(Y!==null)Y.return=D;else for(Y=D;Y!==null;){if(Y===d){Y=null;break}if(D=Y.sibling,D!==null){D.return=Y.return,Y=D;break}Y=Y.return}D=Y}er(f,d,N.children,_),d=d.child}return d;case 9:return N=d.type,b=d.pendingProps.children,xl(d,_),N=gi(N),b=b(N),d.flags|=1,er(f,d,b,_),d.child;case 14:return b=d.type,N=mi(b,d.pendingProps),N=mi(b.type,N),An(f,d,b,N,_);case 15:return aa(f,d,d.type,d.pendingProps,_);case 17:return b=d.type,N=d.pendingProps,N=d.elementType===b?N:mi(b,N),f!==null&&(f.alternate=null,d.alternate=null,d.flags|=2),d.tag=1,ar(b)?(f=!0,Mr(d)):f=!1,xl(d,_),qm(d,b,N),Sd(d,b,N,_),Xr(null,d,b,!0,f,_);case 19:return Io(f,d,_);case 22:return Or(f,d,_)}throw Error(a(156,d.tag))};function Qf(f,d){return po(f,d)}function cg(f,d,_,b){this.tag=f,this.key=_,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=d,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=b,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Bi(f,d,_,b){return new cg(f,d,_,b)}function eh(f){return f=f.prototype,!(!f||!f.isReactComponent)}function _v(f){if(typeof f=="function")return eh(f)?1:0;if(f!=null){if(f=f.$$typeof,f===T)return 11;if(f===C)return 14}return 2}function ma(f,d){var _=f.alternate;return _===null?(_=Bi(f.tag,d,f.key,f.mode),_.elementType=f.elementType,_.type=f.type,_.stateNode=f.stateNode,_.alternate=f,f.alternate=_):(_.pendingProps=d,_.type=f.type,_.flags=0,_.subtreeFlags=0,_.deletions=null),_.flags=f.flags&14680064,_.childLanes=f.childLanes,_.lanes=f.lanes,_.child=f.child,_.memoizedProps=f.memoizedProps,_.memoizedState=f.memoizedState,_.updateQueue=f.updateQueue,d=f.dependencies,_.dependencies=d===null?null:{lanes:d.lanes,firstContext:d.firstContext},_.sibling=f.sibling,_.index=f.index,_.ref=f.ref,_}function th(f,d,_,b,N,D){var Y=2;if(b=f,typeof f=="function")eh(f)&&(Y=1);else if(typeof f=="string")Y=5;else e:switch(f){case p:return Ho(_.children,N,D,d);case m:Y=8,N|=8;break;case y:return f=Bi(12,_,d,N|2),f.elementType=y,f.lanes=D,f;case E:return f=Bi(13,_,d,N),f.elementType=E,f.lanes=D,f;case w:return f=Bi(19,_,d,N),f.elementType=w,f.lanes=D,f;case I:return uc(_,N,D,d);default:if(typeof f=="object"&&f!==null)switch(f.$$typeof){case v:Y=10;break e;case S:Y=9;break e;case T:Y=11;break e;case C:Y=14;break e;case A:Y=16,b=null;break e}throw Error(a(130,f==null?f:typeof f,""))}return d=Bi(Y,_,d,N),d.elementType=f,d.type=b,d.lanes=D,d}function Ho(f,d,_,b){return f=Bi(7,f,b,d),f.lanes=_,f}function uc(f,d,_,b){return f=Bi(22,f,b,d),f.elementType=I,f.lanes=_,f.stateNode={},f}function nh(f,d,_){return f=Bi(6,f,null,d),f.lanes=_,f}function rh(f,d,_){return d=Bi(4,f.children!==null?f.children:[],f.key,d),d.lanes=_,d.stateNode={containerInfo:f.containerInfo,pendingChildren:null,implementation:f.implementation},d}function ih(f,d,_,b,N){this.tag=d,this.containerInfo=f,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=ut,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=pf(0),this.expirationTimes=pf(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=pf(0),this.identifierPrefix=b,this.onRecoverableError=N,Ve&&(this.mutableSourceEagerHydrationData=null)}function fg(f,d,_,b,N,D,Y,he,Ae){return f=new ih(f,d,_,he,Ae),d===1?(d=1,D===!0&&(d|=8)):d=0,D=Bi(3,null,null,d),f.current=D,D.stateNode=f,D.memoizedState={element:b,isDehydrated:_,cache:null,transitions:null},Sl(D),f}function hg(f){if(!f)return Jn;f=f._reactInternals;e:{if(L(f)!==f||f.tag!==1)throw Error(a(170));var d=f;do{switch(d.tag){case 3:d=d.stateNode.context;break e;case 1:if(ar(d.type)){d=d.stateNode.__reactInternalMemoizedMergedChildContext;break e}}d=d.return}while(d!==null);throw Error(a(171))}if(f.tag===1){var _=f.type;if(ar(_))return ml(f,_,d)}return d}function dg(f){var d=f._reactInternals;if(d===void 0)throw typeof f.render=="function"?Error(a(188)):(f=Object.keys(f).join(","),Error(a(268,f)));return f=Q(d),f===null?null:f.stateNode}function ns(f,d){if(f=f.memoizedState,f!==null&&f.dehydrated!==null){var _=f.retryLane;f.retryLane=_!==0&&_<d?_:d}}function cc(f,d){ns(f,d),(f=f.alternate)&&ns(f,d)}function sh(f){return f=Q(f),f===null?null:f.stateNode}function pg(){return null}return t.attemptContinuousHydration=function(f){if(f.tag===13){var d=gn();Yr(f,134217728,d),cc(f,134217728)}},t.attemptHydrationAtCurrentPriority=function(f){if(f.tag===13){var d=gn(),_=Ts(f);Yr(f,_,d),cc(f,_)}},t.attemptSynchronousHydration=function(f){switch(f.tag){case 3:var d=f.stateNode;if(d.current.memoizedState.isDehydrated){var _=vl(d.pendingLanes);_!==0&&(ks(d,_|1),_i(d,yr()),(Zt&6)===0&&(zo(),Ki()))}break;case 13:var b=gn();Vl(function(){return Yr(f,1,b)}),cc(f,1)}},t.batchedUpdates=function(f,d){var _=Zt;Zt|=1;try{return f(d)}finally{Zt=_,Zt===0&&(zo(),vf&&Ki())}},t.createComponentSelector=function(f){return{$$typeof:Qu,value:f}},t.createContainer=function(f,d,_,b,N,D,Y){return fg(f,d,!1,null,_,b,N,D,Y)},t.createHasPseudoClassSelector=function(f){return{$$typeof:ko,value:f}},t.createHydrationContainer=function(f,d,_,b,N,D,Y,he,Ae){return f=fg(_,b,!0,f,N,D,Y,he,Ae),f.context=hg(null),_=f.current,b=gn(),N=Ts(_),D=Qs(b,N),D.callback=d??null,Ua(_,D),f.current.lanes=N,ho(f,N,b),_i(f,b),f},t.createPortal=function(f,d,_){var b=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:h,key:b==null?null:""+b,children:f,containerInfo:d,implementation:_}},t.createRoleSelector=function(f){return{$$typeof:Do,value:f}},t.createTestNameSelector=function(f){return{$$typeof:ca,value:f}},t.createTextSelector=function(f){return{$$typeof:Fl,value:f}},t.deferredUpdates=function(f){var d=en,_=Tn.transition;try{return Tn.transition=null,en=16,f()}finally{en=d,Tn.transition=_}},t.discreteUpdates=function(f,d,_,b,N){var D=en,Y=Tn.transition;try{return Tn.transition=null,en=1,f(d,_,b,N)}finally{en=D,Tn.transition=Y,Zt===0&&zo()}},t.findAllNodes=fa,t.findBoundingRects=function(f,d){if(!Pt)throw Error(a(363));d=fa(f,d),f=[];for(var _=0;_<d.length;_++)f.push(wn(d[_]));for(d=f.length-1;0<d;d--){_=f[d];for(var b=_.x,N=b+_.width,D=_.y,Y=D+_.height,he=d-1;0<=he;he--)if(d!==he){var Ae=f[he],Ye=Ae.x,mt=Ye+Ae.width,qt=Ae.y,Lt=qt+Ae.height;if(b>=Ye&&D>=qt&&N<=mt&&Y<=Lt){f.splice(d,1);break}else if(b!==Ye||_.width!==Ae.width||Lt<D||qt>Y){if(!(D!==qt||_.height!==Ae.height||mt<b||Ye>N)){Ye>b&&(Ae.width+=Ye-b,Ae.x=b),mt<N&&(Ae.width=N-Ye),f.splice(d,1);break}}else{qt>D&&(Ae.height+=qt-D,Ae.y=D),Lt<Y&&(Ae.height=Y-qt),f.splice(d,1);break}}}return f},t.findHostInstance=dg,t.findHostInstanceWithNoPortals=function(f){return f=O(f),f=f!==null?K(f):null,f===null?null:f.stateNode},t.findHostInstanceWithWarning=function(f){return dg(f)},t.flushControlled=function(f){var d=Zt;Zt|=1;var _=Tn.transition,b=en;try{Tn.transition=null,en=1,f()}finally{en=b,Tn.transition=_,Zt=d,Zt===0&&(zo(),Ki())}},t.flushPassiveEffects=Vs,t.flushSync=Vl,t.focusWithin=function(f,d){if(!Pt)throw Error(a(363));for(f=ec(f),d=Fi(f,d),d=Array.from(d),f=0;f<d.length;){var _=d[f++];if(!$(_)){if(_.tag===5&&qe(_.stateNode))return!0;for(_=_.child;_!==null;)d.push(_),_=_.sibling}}return!1},t.getCurrentUpdatePriority=function(){return en},t.getFindAllNodesFailureDescription=function(f,d){if(!Pt)throw Error(a(363));var _=0,b=[];f=[ec(f),0];for(var N=0;N<f.length;){var D=f[N++],Y=f[N++],he=d[Y];if((D.tag!==5||!$(D))&&(tc(D,he)&&(b.push(ja(he)),Y++,Y>_&&(_=Y)),Y<d.length))for(D=D.child;D!==null;)f.push(D,Y),D=D.sibling}if(_<d.length){for(f=[];_<d.length;_++)f.push(ja(d[_]));return`findAllNodes was able to match part of the selector:
  `+(b.join(" > ")+`

No matching component was found for:
  `)+f.join(" > ")}return null},t.getPublicRootInstance=function(f){if(f=f.current,!f.child)return null;switch(f.child.tag){case 5:return de(f.child.stateNode);default:return f.child.stateNode}},t.injectIntoDevTools=function(f){if(f={bundleType:f.bundleType,version:f.version,rendererPackageName:f.rendererPackageName,rendererConfig:f.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:o.ReactCurrentDispatcher,findHostInstanceByFiber:sh,findFiberByHostInstance:f.findFiberByHostInstance||pg,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.0.0-fc46dba67-20220329"},typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u")f=!1;else{var d=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(d.isDisabled||!d.supportsFiber)f=!0;else{try{Pu=d.inject(f),Ds=d}catch{}f=!!d.checkDCE}}return f},t.isAlreadyRendering=function(){return!1},t.observeVisibleRects=function(f,d,_,b){if(!Pt)throw Error(a(363));f=fa(f,d);var N=Oe(f,_,b).disconnect;return{disconnect:function(){N()}}},t.registerMutableSourceForHydration=function(f,d){var _=d._getVersion;_=_(d._source),f.mutableSourceEagerHydrationData==null?f.mutableSourceEagerHydrationData=[d,_]:f.mutableSourceEagerHydrationData.push(d,_)},t.runWithPriority=function(f,d){var _=en;try{return en=f,d()}finally{en=_}},t.shouldError=function(){return null},t.shouldSuspend=function(){return!1},t.updateContainer=function(f,d,_,b){var N=d.current,D=gn(),Y=Ts(N);return _=hg(_),d.context===null?d.context=_:d.pendingContext=_,d=Qs(D,Y),d.payload={element:f},b=b===void 0?null:b,b!==null&&(d.callback=b),Ua(N,d),f=Yr(N,Y,D),f!==null&&wf(f,N,Y),Y},t}),L_}var $b;function g4(){return $b||($b=1,R_.exports=m4()),R_.exports}var y4=g4();const v4=v0(y4);var Gb=t2();const l1={},_4=r=>void Object.assign(l1,r);function x4(r,e){function t(p,{args:m=[],attach:y,...v},S){let T=`${p[0].toUpperCase()}${p.slice(1)}`,E;if(p==="primitive"){if(v.object===void 0)throw new Error("R3F: Primitives without 'object' are invalid!");const w=v.object;E=Ph(w,{type:p,root:S,attach:y,primitive:!0})}else{const w=l1[T];if(!w)throw new Error(`R3F: ${T} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);if(!Array.isArray(m))throw new Error("R3F: The args prop must be an array!");E=Ph(new w(...m),{type:p,root:S,attach:y,memoizedProps:{args:m}})}return E.__r3f.attach===void 0&&(E.isBufferGeometry?E.__r3f.attach="geometry":E.isMaterial&&(E.__r3f.attach="material")),T!=="inject"&&O_(E,v),E}function n(p,m){let y=!1;if(m){var v,S;(v=m.__r3f)!=null&&v.attach?D_(p,m,m.__r3f.attach):m.isObject3D&&p.isObject3D&&(p.add(m),y=!0),y||(S=p.__r3f)==null||S.objects.push(m),m.__r3f||Ph(m,{}),m.__r3f.parent=p,Hx(m),Lh(m)}}function i(p,m,y){let v=!1;if(m){var S,T;if((S=m.__r3f)!=null&&S.attach)D_(p,m,m.__r3f.attach);else if(m.isObject3D&&p.isObject3D){m.parent=p,m.dispatchEvent({type:"added"}),p.dispatchEvent({type:"childadded",child:m});const E=p.children.filter(C=>C!==m),w=E.indexOf(y);p.children=[...E.slice(0,w),m,...E.slice(w)],v=!0}v||(T=p.__r3f)==null||T.objects.push(m),m.__r3f||Ph(m,{}),m.__r3f.parent=p,Hx(m),Lh(m)}}function s(p,m,y=!1){p&&[...p].forEach(v=>a(m,v,y))}function a(p,m,y){if(m){var v,S,T;if(m.__r3f&&(m.__r3f.parent=null),(v=p.__r3f)!=null&&v.objects&&(p.__r3f.objects=p.__r3f.objects.filter(I=>I!==m)),(S=m.__r3f)!=null&&S.attach)Kb(p,m,m.__r3f.attach);else if(m.isObject3D&&p.isObject3D){var E;p.remove(m),(E=m.__r3f)!=null&&E.root&&A4(zy(m),m)}const C=(T=m.__r3f)==null?void 0:T.primitive,A=!C&&(y===void 0?m.dispose!==null:y);if(!C){var w;s((w=m.__r3f)==null?void 0:w.objects,m,A),s(m.children,m,A)}if(delete m.__r3f,A&&m.dispose&&m.type!=="Scene"){const I=()=>{try{m.dispose()}catch{}};typeof IS_REACT_ACT_ENVIRONMENT>"u"?Gb.unstable_scheduleCallback(Gb.unstable_IdlePriority,I):I()}Lh(p)}}function o(p,m,y,v){var S;const T=(S=p.__r3f)==null?void 0:S.parent;if(!T)return;const E=t(m,y,p.__r3f.root);if(p.children){for(const w of p.children)w.__r3f&&n(E,w);p.children=p.children.filter(w=>!w.__r3f)}p.__r3f.objects.forEach(w=>n(E,w)),p.__r3f.objects=[],p.__r3f.autoRemovedBeforeAppend||a(T,p),E.parent&&(E.__r3f.autoRemovedBeforeAppend=!0),n(T,E),E.raycast&&E.__r3f.eventCount&&zy(E).getState().internal.interaction.push(E),[v,v.alternate].forEach(w=>{w!==null&&(w.stateNode=E,w.ref&&(typeof w.ref=="function"?w.ref(E):w.ref.current=E))})}const u=()=>{};return{reconciler:v4({createInstance:t,removeChild:a,appendChild:n,appendInitialChild:n,insertBefore:i,supportsMutation:!0,isPrimaryRenderer:!1,supportsPersistence:!1,supportsHydration:!1,noTimeout:-1,appendChildToContainer:(p,m)=>{if(!m)return;const y=p.getState().scene;y.__r3f&&(y.__r3f.root=p,n(y,m))},removeChildFromContainer:(p,m)=>{m&&a(p.getState().scene,m)},insertInContainerBefore:(p,m,y)=>{if(!m||!y)return;const v=p.getState().scene;v.__r3f&&i(v,m,y)},getRootHostContext:()=>null,getChildHostContext:p=>p,finalizeInitialChildren(p){var m;return!!((m=p==null?void 0:p.__r3f)!=null?m:{}).handlers},prepareUpdate(p,m,y,v){var S;if(((S=p==null?void 0:p.__r3f)!=null?S:{}).primitive&&v.object&&v.object!==p)return[!0];{const{args:E=[],children:w,...C}=v,{args:A=[],children:I,...F}=y;if(!Array.isArray(E))throw new Error("R3F: the args prop must be an array!");if(E.some((V,G)=>V!==A[G]))return[!0];const U=l2(p,C,F,!0);return U.changes.length?[!1,U]:null}},commitUpdate(p,[m,y],v,S,T,E){m?o(p,v,T,E):O_(p,y)},commitMount(p,m,y,v){var S;const T=(S=p.__r3f)!=null?S:{};p.raycast&&T.handlers&&T.eventCount&&zy(p).getState().internal.interaction.push(p)},getPublicInstance:p=>p,prepareForCommit:()=>null,preparePortalMount:p=>Ph(p.getState().scene),resetAfterCommit:()=>{},shouldSetTextContent:()=>!1,clearContainer:()=>!1,hideInstance(p){var m;const{attach:y,parent:v}=(m=p.__r3f)!=null?m:{};y&&v&&Kb(v,p,y),p.isObject3D&&(p.visible=!1),Lh(p)},unhideInstance(p,m){var y;const{attach:v,parent:S}=(y=p.__r3f)!=null?y:{};v&&S&&D_(S,p,v),(p.isObject3D&&m.visible==null||m.visible)&&(p.visible=!0),Lh(p)},createTextInstance:u,hideTextInstance:u,unhideTextInstance:u,getCurrentEventPriority:()=>e?e():Bh.DefaultEventPriority,beforeActiveInstanceBlur:()=>{},afterActiveInstanceBlur:()=>{},detachDeletedInstance:()=>{},now:typeof performance<"u"&&Yn.fun(performance.now)?performance.now:Yn.fun(Date.now)?Date.now:()=>0,scheduleTimeout:Yn.fun(setTimeout)?setTimeout:void 0,cancelTimeout:Yn.fun(clearTimeout)?clearTimeout:void 0}),applyProps:O_}}var Wb,jb;const k_=r=>"colorSpace"in r||"outputColorSpace"in r,n2=()=>{var r;return(r=l1.ColorManagement)!=null?r:null},r2=r=>r&&r.isOrthographicCamera,S4=r=>r&&r.hasOwnProperty("current"),Cm=typeof window<"u"&&((Wb=window.document)!=null&&Wb.createElement||((jb=window.navigator)==null?void 0:jb.product)==="ReactNative")?gt.useLayoutEffect:gt.useEffect;function i2(r){const e=gt.useRef(r);return Cm(()=>void(e.current=r),[r]),e}function w4({set:r}){return Cm(()=>(r(new Promise(()=>null)),()=>r(!1)),[r]),null}class s2 extends gt.Component{constructor(...e){super(...e),this.state={error:!1}}componentDidCatch(e){this.props.set(e)}render(){return this.state.error?null:this.props.children}}s2.getDerivedStateFromError=()=>({error:!0});const a2="__default",qb=new Map,E4=r=>r&&!!r.memoized&&!!r.changes;function o2(r){var e;const t=typeof window<"u"?(e=window.devicePixelRatio)!=null?e:2:1;return Array.isArray(r)?Math.min(Math.max(r[0],t),r[1]):r}const xp=r=>{var e;return(e=r.__r3f)==null?void 0:e.root.getState()};function zy(r){let e=r.__r3f.root;for(;e.getState().previousRoot;)e=e.getState().previousRoot;return e}const Yn={obj:r=>r===Object(r)&&!Yn.arr(r)&&typeof r!="function",fun:r=>typeof r=="function",str:r=>typeof r=="string",num:r=>typeof r=="number",boo:r=>typeof r=="boolean",und:r=>r===void 0,arr:r=>Array.isArray(r),equ(r,e,{arrays:t="shallow",objects:n="reference",strict:i=!0}={}){if(typeof r!=typeof e||!!r!=!!e)return!1;if(Yn.str(r)||Yn.num(r)||Yn.boo(r))return r===e;const s=Yn.obj(r);if(s&&n==="reference")return r===e;const a=Yn.arr(r);if(a&&t==="reference")return r===e;if((a||s)&&r===e)return!0;let o;for(o in r)if(!(o in e))return!1;if(s&&t==="shallow"&&n==="shallow"){for(o in i?e:r)if(!Yn.equ(r[o],e[o],{strict:i,objects:"reference"}))return!1}else for(o in i?e:r)if(r[o]!==e[o])return!1;if(Yn.und(o)){if(a&&r.length===0&&e.length===0||s&&Object.keys(r).length===0&&Object.keys(e).length===0)return!0;if(r!==e)return!1}return!0}};function b4(r){r.dispose&&r.type!=="Scene"&&r.dispose();for(const e in r)e.dispose==null||e.dispose(),delete r[e]}function Ph(r,e){const t=r;return t.__r3f={type:"",root:null,previousAttach:null,memoizedProps:{},eventCount:0,handlers:{},objects:[],parent:null,...e},r}function Vx(r,e){let t=r;if(e.includes("-")){const n=e.split("-"),i=n.pop();return t=n.reduce((s,a)=>s[a],r),{target:t,key:i}}else return{target:t,key:e}}const Xb=/-\d+$/;function D_(r,e,t){if(Yn.str(t)){if(Xb.test(t)){const s=t.replace(Xb,""),{target:a,key:o}=Vx(r,s);Array.isArray(a[o])||(a[o]=[])}const{target:n,key:i}=Vx(r,t);e.__r3f.previousAttach=n[i],n[i]=e}else e.__r3f.previousAttach=t(r,e)}function Kb(r,e,t){var n,i;if(Yn.str(t)){const{target:s,key:a}=Vx(r,t),o=e.__r3f.previousAttach;o===void 0?delete s[a]:s[a]=o}else(n=e.__r3f)==null||n.previousAttach==null||n.previousAttach(r,e);(i=e.__r3f)==null||delete i.previousAttach}function l2(r,{children:e,key:t,ref:n,...i},{children:s,key:a,ref:o,...u}={},h=!1){const p=r.__r3f,m=Object.entries(i),y=[];if(h){const S=Object.keys(u);for(let T=0;T<S.length;T++)i.hasOwnProperty(S[T])||m.unshift([S[T],a2+"remove"])}m.forEach(([S,T])=>{var E;if((E=r.__r3f)!=null&&E.primitive&&S==="object"||Yn.equ(T,u[S]))return;if(/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(S))return y.push([S,T,!0,[]]);let w=[];S.includes("-")&&(w=S.split("-")),y.push([S,T,!1,w]);for(const C in i){const A=i[C];C.startsWith(`${S}-`)&&y.push([C,A,!1,C.split("-")])}});const v={...i};return p!=null&&p.memoizedProps&&p!=null&&p.memoizedProps.args&&(v.args=p.memoizedProps.args),p!=null&&p.memoizedProps&&p!=null&&p.memoizedProps.attach&&(v.attach=p.memoizedProps.attach),{memoized:v,changes:y}}function O_(r,e){var t;const n=r.__r3f,i=n==null?void 0:n.root,s=i==null||i.getState==null?void 0:i.getState(),{memoized:a,changes:o}=E4(e)?e:l2(r,e),u=n==null?void 0:n.eventCount;r.__r3f&&(r.__r3f.memoizedProps=a);for(let y=0;y<o.length;y++){let[v,S,T,E]=o[y];if(k_(r)){const I="srgb",F="srgb-linear";v==="encoding"?(v="colorSpace",S=S===3001?I:F):v==="outputEncoding"&&(v="outputColorSpace",S=S===3001?I:F)}let w=r,C=w[v];if(E.length&&(C=E.reduce((A,I)=>A[I],r),!(C&&C.set))){const[A,...I]=E.reverse();w=I.reverse().reduce((F,U)=>F[U],r),v=A}if(S===a2+"remove")if(w.constructor){let A=qb.get(w.constructor);A||(A=new w.constructor,qb.set(w.constructor,A)),S=A[v]}else S=0;if(T&&n)S?n.handlers[v]=S:delete n.handlers[v],n.eventCount=Object.keys(n.handlers).length;else if(C&&C.set&&(C.copy||C instanceof Hc)){if(Array.isArray(S))C.fromArray?C.fromArray(S):C.set(...S);else if(C.copy&&S&&S.constructor&&C.constructor===S.constructor)C.copy(S);else if(S!==void 0){var h;const A=(h=C)==null?void 0:h.isColor;!A&&C.setScalar?C.setScalar(S):C instanceof Hc&&S instanceof Hc?C.mask=S.mask:C.set(S),!n2()&&s&&!s.linear&&A&&C.convertSRGBToLinear()}}else{var p;if(w[v]=S,(p=w[v])!=null&&p.isTexture&&w[v].format===hs&&w[v].type===to&&s){const A=w[v];k_(A)&&k_(s.gl)?A.colorSpace=s.gl.outputColorSpace:A.encoding=s.gl.outputEncoding}}Lh(r)}if(n&&n.parent&&r.raycast&&u!==n.eventCount){const y=zy(r).getState().internal,v=y.interaction.indexOf(r);v>-1&&y.interaction.splice(v,1),n.eventCount&&y.interaction.push(r)}return!(o.length===1&&o[0][0]==="onUpdate")&&o.length&&(t=r.__r3f)!=null&&t.parent&&Hx(r),r}function Lh(r){var e,t;const n=(e=r.__r3f)==null||(t=e.root)==null||t.getState==null?void 0:t.getState();n&&n.internal.frames===0&&n.invalidate()}function Hx(r){r.onUpdate==null||r.onUpdate(r)}function T4(r,e){r.manual||(r2(r)?(r.left=e.width/-2,r.right=e.width/2,r.top=e.height/2,r.bottom=e.height/-2):r.aspect=e.width/e.height,r.updateProjectionMatrix(),r.updateMatrixWorld())}function My(r){return(r.eventObject||r.object).uuid+"/"+r.index+r.instanceId}function M4(){var r;const e=typeof self<"u"&&self||typeof window<"u"&&window;if(!e)return Bh.DefaultEventPriority;switch((r=e.event)==null?void 0:r.type){case"click":case"contextmenu":case"dblclick":case"pointercancel":case"pointerdown":case"pointerup":return Bh.DiscreteEventPriority;case"pointermove":case"pointerout":case"pointerover":case"pointerenter":case"pointerleave":case"wheel":return Bh.ContinuousEventPriority;default:return Bh.DefaultEventPriority}}function u2(r,e,t,n){const i=t.get(e);i&&(t.delete(e),t.size===0&&(r.delete(n),i.target.releasePointerCapture(n)))}function A4(r,e){const{internal:t}=r.getState();t.interaction=t.interaction.filter(n=>n!==e),t.initialHits=t.initialHits.filter(n=>n!==e),t.hovered.forEach((n,i)=>{(n.eventObject===e||n.object===e)&&t.hovered.delete(i)}),t.capturedMap.forEach((n,i)=>{u2(t.capturedMap,e,n,i)})}function N4(r){function e(u){const{internal:h}=r.getState(),p=u.offsetX-h.initialClick[0],m=u.offsetY-h.initialClick[1];return Math.round(Math.sqrt(p*p+m*m))}function t(u){return u.filter(h=>["Move","Over","Enter","Out","Leave"].some(p=>{var m;return(m=h.__r3f)==null?void 0:m.handlers["onPointer"+p]}))}function n(u,h){const p=r.getState(),m=new Set,y=[],v=h?h(p.internal.interaction):p.internal.interaction;for(let w=0;w<v.length;w++){const C=xp(v[w]);C&&(C.raycaster.camera=void 0)}p.previousRoot||p.events.compute==null||p.events.compute(u,p);function S(w){const C=xp(w);if(!C||!C.events.enabled||C.raycaster.camera===null)return[];if(C.raycaster.camera===void 0){var A;C.events.compute==null||C.events.compute(u,C,(A=C.previousRoot)==null?void 0:A.getState()),C.raycaster.camera===void 0&&(C.raycaster.camera=null)}return C.raycaster.camera?C.raycaster.intersectObject(w,!0):[]}let T=v.flatMap(S).sort((w,C)=>{const A=xp(w.object),I=xp(C.object);return!A||!I?w.distance-C.distance:I.events.priority-A.events.priority||w.distance-C.distance}).filter(w=>{const C=My(w);return m.has(C)?!1:(m.add(C),!0)});p.events.filter&&(T=p.events.filter(T,p));for(const w of T){let C=w.object;for(;C;){var E;(E=C.__r3f)!=null&&E.eventCount&&y.push({...w,eventObject:C}),C=C.parent}}if("pointerId"in u&&p.internal.capturedMap.has(u.pointerId))for(let w of p.internal.capturedMap.get(u.pointerId).values())m.has(My(w.intersection))||y.push(w.intersection);return y}function i(u,h,p,m){const y=r.getState();if(u.length){const v={stopped:!1};for(const S of u){const T=xp(S.object)||y,{raycaster:E,pointer:w,camera:C,internal:A}=T,I=new X(w.x,w.y,0).unproject(C),F=k=>{var O,Q;return(O=(Q=A.capturedMap.get(k))==null?void 0:Q.has(S.eventObject))!=null?O:!1},U=k=>{const O={intersection:S,target:h.target};A.capturedMap.has(k)?A.capturedMap.get(k).set(S.eventObject,O):A.capturedMap.set(k,new Map([[S.eventObject,O]])),h.target.setPointerCapture(k)},V=k=>{const O=A.capturedMap.get(k);O&&u2(A.capturedMap,S.eventObject,O,k)};let G={};for(let k in h){let O=h[k];typeof O!="function"&&(G[k]=O)}let L={...S,...G,pointer:w,intersections:u,stopped:v.stopped,delta:p,unprojectedPoint:I,ray:E.ray,camera:C,stopPropagation(){const k="pointerId"in h&&A.capturedMap.get(h.pointerId);if((!k||k.has(S.eventObject))&&(L.stopped=v.stopped=!0,A.hovered.size&&Array.from(A.hovered.values()).find(O=>O.eventObject===S.eventObject))){const O=u.slice(0,u.indexOf(S));s([...O,S])}},target:{hasPointerCapture:F,setPointerCapture:U,releasePointerCapture:V},currentTarget:{hasPointerCapture:F,setPointerCapture:U,releasePointerCapture:V},nativeEvent:h};if(m(L),v.stopped===!0)break}}return u}function s(u){const{internal:h}=r.getState();for(const p of h.hovered.values())if(!u.length||!u.find(m=>m.object===p.object&&m.index===p.index&&m.instanceId===p.instanceId)){const y=p.eventObject.__r3f,v=y==null?void 0:y.handlers;if(h.hovered.delete(My(p)),y!=null&&y.eventCount){const S={...p,intersections:u};v.onPointerOut==null||v.onPointerOut(S),v.onPointerLeave==null||v.onPointerLeave(S)}}}function a(u,h){for(let p=0;p<h.length;p++){const m=h[p].__r3f;m==null||m.handlers.onPointerMissed==null||m.handlers.onPointerMissed(u)}}function o(u){switch(u){case"onPointerLeave":case"onPointerCancel":return()=>s([]);case"onLostPointerCapture":return h=>{const{internal:p}=r.getState();"pointerId"in h&&p.capturedMap.has(h.pointerId)&&requestAnimationFrame(()=>{p.capturedMap.has(h.pointerId)&&(p.capturedMap.delete(h.pointerId),s([]))})}}return function(p){const{onPointerMissed:m,internal:y}=r.getState();y.lastEvent.current=p;const v=u==="onPointerMove",S=u==="onClick"||u==="onContextMenu"||u==="onDoubleClick",E=n(p,v?t:void 0),w=S?e(p):0;u==="onPointerDown"&&(y.initialClick=[p.offsetX,p.offsetY],y.initialHits=E.map(A=>A.eventObject)),S&&!E.length&&w<=2&&(a(p,y.interaction),m&&m(p)),v&&s(E);function C(A){const I=A.eventObject,F=I.__r3f,U=F==null?void 0:F.handlers;if(F!=null&&F.eventCount)if(v){if(U.onPointerOver||U.onPointerEnter||U.onPointerOut||U.onPointerLeave){const V=My(A),G=y.hovered.get(V);G?G.stopped&&A.stopPropagation():(y.hovered.set(V,A),U.onPointerOver==null||U.onPointerOver(A),U.onPointerEnter==null||U.onPointerEnter(A))}U.onPointerMove==null||U.onPointerMove(A)}else{const V=U[u];V?(!S||y.initialHits.includes(I))&&(a(p,y.interaction.filter(G=>!y.initialHits.includes(G))),V(A)):S&&y.initialHits.includes(I)&&a(p,y.interaction.filter(G=>!y.initialHits.includes(G)))}}i(E,p,w,C)}}return{handlePointer:o}}const c2=r=>!!(r!=null&&r.render),f2=gt.createContext(null),C4=(r,e)=>{const t=d4((o,u)=>{const h=new X,p=new X,m=new X;function y(w=u().camera,C=p,A=u().size){const{width:I,height:F,top:U,left:V}=A,G=I/F;C.isVector3?m.copy(C):m.set(...C);const L=w.getWorldPosition(h).distanceTo(m);if(r2(w))return{width:I/w.zoom,height:F/w.zoom,top:U,left:V,factor:1,distance:L,aspect:G};{const k=w.fov*Math.PI/180,O=2*Math.tan(k/2)*L,Q=O*(I/F);return{width:Q,height:O,top:U,left:V,factor:I/Q,distance:L,aspect:G}}}let v;const S=w=>o(C=>({performance:{...C.performance,current:w}})),T=new Pe;return{set:o,get:u,gl:null,camera:null,raycaster:null,events:{priority:1,enabled:!0,connected:!1},xr:null,scene:null,invalidate:(w=1)=>r(u(),w),advance:(w,C)=>e(w,C,u()),legacy:!1,linear:!1,flat:!1,controls:null,clock:new i1,pointer:T,mouse:T,frameloop:"always",onPointerMissed:void 0,performance:{current:1,min:.5,max:1,debounce:200,regress:()=>{const w=u();v&&clearTimeout(v),w.performance.current!==w.performance.min&&S(w.performance.min),v=setTimeout(()=>S(u().performance.max),w.performance.debounce)}},size:{width:0,height:0,top:0,left:0,updateStyle:!1},viewport:{initialDpr:0,dpr:0,width:0,height:0,top:0,left:0,aspect:0,distance:0,factor:0,getCurrentViewport:y},setEvents:w=>o(C=>({...C,events:{...C.events,...w}})),setSize:(w,C,A,I,F)=>{const U=u().camera,V={width:w,height:C,top:I||0,left:F||0,updateStyle:A};o(G=>({size:V,viewport:{...G.viewport,...y(U,p,V)}}))},setDpr:w=>o(C=>{const A=o2(w);return{viewport:{...C.viewport,dpr:A,initialDpr:C.viewport.initialDpr||A}}}),setFrameloop:(w="always")=>{const C=u().clock;C.stop(),C.elapsedTime=0,w!=="never"&&(C.start(),C.elapsedTime=0),o(()=>({frameloop:w}))},previousRoot:void 0,internal:{active:!1,priority:0,frames:0,lastEvent:gt.createRef(),interaction:[],hovered:new Map,subscribers:[],initialClick:[0,0],initialHits:[],capturedMap:new Map,subscribe:(w,C,A)=>{const I=u().internal;return I.priority=I.priority+(C>0?1:0),I.subscribers.push({ref:w,priority:C,store:A}),I.subscribers=I.subscribers.sort((F,U)=>F.priority-U.priority),()=>{const F=u().internal;F!=null&&F.subscribers&&(F.priority=F.priority-(C>0?1:0),F.subscribers=F.subscribers.filter(U=>U.ref!==w))}}}}}),n=t.getState();let i=n.size,s=n.viewport.dpr,a=n.camera;return t.subscribe(()=>{const{camera:o,size:u,viewport:h,gl:p,set:m}=t.getState();if(u.width!==i.width||u.height!==i.height||h.dpr!==s){var y;i=u,s=h.dpr,T4(o,u),p.setPixelRatio(h.dpr);const v=(y=u.updateStyle)!=null?y:typeof HTMLCanvasElement<"u"&&p.domElement instanceof HTMLCanvasElement;p.setSize(u.width,u.height,v)}o!==a&&(a=o,m(v=>({viewport:{...v.viewport,...v.viewport.getCurrentViewport(o)}})))}),t.subscribe(o=>r(o)),t};let Ay,R4=new Set,I4=new Set,P4=new Set;function F_(r,e){if(r.size)for(const{callback:t}of r.values())t(e)}function Sp(r,e){switch(r){case"before":return F_(R4,e);case"after":return F_(I4,e);case"tail":return F_(P4,e)}}let U_,z_;function B_(r,e,t){let n=e.clock.getDelta();for(e.frameloop==="never"&&typeof r=="number"&&(n=r-e.clock.elapsedTime,e.clock.oldTime=e.clock.elapsedTime,e.clock.elapsedTime=r),U_=e.internal.subscribers,Ay=0;Ay<U_.length;Ay++)z_=U_[Ay],z_.ref.current(z_.store.getState(),n,t);return!e.internal.priority&&e.gl.render&&e.gl.render(e.scene,e.camera),e.internal.frames=Math.max(0,e.internal.frames-1),e.frameloop==="always"?1:e.internal.frames}function L4(r){let e=!1,t=!1,n,i,s;function a(h){i=requestAnimationFrame(a),e=!0,n=0,Sp("before",h),t=!0;for(const m of r.values()){var p;s=m.store.getState(),s.internal.active&&(s.frameloop==="always"||s.internal.frames>0)&&!((p=s.gl.xr)!=null&&p.isPresenting)&&(n+=B_(h,s))}if(t=!1,Sp("after",h),n===0)return Sp("tail",h),e=!1,cancelAnimationFrame(i)}function o(h,p=1){var m;if(!h)return r.forEach(y=>o(y.store.getState(),p));(m=h.gl.xr)!=null&&m.isPresenting||!h.internal.active||h.frameloop==="never"||(p>1?h.internal.frames=Math.min(60,h.internal.frames+p):t?h.internal.frames=2:h.internal.frames=1,e||(e=!0,requestAnimationFrame(a)))}function u(h,p=!0,m,y){if(p&&Sp("before",h),m)B_(h,m,y);else for(const v of r.values())B_(h,v.store.getState());p&&Sp("after",h)}return{loop:a,invalidate:o,advance:u}}function h2(){const r=gt.useContext(f2);if(!r)throw new Error("R3F: Hooks can only be used within the Canvas component!");return r}function Zo(r=t=>t,e){return h2()(r,e)}function k4(r,e=0){const t=h2(),n=t.getState().internal.subscribe,i=i2(r);return Cm(()=>n(i,e,t),[e,n,t]),null}const Zh=new Map,{invalidate:Yb,advance:Zb}=L4(Zh),{reconciler:r0,applyProps:Rh}=x4(Zh,M4),Ih={objects:"shallow",strict:!1},D4=(r,e)=>{const t=typeof r=="function"?r(e):r;return c2(t)?t:new BS({powerPreference:"high-performance",canvas:e,antialias:!0,alpha:!0,...r})};function O4(r,e){const t=typeof HTMLCanvasElement<"u"&&r instanceof HTMLCanvasElement;if(e){const{width:n,height:i,top:s,left:a,updateStyle:o=t}=e;return{width:n,height:i,top:s,left:a,updateStyle:o}}else if(typeof HTMLCanvasElement<"u"&&r instanceof HTMLCanvasElement&&r.parentElement){const{width:n,height:i,top:s,left:a}=r.parentElement.getBoundingClientRect();return{width:n,height:i,top:s,left:a,updateStyle:t}}else if(typeof OffscreenCanvas<"u"&&r instanceof OffscreenCanvas)return{width:r.width,height:r.height,top:0,left:0,updateStyle:t};return{width:0,height:0,top:0,left:0}}function F4(r){const e=Zh.get(r),t=e==null?void 0:e.fiber,n=e==null?void 0:e.store;e&&console.warn("R3F.createRoot should only be called once!");const i=typeof reportError=="function"?reportError:console.error,s=n||C4(Yb,Zb),a=t||r0.createContainer(s,Bh.ConcurrentRoot,null,!1,null,"",i,null);e||Zh.set(r,{fiber:a,store:s});let o,u=!1,h;return{configure(p={}){let{gl:m,size:y,scene:v,events:S,onCreated:T,shadows:E=!1,linear:w=!1,flat:C=!1,legacy:A=!1,orthographic:I=!1,frameloop:F="always",dpr:U=[1,2],performance:V,raycaster:G,camera:L,onPointerMissed:k}=p,O=s.getState(),Q=O.gl;O.gl||O.set({gl:Q=D4(m,r)});let le=O.raycaster;le||O.set({raycaster:le=new QA});const{params:K,...ce}=G||{};if(Yn.equ(ce,le,Ih)||Rh(le,{...ce}),Yn.equ(K,le.params,Ih)||Rh(le,{params:{...le.params,...K}}),!O.camera||O.camera===h&&!Yn.equ(h,L,Ih)){h=L;const ee=L instanceof wm,z=ee?L:I?new fu(0,0,0,0,.1,1e3):new Er(75,0,.1,1e3);ee||(z.position.z=5,L&&(Rh(z,L),("aspect"in L||"left"in L||"right"in L||"bottom"in L||"top"in L)&&(z.manual=!0,z.updateProjectionMatrix())),!O.camera&&!(L!=null&&L.rotation)&&z.lookAt(0,0,0)),O.set({camera:z}),le.camera=z}if(!O.scene){let ee;v!=null&&v.isScene?ee=v:(ee=new VS,v&&Rh(ee,v)),O.set({scene:Ph(ee)})}if(!O.xr){var de;const ee=(ve,Ce)=>{const ke=s.getState();ke.frameloop!=="never"&&Zb(ve,!0,ke,Ce)},z=()=>{const ve=s.getState();ve.gl.xr.enabled=ve.gl.xr.isPresenting,ve.gl.xr.setAnimationLoop(ve.gl.xr.isPresenting?ee:null),ve.gl.xr.isPresenting||Yb(ve)},q={connect(){const ve=s.getState().gl;ve.xr.addEventListener("sessionstart",z),ve.xr.addEventListener("sessionend",z)},disconnect(){const ve=s.getState().gl;ve.xr.removeEventListener("sessionstart",z),ve.xr.removeEventListener("sessionend",z)}};typeof((de=Q.xr)==null?void 0:de.addEventListener)=="function"&&q.connect(),O.set({xr:q})}if(Q.shadowMap){const ee=Q.shadowMap.enabled,z=Q.shadowMap.type;if(Q.shadowMap.enabled=!!E,Yn.boo(E))Q.shadowMap.type=Cp;else if(Yn.str(E)){var me;const q={basic:GT,percentage:S0,soft:Cp,variance:Ea};Q.shadowMap.type=(me=q[E])!=null?me:Cp}else Yn.obj(E)&&Object.assign(Q.shadowMap,E);(ee!==Q.shadowMap.enabled||z!==Q.shadowMap.type)&&(Q.shadowMap.needsUpdate=!0)}const Z=n2();Z&&("enabled"in Z?Z.enabled=!A:"legacyMode"in Z&&(Z.legacyMode=A)),u||Rh(Q,{outputEncoding:w?3e3:3001,toneMapping:C?eo:wS}),O.legacy!==A&&O.set(()=>({legacy:A})),O.linear!==w&&O.set(()=>({linear:w})),O.flat!==C&&O.set(()=>({flat:C})),m&&!Yn.fun(m)&&!c2(m)&&!Yn.equ(m,Q,Ih)&&Rh(Q,m),S&&!O.events.handlers&&O.set({events:S(s)});const re=O4(r,y);return Yn.equ(re,O.size,Ih)||O.setSize(re.width,re.height,re.updateStyle,re.top,re.left),U&&O.viewport.dpr!==o2(U)&&O.setDpr(U),O.frameloop!==F&&O.setFrameloop(F),O.onPointerMissed||O.set({onPointerMissed:k}),V&&!Yn.equ(V,O.performance,Ih)&&O.set(ee=>({performance:{...ee.performance,...V}})),o=T,u=!0,this},render(p){return u||this.configure(),r0.updateContainer(lt.jsx(U4,{store:s,children:p,onCreated:o,rootElement:r}),a,null,()=>{}),s},unmount(){d2(r)}}}function U4({store:r,children:e,onCreated:t,rootElement:n}){return Cm(()=>{const i=r.getState();i.set(s=>({internal:{...s.internal,active:!0}})),t&&t(i),r.getState().events.connected||i.events.connect==null||i.events.connect(n)},[]),lt.jsx(f2.Provider,{value:r,children:e})}function d2(r,e){const t=Zh.get(r),n=t==null?void 0:t.fiber;if(n){const i=t==null?void 0:t.store.getState();i&&(i.internal.active=!1),r0.updateContainer(null,n,null,()=>{i&&setTimeout(()=>{try{var s,a,o,u;i.events.disconnect==null||i.events.disconnect(),(s=i.gl)==null||(a=s.renderLists)==null||a.dispose==null||a.dispose(),(o=i.gl)==null||o.forceContextLoss==null||o.forceContextLoss(),(u=i.gl)!=null&&u.xr&&i.xr.disconnect(),b4(i),Zh.delete(r)}catch{}},500)})}}r0.injectIntoDevTools({bundleType:0,rendererPackageName:"@react-three/fiber",version:gt.version});const V_={onClick:["click",!1],onContextMenu:["contextmenu",!1],onDoubleClick:["dblclick",!1],onWheel:["wheel",!0],onPointerDown:["pointerdown",!0],onPointerUp:["pointerup",!0],onPointerLeave:["pointerleave",!0],onPointerMove:["pointermove",!0],onPointerCancel:["pointercancel",!0],onLostPointerCapture:["lostpointercapture",!0]};function z4(r){const{handlePointer:e}=N4(r);return{priority:1,enabled:!0,compute(t,n,i){n.pointer.set(t.offsetX/n.size.width*2-1,-(t.offsetY/n.size.height)*2+1),n.raycaster.setFromCamera(n.pointer,n.camera)},connected:void 0,handlers:Object.keys(V_).reduce((t,n)=>({...t,[n]:e(n)}),{}),update:()=>{var t;const{events:n,internal:i}=r.getState();(t=i.lastEvent)!=null&&t.current&&n.handlers&&n.handlers.onPointerMove(i.lastEvent.current)},connect:t=>{var n;const{set:i,events:s}=r.getState();s.disconnect==null||s.disconnect(),i(a=>({events:{...a.events,connected:t}})),Object.entries((n=s.handlers)!=null?n:[]).forEach(([a,o])=>{const[u,h]=V_[a];t.addEventListener(u,o,{passive:h})})},disconnect:()=>{const{set:t,events:n}=r.getState();if(n.connected){var i;Object.entries((i=n.handlers)!=null?i:[]).forEach(([s,a])=>{if(n&&n.connected instanceof HTMLElement){const[o]=V_[s];n.connected.removeEventListener(o,a)}}),t(s=>({events:{...s.events,connected:void 0}}))}}}}function Jb(r,e){let t;return(...n)=>{window.clearTimeout(t),t=window.setTimeout(()=>r(...n),e)}}function B4({debounce:r,scroll:e,polyfill:t,offsetSize:n}={debounce:0,scroll:!1,offsetSize:!1}){const i=t||(typeof window>"u"?class{}:window.ResizeObserver);if(!i)throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");const[s,a]=gt.useState({left:0,top:0,width:0,height:0,bottom:0,right:0,x:0,y:0}),o=gt.useRef({element:null,scrollContainers:null,resizeObserver:null,lastBounds:s,orientationHandler:null}),u=r?typeof r=="number"?r:r.scroll:null,h=r?typeof r=="number"?r:r.resize:null,p=gt.useRef(!1);gt.useEffect(()=>(p.current=!0,()=>void(p.current=!1)));const[m,y,v]=gt.useMemo(()=>{const w=()=>{if(!o.current.element)return;const{left:C,top:A,width:I,height:F,bottom:U,right:V,x:G,y:L}=o.current.element.getBoundingClientRect(),k={left:C,top:A,width:I,height:F,bottom:U,right:V,x:G,y:L};o.current.element instanceof HTMLElement&&n&&(k.height=o.current.element.offsetHeight,k.width=o.current.element.offsetWidth),Object.freeze(k),p.current&&!G4(o.current.lastBounds,k)&&a(o.current.lastBounds=k)};return[w,h?Jb(w,h):w,u?Jb(w,u):w]},[a,n,u,h]);function S(){o.current.scrollContainers&&(o.current.scrollContainers.forEach(w=>w.removeEventListener("scroll",v,!0)),o.current.scrollContainers=null),o.current.resizeObserver&&(o.current.resizeObserver.disconnect(),o.current.resizeObserver=null),o.current.orientationHandler&&("orientation"in screen&&"removeEventListener"in screen.orientation?screen.orientation.removeEventListener("change",o.current.orientationHandler):"onorientationchange"in window&&window.removeEventListener("orientationchange",o.current.orientationHandler))}function T(){o.current.element&&(o.current.resizeObserver=new i(v),o.current.resizeObserver.observe(o.current.element),e&&o.current.scrollContainers&&o.current.scrollContainers.forEach(w=>w.addEventListener("scroll",v,{capture:!0,passive:!0})),o.current.orientationHandler=()=>{v()},"orientation"in screen&&"addEventListener"in screen.orientation?screen.orientation.addEventListener("change",o.current.orientationHandler):"onorientationchange"in window&&window.addEventListener("orientationchange",o.current.orientationHandler))}const E=w=>{!w||w===o.current.element||(S(),o.current.element=w,o.current.scrollContainers=p2(w),T())};return H4(v,!!e),V4(y),gt.useEffect(()=>{S(),T()},[e,v,y]),gt.useEffect(()=>S,[]),[E,s,m]}function V4(r){gt.useEffect(()=>{const e=r;return window.addEventListener("resize",e),()=>void window.removeEventListener("resize",e)},[r])}function H4(r,e){gt.useEffect(()=>{if(e){const t=r;return window.addEventListener("scroll",t,{capture:!0,passive:!0}),()=>void window.removeEventListener("scroll",t,!0)}},[r,e])}function p2(r){const e=[];if(!r||r===document.body)return e;const{overflow:t,overflowX:n,overflowY:i}=window.getComputedStyle(r);return[t,n,i].some(s=>s==="auto"||s==="scroll")&&e.push(r),[...e,...p2(r.parentElement)]}const $4=["x","y","top","bottom","left","right","width","height"],G4=(r,e)=>$4.every(t=>r[t]===e[t]);var W4=Object.defineProperty,j4=Object.defineProperties,q4=Object.getOwnPropertyDescriptors,Qb=Object.getOwnPropertySymbols,X4=Object.prototype.hasOwnProperty,K4=Object.prototype.propertyIsEnumerable,eT=(r,e,t)=>e in r?W4(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,tT=(r,e)=>{for(var t in e||(e={}))X4.call(e,t)&&eT(r,t,e[t]);if(Qb)for(var t of Qb(e))K4.call(e,t)&&eT(r,t,e[t]);return r},Y4=(r,e)=>j4(r,q4(e)),nT,rT;typeof window<"u"&&((nT=window.document)!=null&&nT.createElement||((rT=window.navigator)==null?void 0:rT.product)==="ReactNative")?gt.useLayoutEffect:gt.useEffect;function m2(r,e,t){if(!r)return;if(t(r)===!0)return r;let n=r.child;for(;n;){const i=m2(n,e,t);if(i)return i;n=n.sibling}}function g2(r){try{return Object.defineProperties(r,{_currentRenderer:{get(){return null},set(){}},_currentRenderer2:{get(){return null},set(){}}})}catch{return r}}const iT=console.error;console.error=function(){const r=[...arguments].join("");if(r!=null&&r.startsWith("Warning:")&&r.includes("useContext")){console.error=iT;return}return iT.apply(this,arguments)};const u1=g2(gt.createContext(null));class y2 extends gt.Component{render(){return gt.createElement(u1.Provider,{value:this._reactInternals},this.props.children)}}function Z4(){const r=gt.useContext(u1);if(r===null)throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");const e=gt.useId();return gt.useMemo(()=>{for(const n of[r,r==null?void 0:r.alternate]){if(!n)continue;const i=m2(n,!1,s=>{let a=s.memoizedState;for(;a;){if(a.memoizedState===e)return!0;a=a.next}});if(i)return i}},[r,e])}function J4(){const r=Z4(),[e]=gt.useState(()=>new Map);e.clear();let t=r;for(;t;){if(t.type&&typeof t.type=="object"){const i=t.type._context===void 0&&t.type.Provider===t.type?t.type:t.type._context;i&&i!==u1&&!e.has(i)&&e.set(i,gt.useContext(g2(i)))}t=t.return}return e}function Q4(){const r=J4();return gt.useMemo(()=>Array.from(r.keys()).reduce((e,t)=>n=>gt.createElement(e,null,gt.createElement(t.Provider,Y4(tT({},n),{value:r.get(t)}))),e=>gt.createElement(y2,tT({},e))),[r])}const eV=gt.forwardRef(function({children:e,fallback:t,resize:n,style:i,gl:s,events:a=z4,eventSource:o,eventPrefix:u,shadows:h,linear:p,flat:m,legacy:y,orthographic:v,frameloop:S,dpr:T,performance:E,raycaster:w,camera:C,scene:A,onPointerMissed:I,onCreated:F,...U},V){gt.useMemo(()=>_4(l4),[]);const G=Q4(),[L,k]=B4({scroll:!0,debounce:{scroll:50,resize:0},...n}),O=gt.useRef(null),Q=gt.useRef(null);gt.useImperativeHandle(V,()=>O.current);const le=i2(I),[K,ce]=gt.useState(!1),[de,me]=gt.useState(!1);if(K)throw K;if(de)throw de;const Z=gt.useRef(null);Cm(()=>{const ee=O.current;k.width>0&&k.height>0&&ee&&(Z.current||(Z.current=F4(ee)),Z.current.configure({gl:s,events:a,shadows:h,linear:p,flat:m,legacy:y,orthographic:v,frameloop:S,dpr:T,performance:E,raycaster:w,camera:C,scene:A,size:k,onPointerMissed:(...z)=>le.current==null?void 0:le.current(...z),onCreated:z=>{z.events.connect==null||z.events.connect(o?S4(o)?o.current:o:Q.current),u&&z.setEvents({compute:(q,ve)=>{const Ce=q[u+"X"],ke=q[u+"Y"];ve.pointer.set(Ce/ve.size.width*2-1,-(ke/ve.size.height)*2+1),ve.raycaster.setFromCamera(ve.pointer,ve.camera)}}),F==null||F(z)}}),Z.current.render(lt.jsx(G,{children:lt.jsx(s2,{set:me,children:lt.jsx(gt.Suspense,{fallback:lt.jsx(w4,{set:ce}),children:e??null})})})))}),gt.useEffect(()=>{const ee=O.current;if(ee)return()=>d2(ee)},[]);const re=o?"none":"auto";return lt.jsx("div",{ref:Q,style:{position:"relative",width:"100%",height:"100%",overflow:"hidden",pointerEvents:re,...i},...U,children:lt.jsx("div",{ref:L,style:{width:"100%",height:"100%"},children:lt.jsx("canvas",{ref:O,style:{display:"block"},children:t})})})}),tV=gt.forwardRef(function(e,t){return lt.jsx(y2,{children:lt.jsx(eV,{...e,ref:t})})});function $x(){return $x=Object.assign?Object.assign.bind():function(r){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var n in t)({}).hasOwnProperty.call(t,n)&&(r[n]=t[n])}return r},$x.apply(null,arguments)}var nV=Object.defineProperty,rV=(r,e,t)=>e in r?nV(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,iV=(r,e,t)=>(rV(r,e+"",t),t);class sV{constructor(){iV(this,"_listeners")}addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const n=this._listeners;n[e]===void 0&&(n[e]=[]),n[e].indexOf(t)===-1&&n[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;const n=this._listeners;return n[e]!==void 0&&n[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;const i=this._listeners[e];if(i!==void 0){const s=i.indexOf(t);s!==-1&&i.splice(s,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const n=this._listeners[e.type];if(n!==void 0){e.target=this;const i=n.slice(0);for(let s=0,a=i.length;s<a;s++)i[s].call(this,e);e.target=null}}}var aV=Object.defineProperty,oV=(r,e,t)=>e in r?aV(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,Ut=(r,e,t)=>(oV(r,typeof e!="symbol"?e+"":e,t),t);const Ny=new sf,sT=new Jo,lV=Math.cos(70*(Math.PI/180)),aT=(r,e)=>(r%e+e)%e;let uV=class extends sV{constructor(e,t){super(),Ut(this,"object"),Ut(this,"domElement"),Ut(this,"enabled",!0),Ut(this,"target",new X),Ut(this,"minDistance",0),Ut(this,"maxDistance",1/0),Ut(this,"minZoom",0),Ut(this,"maxZoom",1/0),Ut(this,"minPolarAngle",0),Ut(this,"maxPolarAngle",Math.PI),Ut(this,"minAzimuthAngle",-1/0),Ut(this,"maxAzimuthAngle",1/0),Ut(this,"enableDamping",!1),Ut(this,"dampingFactor",.05),Ut(this,"enableZoom",!0),Ut(this,"zoomSpeed",1),Ut(this,"enableRotate",!0),Ut(this,"rotateSpeed",1),Ut(this,"enablePan",!0),Ut(this,"panSpeed",1),Ut(this,"screenSpacePanning",!0),Ut(this,"keyPanSpeed",7),Ut(this,"zoomToCursor",!1),Ut(this,"autoRotate",!1),Ut(this,"autoRotateSpeed",2),Ut(this,"reverseOrbit",!1),Ut(this,"reverseHorizontalOrbit",!1),Ut(this,"reverseVerticalOrbit",!1),Ut(this,"keys",{LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"}),Ut(this,"mouseButtons",{LEFT:Mc.ROTATE,MIDDLE:Mc.DOLLY,RIGHT:Mc.PAN}),Ut(this,"touches",{ONE:Ac.ROTATE,TWO:Ac.DOLLY_PAN}),Ut(this,"target0"),Ut(this,"position0"),Ut(this,"zoom0"),Ut(this,"_domElementKeyEvents",null),Ut(this,"getPolarAngle"),Ut(this,"getAzimuthalAngle"),Ut(this,"setPolarAngle"),Ut(this,"setAzimuthalAngle"),Ut(this,"getDistance"),Ut(this,"getZoomScale"),Ut(this,"listenToKeyEvents"),Ut(this,"stopListenToKeyEvents"),Ut(this,"saveState"),Ut(this,"reset"),Ut(this,"update"),Ut(this,"connect"),Ut(this,"dispose"),Ut(this,"dollyIn"),Ut(this,"dollyOut"),Ut(this,"getScale"),Ut(this,"setScale"),this.object=e,this.domElement=t,this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=()=>p.phi,this.getAzimuthalAngle=()=>p.theta,this.setPolarAngle=ae=>{let Ne=aT(ae,2*Math.PI),ze=p.phi;ze<0&&(ze+=2*Math.PI),Ne<0&&(Ne+=2*Math.PI);let Fe=Math.abs(Ne-ze);2*Math.PI-Fe<Fe&&(Ne<ze?Ne+=2*Math.PI:ze+=2*Math.PI),m.phi=Ne-ze,n.update()},this.setAzimuthalAngle=ae=>{let Ne=aT(ae,2*Math.PI),ze=p.theta;ze<0&&(ze+=2*Math.PI),Ne<0&&(Ne+=2*Math.PI);let Fe=Math.abs(Ne-ze);2*Math.PI-Fe<Fe&&(Ne<ze?Ne+=2*Math.PI:ze+=2*Math.PI),m.theta=Ne-ze,n.update()},this.getDistance=()=>n.object.position.distanceTo(n.target),this.listenToKeyEvents=ae=>{ae.addEventListener("keydown",He),this._domElementKeyEvents=ae},this.stopListenToKeyEvents=()=>{this._domElementKeyEvents.removeEventListener("keydown",He),this._domElementKeyEvents=null},this.saveState=()=>{n.target0.copy(n.target),n.position0.copy(n.object.position),n.zoom0=n.object.zoom},this.reset=()=>{n.target.copy(n.target0),n.object.position.copy(n.position0),n.object.zoom=n.zoom0,n.object.updateProjectionMatrix(),n.dispatchEvent(i),n.update(),u=o.NONE},this.update=(()=>{const ae=new X,Ne=new X(0,1,0),ze=new Ni().setFromUnitVectors(e.up,Ne),Fe=ze.clone().invert(),Ct=new X,ue=new Ni,Qe=2*Math.PI;return function(){const Re=n.object.position;ze.setFromUnitVectors(e.up,Ne),Fe.copy(ze).invert(),ae.copy(Re).sub(n.target),ae.applyQuaternion(ze),p.setFromVector3(ae),n.autoRotate&&u===o.NONE&&K(Q()),n.enableDamping?(p.theta+=m.theta*n.dampingFactor,p.phi+=m.phi*n.dampingFactor):(p.theta+=m.theta,p.phi+=m.phi);let $e=n.minAzimuthAngle,Et=n.maxAzimuthAngle;isFinite($e)&&isFinite(Et)&&($e<-Math.PI?$e+=Qe:$e>Math.PI&&($e-=Qe),Et<-Math.PI?Et+=Qe:Et>Math.PI&&(Et-=Qe),$e<=Et?p.theta=Math.max($e,Math.min(Et,p.theta)):p.theta=p.theta>($e+Et)/2?Math.max($e,p.theta):Math.min(Et,p.theta)),p.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,p.phi)),p.makeSafe(),n.enableDamping===!0?n.target.addScaledVector(v,n.dampingFactor):n.target.add(v),n.zoomToCursor&&L||n.object.isOrthographicCamera?p.radius=ve(p.radius):p.radius=ve(p.radius*y),ae.setFromSpherical(p),ae.applyQuaternion(Fe),Re.copy(n.target).add(ae),n.object.matrixAutoUpdate||n.object.updateMatrix(),n.object.lookAt(n.target),n.enableDamping===!0?(m.theta*=1-n.dampingFactor,m.phi*=1-n.dampingFactor,v.multiplyScalar(1-n.dampingFactor)):(m.set(0,0,0),v.set(0,0,0));let Yt=!1;if(n.zoomToCursor&&L){let yn=null;if(n.object instanceof Er&&n.object.isPerspectiveCamera){const Zn=ae.length();yn=ve(Zn*y);const an=Zn-yn;n.object.position.addScaledVector(V,an),n.object.updateMatrixWorld()}else if(n.object.isOrthographicCamera){const Zn=new X(G.x,G.y,0);Zn.unproject(n.object),n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/y)),n.object.updateProjectionMatrix(),Yt=!0;const an=new X(G.x,G.y,0);an.unproject(n.object),n.object.position.sub(an).add(Zn),n.object.updateMatrixWorld(),yn=ae.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),n.zoomToCursor=!1;yn!==null&&(n.screenSpacePanning?n.target.set(0,0,-1).transformDirection(n.object.matrix).multiplyScalar(yn).add(n.object.position):(Ny.origin.copy(n.object.position),Ny.direction.set(0,0,-1).transformDirection(n.object.matrix),Math.abs(n.object.up.dot(Ny.direction))<lV?e.lookAt(n.target):(sT.setFromNormalAndCoplanarPoint(n.object.up,n.target),Ny.intersectPlane(sT,n.target))))}else n.object instanceof fu&&n.object.isOrthographicCamera&&(Yt=y!==1,Yt&&(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/y)),n.object.updateProjectionMatrix()));return y=1,L=!1,Yt||Ct.distanceToSquared(n.object.position)>h||8*(1-ue.dot(n.object.quaternion))>h?(n.dispatchEvent(i),Ct.copy(n.object.position),ue.copy(n.object.quaternion),Yt=!1,!0):!1}})(),this.connect=ae=>{n.domElement=ae,n.domElement.style.touchAction="none",n.domElement.addEventListener("contextmenu",rt),n.domElement.addEventListener("pointerdown",wn),n.domElement.addEventListener("pointercancel",$),n.domElement.addEventListener("wheel",Oe)},this.dispose=()=>{var ae,Ne,ze,Fe,Ct,ue;n.domElement&&(n.domElement.style.touchAction="auto"),(ae=n.domElement)==null||ae.removeEventListener("contextmenu",rt),(Ne=n.domElement)==null||Ne.removeEventListener("pointerdown",wn),(ze=n.domElement)==null||ze.removeEventListener("pointercancel",$),(Fe=n.domElement)==null||Fe.removeEventListener("wheel",Oe),(Ct=n.domElement)==null||Ct.ownerDocument.removeEventListener("pointermove",J),(ue=n.domElement)==null||ue.ownerDocument.removeEventListener("pointerup",$),n._domElementKeyEvents!==null&&n._domElementKeyEvents.removeEventListener("keydown",He)};const n=this,i={type:"change"},s={type:"start"},a={type:"end"},o={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let u=o.NONE;const h=1e-6,p=new Bx,m=new Bx;let y=1;const v=new X,S=new Pe,T=new Pe,E=new Pe,w=new Pe,C=new Pe,A=new Pe,I=new Pe,F=new Pe,U=new Pe,V=new X,G=new Pe;let L=!1;const k=[],O={};function Q(){return 2*Math.PI/60/60*n.autoRotateSpeed}function le(){return Math.pow(.95,n.zoomSpeed)}function K(ae){n.reverseOrbit||n.reverseHorizontalOrbit?m.theta+=ae:m.theta-=ae}function ce(ae){n.reverseOrbit||n.reverseVerticalOrbit?m.phi+=ae:m.phi-=ae}const de=(()=>{const ae=new X;return function(ze,Fe){ae.setFromMatrixColumn(Fe,0),ae.multiplyScalar(-ze),v.add(ae)}})(),me=(()=>{const ae=new X;return function(ze,Fe){n.screenSpacePanning===!0?ae.setFromMatrixColumn(Fe,1):(ae.setFromMatrixColumn(Fe,0),ae.crossVectors(n.object.up,ae)),ae.multiplyScalar(ze),v.add(ae)}})(),Z=(()=>{const ae=new X;return function(ze,Fe){const Ct=n.domElement;if(Ct&&n.object instanceof Er&&n.object.isPerspectiveCamera){const ue=n.object.position;ae.copy(ue).sub(n.target);let Qe=ae.length();Qe*=Math.tan(n.object.fov/2*Math.PI/180),de(2*ze*Qe/Ct.clientHeight,n.object.matrix),me(2*Fe*Qe/Ct.clientHeight,n.object.matrix)}else Ct&&n.object instanceof fu&&n.object.isOrthographicCamera?(de(ze*(n.object.right-n.object.left)/n.object.zoom/Ct.clientWidth,n.object.matrix),me(Fe*(n.object.top-n.object.bottom)/n.object.zoom/Ct.clientHeight,n.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),n.enablePan=!1)}})();function re(ae){n.object instanceof Er&&n.object.isPerspectiveCamera||n.object instanceof fu&&n.object.isOrthographicCamera?y=ae:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function ee(ae){re(y/ae)}function z(ae){re(y*ae)}function q(ae){if(!n.zoomToCursor||!n.domElement)return;L=!0;const Ne=n.domElement.getBoundingClientRect(),ze=ae.clientX-Ne.left,Fe=ae.clientY-Ne.top,Ct=Ne.width,ue=Ne.height;G.x=ze/Ct*2-1,G.y=-(Fe/ue)*2+1,V.set(G.x,G.y,1).unproject(n.object).sub(n.object.position).normalize()}function ve(ae){return Math.max(n.minDistance,Math.min(n.maxDistance,ae))}function Ce(ae){S.set(ae.clientX,ae.clientY)}function ke(ae){q(ae),I.set(ae.clientX,ae.clientY)}function We(ae){w.set(ae.clientX,ae.clientY)}function tt(ae){T.set(ae.clientX,ae.clientY),E.subVectors(T,S).multiplyScalar(n.rotateSpeed);const Ne=n.domElement;Ne&&(K(2*Math.PI*E.x/Ne.clientHeight),ce(2*Math.PI*E.y/Ne.clientHeight)),S.copy(T),n.update()}function nt(ae){F.set(ae.clientX,ae.clientY),U.subVectors(F,I),U.y>0?ee(le()):U.y<0&&z(le()),I.copy(F),n.update()}function ut(ae){C.set(ae.clientX,ae.clientY),A.subVectors(C,w).multiplyScalar(n.panSpeed),Z(A.x,A.y),w.copy(C),n.update()}function kt(ae){q(ae),ae.deltaY<0?z(le()):ae.deltaY>0&&ee(le()),n.update()}function vt(ae){let Ne=!1;switch(ae.code){case n.keys.UP:Z(0,n.keyPanSpeed),Ne=!0;break;case n.keys.BOTTOM:Z(0,-n.keyPanSpeed),Ne=!0;break;case n.keys.LEFT:Z(n.keyPanSpeed,0),Ne=!0;break;case n.keys.RIGHT:Z(-n.keyPanSpeed,0),Ne=!0;break}Ne&&(ae.preventDefault(),n.update())}function se(){if(k.length==1)S.set(k[0].pageX,k[0].pageY);else{const ae=.5*(k[0].pageX+k[1].pageX),Ne=.5*(k[0].pageY+k[1].pageY);S.set(ae,Ne)}}function Ve(){if(k.length==1)w.set(k[0].pageX,k[0].pageY);else{const ae=.5*(k[0].pageX+k[1].pageX),Ne=.5*(k[0].pageY+k[1].pageY);w.set(ae,Ne)}}function Ie(){const ae=k[0].pageX-k[1].pageX,Ne=k[0].pageY-k[1].pageY,ze=Math.sqrt(ae*ae+Ne*Ne);I.set(0,ze)}function je(){n.enableZoom&&Ie(),n.enablePan&&Ve()}function De(){n.enableZoom&&Ie(),n.enableRotate&&se()}function bt(ae){if(k.length==1)T.set(ae.pageX,ae.pageY);else{const ze=fn(ae),Fe=.5*(ae.pageX+ze.x),Ct=.5*(ae.pageY+ze.y);T.set(Fe,Ct)}E.subVectors(T,S).multiplyScalar(n.rotateSpeed);const Ne=n.domElement;Ne&&(K(2*Math.PI*E.x/Ne.clientHeight),ce(2*Math.PI*E.y/Ne.clientHeight)),S.copy(T)}function at(ae){if(k.length==1)C.set(ae.pageX,ae.pageY);else{const Ne=fn(ae),ze=.5*(ae.pageX+Ne.x),Fe=.5*(ae.pageY+Ne.y);C.set(ze,Fe)}A.subVectors(C,w).multiplyScalar(n.panSpeed),Z(A.x,A.y),w.copy(C)}function dt(ae){const Ne=fn(ae),ze=ae.pageX-Ne.x,Fe=ae.pageY-Ne.y,Ct=Math.sqrt(ze*ze+Fe*Fe);F.set(0,Ct),U.set(0,Math.pow(F.y/I.y,n.zoomSpeed)),ee(U.y),I.copy(F)}function Pt(ae){n.enableZoom&&dt(ae),n.enablePan&&at(ae)}function Gt(ae){n.enableZoom&&dt(ae),n.enableRotate&&bt(ae)}function wn(ae){var Ne,ze;n.enabled!==!1&&(k.length===0&&((Ne=n.domElement)==null||Ne.ownerDocument.addEventListener("pointermove",J),(ze=n.domElement)==null||ze.ownerDocument.addEventListener("pointerup",$)),zt(ae),ae.pointerType==="touch"?St(ae):Se(ae))}function J(ae){n.enabled!==!1&&(ae.pointerType==="touch"?Ke(ae):qe(ae))}function $(ae){var Ne,ze,Fe;un(ae),k.length===0&&((Ne=n.domElement)==null||Ne.releasePointerCapture(ae.pointerId),(ze=n.domElement)==null||ze.ownerDocument.removeEventListener("pointermove",J),(Fe=n.domElement)==null||Fe.ownerDocument.removeEventListener("pointerup",$)),n.dispatchEvent(a),u=o.NONE}function Se(ae){let Ne;switch(ae.button){case 0:Ne=n.mouseButtons.LEFT;break;case 1:Ne=n.mouseButtons.MIDDLE;break;case 2:Ne=n.mouseButtons.RIGHT;break;default:Ne=-1}switch(Ne){case Mc.DOLLY:if(n.enableZoom===!1)return;ke(ae),u=o.DOLLY;break;case Mc.ROTATE:if(ae.ctrlKey||ae.metaKey||ae.shiftKey){if(n.enablePan===!1)return;We(ae),u=o.PAN}else{if(n.enableRotate===!1)return;Ce(ae),u=o.ROTATE}break;case Mc.PAN:if(ae.ctrlKey||ae.metaKey||ae.shiftKey){if(n.enableRotate===!1)return;Ce(ae),u=o.ROTATE}else{if(n.enablePan===!1)return;We(ae),u=o.PAN}break;default:u=o.NONE}u!==o.NONE&&n.dispatchEvent(s)}function qe(ae){if(n.enabled!==!1)switch(u){case o.ROTATE:if(n.enableRotate===!1)return;tt(ae);break;case o.DOLLY:if(n.enableZoom===!1)return;nt(ae);break;case o.PAN:if(n.enablePan===!1)return;ut(ae);break}}function Oe(ae){n.enabled===!1||n.enableZoom===!1||u!==o.NONE&&u!==o.ROTATE||(ae.preventDefault(),n.dispatchEvent(s),kt(ae),n.dispatchEvent(a))}function He(ae){n.enabled===!1||n.enablePan===!1||vt(ae)}function St(ae){switch(Xe(ae),k.length){case 1:switch(n.touches.ONE){case Ac.ROTATE:if(n.enableRotate===!1)return;se(),u=o.TOUCH_ROTATE;break;case Ac.PAN:if(n.enablePan===!1)return;Ve(),u=o.TOUCH_PAN;break;default:u=o.NONE}break;case 2:switch(n.touches.TWO){case Ac.DOLLY_PAN:if(n.enableZoom===!1&&n.enablePan===!1)return;je(),u=o.TOUCH_DOLLY_PAN;break;case Ac.DOLLY_ROTATE:if(n.enableZoom===!1&&n.enableRotate===!1)return;De(),u=o.TOUCH_DOLLY_ROTATE;break;default:u=o.NONE}break;default:u=o.NONE}u!==o.NONE&&n.dispatchEvent(s)}function Ke(ae){switch(Xe(ae),u){case o.TOUCH_ROTATE:if(n.enableRotate===!1)return;bt(ae),n.update();break;case o.TOUCH_PAN:if(n.enablePan===!1)return;at(ae),n.update();break;case o.TOUCH_DOLLY_PAN:if(n.enableZoom===!1&&n.enablePan===!1)return;Pt(ae),n.update();break;case o.TOUCH_DOLLY_ROTATE:if(n.enableZoom===!1&&n.enableRotate===!1)return;Gt(ae),n.update();break;default:u=o.NONE}}function rt(ae){n.enabled!==!1&&ae.preventDefault()}function zt(ae){k.push(ae)}function un(ae){delete O[ae.pointerId];for(let Ne=0;Ne<k.length;Ne++)if(k[Ne].pointerId==ae.pointerId){k.splice(Ne,1);return}}function Xe(ae){let Ne=O[ae.pointerId];Ne===void 0&&(Ne=new Pe,O[ae.pointerId]=Ne),Ne.set(ae.pageX,ae.pageY)}function fn(ae){const Ne=ae.pointerId===k[0].pointerId?k[1]:k[0];return O[Ne.pointerId]}this.dollyIn=(ae=le())=>{z(ae),n.update()},this.dollyOut=(ae=le())=>{ee(ae),n.update()},this.getScale=()=>y,this.setScale=ae=>{re(ae),n.update()},this.getZoomScale=()=>le(),t!==void 0&&this.connect(t),this.update()}};const cV=gt.forwardRef(({makeDefault:r,camera:e,regress:t,domElement:n,enableDamping:i=!0,keyEvents:s=!1,onChange:a,onStart:o,onEnd:u,...h},p)=>{const m=Zo(U=>U.invalidate),y=Zo(U=>U.camera),v=Zo(U=>U.gl),S=Zo(U=>U.events),T=Zo(U=>U.setEvents),E=Zo(U=>U.set),w=Zo(U=>U.get),C=Zo(U=>U.performance),A=e||y,I=n||S.connected||v.domElement,F=gt.useMemo(()=>new uV(A),[A]);return k4(()=>{F.enabled&&F.update()},-1),gt.useEffect(()=>(s&&F.connect(s===!0?I:s),F.connect(I),()=>void F.dispose()),[s,I,t,F,m]),gt.useEffect(()=>{const U=L=>{m(),t&&C.regress(),a&&a(L)},V=L=>{o&&o(L)},G=L=>{u&&u(L)};return F.addEventListener("change",U),F.addEventListener("start",V),F.addEventListener("end",G),()=>{F.removeEventListener("start",V),F.removeEventListener("end",G),F.removeEventListener("change",U)}},[a,o,u,F,m,T]),gt.useEffect(()=>{if(r){const U=w().controls;return E({controls:F}),()=>E({controls:U})}},[r,F]),gt.createElement("primitive",$x({ref:p,object:F,enableDamping:i},h))}),fV=({items:r,onAddItem:e})=>{const[t,n]=gt.useState({name:"",category:"",quantity:1,location:""}),i=s=>{s.preventDefault(),t.name&&(e({...t,id:Date.now()}),n({name:"",category:"",quantity:1,location:""}))};return lt.jsxs("div",{className:"item-inventory",children:[lt.jsx("h2",{children:"Item Inventory"}),lt.jsxs("form",{onSubmit:i,className:"add-item-form",children:[lt.jsx("input",{type:"text",placeholder:"Item name",value:t.name,onChange:s=>n({...t,name:s.target.value})}),lt.jsx("input",{type:"text",placeholder:"Category",value:t.category,onChange:s=>n({...t,category:s.target.value})}),lt.jsx("input",{type:"number",placeholder:"Quantity",value:t.quantity,onChange:s=>n({...t,quantity:parseInt(s.target.value)})}),lt.jsx("input",{type:"text",placeholder:"Location",value:t.location,onChange:s=>n({...t,location:s.target.value})}),lt.jsx("button",{type:"submit",children:"Add Item"})]}),lt.jsx("div",{className:"inventory-list",children:r.map(s=>lt.jsxs("div",{className:"inventory-item",children:[lt.jsx("h3",{children:s.name}),lt.jsxs("p",{children:["Category: ",s.category]}),lt.jsxs("p",{children:["Quantity: ",s.quantity]}),lt.jsxs("p",{children:["Location: ",s.location]})]},s.id))})]})};var Mp={exports:{}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hV=1e-7,dV=1e-4;class pV{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class v2{refCount(e){return as("refCount")}incRef(e){return as("incRef")}timerAvailable(){return!0}time(e){return as("time")}read(e){return as("read")}readSync(e){return as("readSync")}readToGPU(e,t){return as("readToGPU")}numDataIds(){return as("numDataIds")}disposeData(e,t){return as("disposeData")}write(e,t,n){return as("write")}move(e,t,n,i,s){return as("move")}createTensorFromGPUData(e,t,n){return as("createTensorFromGPUData")}memory(){return as("memory")}floatPrecision(){return as("floatPrecision")}epsilon(){return this.floatPrecision()===32?hV:dV}dispose(){return as("dispose")}}function as(r){throw new Error(`'${r}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _2(r){let e=r.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,i0(r,e,t)}function mV(r,e){if(r.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${r.length}Second array length was ${e.length}`);let t=r.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,i0(r,t,n),i0(e,t,n)}function sm(r,e,t){return Math.max(r,Math.min(e,t))}function gV(r){return r%2===0?r:r+1}function i0(r,e,t){const n=r[e];r[e]=r[t],r[t]=n}function yV(r){let e=0;for(let t=0;t<r.length;t++)e+=r[t];return e}function vV(r,e){const t=Math.random();return e*t+(1-t)*r}function _V(r,e){let t=0;for(let n=0;n<r.length;n++){const i=Number(r[n])-Number(e[n]);t+=i*i}return t}function j(r,e){if(!r)throw new Error(typeof e=="string"?e:e())}function Ii(r,e,t=""){j(Ra(r,e),()=>t+` Shapes ${r} and ${e} must match`)}function uf(r){j(r!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Rn(r){if(r.length===0)return 1;let e=r[0];for(let t=1;t<r.length;t++)e*=r[t];return e}function xV(r){return r.length===0}function x2(r,e){if(r===e)return!0;if(r==null||e==null||r.length!==e.length)return!1;for(let t=0;t<r.length;t++)if(r[t]!==null&&e[t]!==null&&r[t]!==e[t])return!1;return!0}function Ra(r,e){if(r===e)return!0;if(r==null||e==null||r.length!==e.length)return!1;for(let t=0;t<r.length;t++)if(r[t]!==e[t])return!1;return!0}function Jh(r){return r%1===0}function SV(r){if(Math.tanh!=null)return Math.tanh(r);if(r===1/0)return 1;if(r===-1/0)return-1;{const e=Math.exp(2*r);return(e-1)/(e+1)}}function wV(r){const e=Math.ceil(Math.sqrt(r));return[e,Math.ceil(r/e)]}function EV(r){const e=new Uint32Array(r);for(let t=0;t<r;++t)e[t]=t;return _2(e),e}function Dp(r,e){return e<=r.length?r:r+" ".repeat(e-r.length)}function bV(r,e=i=>0,t,n){return new Promise((i,s)=>{let a=0;const o=()=>{if(r()){i();return}a++;const u=e(a);if(t!=null&&a>=t){s();return}n!=null?n(o,u):setTimeout(o,u)};o()})}function TV(r,e){let t=1,n=-1;for(let s=0;s<r.length;++s)if(r[s]>=0)t*=r[s];else if(r[s]===-1){if(n!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${n} and dim ${s}`);n=s}else if(r[s]<0)throw Error(`Shapes can not be < 0. Found ${r[s]} at dim ${s}`);if(n===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${r}`);return r}if(t===0)throw Error(`Cannot infer the missing size in [${r}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const i=r.slice();return i[n]=e/t,i}function Rm(r,e){const t=e.length;return r=r==null?e.map((n,i)=>i):[].concat(r),j(r.every(n=>n>=-t&&n<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${r}`),j(r.every(n=>Jh(n)),()=>`All values in axis param must be integers but got axis ${r}`),r.map(n=>n<0?t+n:n)}function S2(r,e){const t=[],n=[],i=e!=null&&Array.isArray(e)&&e.length===0,s=e==null||i?null:Rm(e,r).sort();let a=0;for(let o=0;o<r.length;++o){if(s!=null){if(s[a]===o&&r[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${r[o]}' is not 1`);(s[a]==null||s[a]>o)&&r[o]===1&&(t.push(r[o]),n.push(o)),s[a]<=o&&a++}r[o]!==1&&(t.push(r[o]),n.push(o))}return{newShape:t,keptDims:n}}function w2(r,e){return c1(r,e)}function c1(r,e){let t=null;if(r==null||r==="float32")t=new Float32Array(e);else if(r==="int32")t=new Int32Array(e);else if(r==="bool")t=new Uint8Array(e);else if(r==="string")t=new Array(e);else throw new Error(`Unknown data type ${r}`);return t}function E2(r,e){for(let t=0;t<r.length;t++){const n=r[t];if(isNaN(n)||!isFinite(n))throw Error(`A tensor of type ${e} being uploaded contains ${n}.`)}}function b2(r){return r==="bool"||r==="complex64"||r==="float32"||r==="int32"||r==="string"}function MV(r,e){return!(e==="complex64"||e==="float32"&&r!=="complex64"||e==="int32"&&r!=="float32"&&r!=="complex64"||e==="bool"&&r==="bool")}function s0(r){if(r==="float32"||r==="int32")return 4;if(r==="complex64")return 8;if(r==="bool")return 1;throw new Error(`Unknown dtype ${r}`)}function T2(r){if(r==null)return 0;let e=0;return r.forEach(t=>e+=t.length),e}function su(r){return typeof r=="string"||r instanceof String}function M2(r){return typeof r=="boolean"}function A2(r){return typeof r=="number"}function Im(r){return Array.isArray(r)?Im(r[0]):r instanceof Float32Array?"float32":r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray?"int32":A2(r)?"float32":su(r)?"string":M2(r)?"bool":"float32"}function gu(r){return!!(r&&r.constructor&&r.call&&r.apply)}function a0(r,e){for(let t=e;t<r;++t)if(r%t===0)return t;return r}function cd(r){const e=r.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=r[e-1];for(let n=e-3;n>=0;--n)t[n]=t[n+1]*r[n+1];return t}function N2(r,e,t,n=!1){const i=new Array;if(e.length===1){const s=e[0]*(n?2:1);for(let a=0;a<s;a++)i[a]=t[r+a]}else{const s=e[0],a=e.slice(1),o=a.reduce((u,h)=>u*h)*(n?2:1);for(let u=0;u<s;u++)i[u]=N2(r+u*o,a,t,n)}return i}function Gc(r,e,t=!1){if(r.length===0)return e[0];const n=r.reduce((i,s)=>i*s)*(t?2:1);if(n===0)return[];if(n!==e.length)throw new Error(`[${r}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return N2(0,r,e,t)}function AV(r,e){if(Array.isArray(r))return r;if(e==="float32")return r instanceof Float32Array?r:new Float32Array(r);if(e==="int32")return r instanceof Int32Array?r:new Int32Array(r);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(r));throw new Error(`Unknown dtype ${e}`)}function f1(r,e){const t=K0(r,e);for(let n=0;n<t.length;n++)t[n]=1;return t}function K0(r,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(r);if(e==="int32")return new Int32Array(r);if(e==="bool")return new Uint8Array(r);throw new Error(`Unknown data type ${e}`)}function NV(r,e){const t=r.reduce((n,i)=>n*i,1);if(e==null||e==="float32")return Gc(r,new Float32Array(t));if(e==="int32")return Gc(r,new Int32Array(t));if(e==="bool")return Gc(r,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function gs(r){r.forEach(e=>{j(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${r}].`)})}function CV(r,e,t){if(e===0)return 0;if(e===1)return r[0];let n=r[r.length-1];for(let i=0;i<r.length-1;++i)n+=t[i]*r[i];return n}function RV(r,e,t){if(e===0)return[];if(e===1)return[r];const n=new Array(e);for(let i=0;i<n.length-1;++i)n[i]=Math.floor(r/t[i]),r-=n[i]*t[i];return n[n.length-1]=r,n}function yu(r){return r&&r.then&&typeof r.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oT="tfjsflags";class C2{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=IV,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(Ht().getBool("IS_TEST")||Ht().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},this.urlFlags[e]!=null){const i=this.urlFlags[e];Ht().getBool("IS_TEST")||Ht().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${i}.`),this.set(e,i)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(yu(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);oT in e&&e[oT].split(",").forEach(n=>{const[i,s]=n.split(":");this.urlFlags[i]=LV(i,s)})}}function IV(r){const e={};return r.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...n)=>(PV(e,n[0],n[1]),n.join("="))),e}function PV(r,e,t){r[decodeURIComponent(e)]=decodeURIComponent(t||"")}function LV(r,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function Ht(){return h1}let h1=null;function kV(r){h1=r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let H_;function R2(){if(H_==null){let r;if(typeof window<"u")r=window;else if(typeof global<"u")r=global;else if(typeof process<"u")r=process;else if(typeof self<"u")r=self;else throw new Error("Could not find a global object");H_=r}return H_}function DV(){const r=R2();return r._tfGlobals==null&&(r._tfGlobals=new Map),r._tfGlobals}function d1(r,e){const t=DV();if(t.has(r))return t.get(r);{const n=e();return t.set(r,n),t.get(r)}}const I2="Abs",P2="Acos",L2="Acosh",p1="Add",k2="AddN",D2="All",O2="Any",F2="ArgMax",U2="ArgMin",z2="Asin",B2="Asinh",V2="Atan",H2="Atanh",$2="Atan2",G2="AvgPool",OV="AvgPoolGrad",W2="AvgPool3D",FV="AvgPool3DGrad",j2="BatchMatMul",q2="BatchToSpaceND",X2="Bincount",K2="BitwiseAnd",UV="BroadcastTo",Y2="BroadcastArgs",m1="Cast",Z2="Ceil",J2="ClipByValue",Q2="Complex",eN="ComplexAbs",tN="Concat",nN="Conv2D",rN="Conv2DBackpropFilter",iN="Conv2DBackpropInput",sN="Conv3D",zV="Conv3DBackpropFilterV2",aN="Conv3DBackpropInputV2",oN="Cos",lN="Cosh",uN="Cumprod",cN="Cumsum",fN="CropAndResize",hN="DenseBincount",dN="DepthToSpace",pN="DepthwiseConv2dNative",mN="DepthwiseConv2dNativeBackpropFilter",gN="DepthwiseConv2dNativeBackpropInput",yN="Diag",vN="Dilation2D",BV="Dilation2DBackpropInput",VV="Dilation2DBackpropFilter",g1="Draw",_N="RealDiv",xN="Einsum",SN="Elu",HV="EluGrad",wN="Erf",EN="Equal",bN="Exp",TN="ExpandDims",MN="Expm1",AN="FFT",NN="Fill",CN="FlipLeftRight",RN="Floor",IN="FloorDiv",PN="FusedBatchNorm",LN="GatherV2",kN="GatherNd",DN="Greater",ON="GreaterEqual",y1="Identity",FN="IFFT",UN="Imag",zN="IsFinite",BN="IsInf",VN="IsNan",HN="LeakyRelu",$N="Less",GN="LessEqual",WN="LinSpace",jN="Log",qN="Log1p",XN="LogicalAnd",KN="LogicalNot",YN="LogicalOr",$V="LogicalXor",GV="LogSoftmax",WV="LowerBound",ZN="LRN",jV="LRNGrad",qV="MatrixBandPart",JN="Max",QN="Maximum",eC="MaxPool",XV="MaxPoolGrad",tC="MaxPool3D",KV="MaxPool3DGrad",nC="MaxPoolWithArgmax",rC="Mean",iC="Min",sC="Minimum",aC="MirrorPad",oC="Mod",lC="Multinomial",uC="Multiply",cC="Neg",fC="NotEqual",hC="NonMaxSuppressionV3",dC="NonMaxSuppressionV4",pC="NonMaxSuppressionV5",mC="OnesLike",gC="OneHot",yC="Pack",vC="PadV2",YV="Pool",_C="Pow",xC="Prelu",SC="Prod",wC="RaggedGather",EC="RaggedRange",bC="RaggedTensorToTensor",TC="Range",MC="Real",AC="Reciprocal",NC="Relu",CC="Reshape",RC="ResizeNearestNeighbor",ZV="ResizeNearestNeighborGrad",IC="ResizeBilinear",JV="ResizeBilinearGrad",PC="Relu6",LC="Reverse",kC="Round",DC="Rsqrt",OC="ScatterNd",FC="TensorScatterUpdate",UC="SearchSorted",zC="Select",BC="Selu",VC="Slice",HC="Sin",$C="Sinh",GC="Sign",WC="Sigmoid",jC="Softplus",qC="Sqrt",XC="Sum",KC="SpaceToBatchND",YC="SplitV",ZC="Softmax",JC="SparseFillEmptyRows",QC="SparseReshape",eR="SparseSegmentMean",tR="SparseSegmentSum",nR="SparseToDense",rR="SquaredDifference",QV="Square",iR="StaticRegexReplace",sR="StridedSlice",aR="StringNGrams",oR="StringSplit",lR="StringToHashBucketFast",uR="Sub",cR="Tan",fR="Tanh",v1="Tile",hR="TopK",dR="Transform",By="Transpose",pR="Unique",mR="Unpack",gR="UnsortedSegmentSum",eH="UpperBound",yR="ZerosLike",vR="Step",Gx="FromPixels",_R="RotateWithOffset",Wx="_FusedMatMul",jx="FusedConv2D",qx="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ru(...r){Ht().getBool("IS_TEST")||Ht().getBool("PROD")||console.warn(...r)}function tH(...r){Ht().getBool("IS_TEST")||Ht().getBool("PROD")||console.log(...r)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qh=d1("kernelRegistry",()=>new Map),am=d1("gradRegistry",()=>new Map);function om(r,e){const t=_1(r,e);return Qh.get(t)}function Xx(r){return am.get(r)}function o0(r){const e=Qh.entries(),t=[];for(;;){const{done:n,value:i}=e.next();if(n)break;const[s,a]=i,[o]=s.split("_");o===r&&t.push(a)}return t}function xR(r){const{kernelName:e,backendName:t}=r,n=_1(e,t);Qh.has(n)&&ru(`The kernel '${e}' for backend '${t}' is already registered`),Qh.set(n,r)}function nH(r){const{kernelName:e}=r;am.has(e)&&Ht().getBool("DEBUG")&&ru(`Overriding the gradient for '${e}'`),am.set(e,r)}function rH(r,e){const t=_1(r,e);if(!Qh.has(t))throw new Error(`The kernel '${r}' for backend '${e}' is not registered`);Qh.delete(t)}function iH(r){if(!am.has(r))throw new Error(`The gradient '${r}' for backend is not registered`);am.delete(r)}function sH(r,e){o0(r).forEach(n=>{const i=Object.assign({},n,{backendName:e});xR(i)})}function _1(r,e){return`${e}_${r}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SR(r){return r instanceof Float32Array||r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray}var $_,lT;function aH(){if(lT)return $_;lT=1,$_=e;var r=null;try{r=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function e(k,O,Q){this.low=k|0,this.high=O|0,this.unsigned=!!Q}e.prototype.__isLong__,Object.defineProperty(e.prototype,"__isLong__",{value:!0});function t(k){return(k&&k.__isLong__)===!0}e.isLong=t;var n={},i={};function s(k,O){var Q,le,K;return O?(k>>>=0,(K=0<=k&&k<256)&&(le=i[k],le)?le:(Q=o(k,(k|0)<0?-1:0,!0),K&&(i[k]=Q),Q)):(k|=0,(K=-128<=k&&k<128)&&(le=n[k],le)?le:(Q=o(k,k<0?-1:0,!1),K&&(n[k]=Q),Q))}e.fromInt=s;function a(k,O){if(isNaN(k))return O?C:w;if(O){if(k<0)return C;if(k>=S)return V}else{if(k<=-9223372036854776e3)return G;if(k+1>=T)return U}return k<0?a(-k,O).neg():o(k%v|0,k/v|0,O)}e.fromNumber=a;function o(k,O,Q){return new e(k,O,Q)}e.fromBits=o;var u=Math.pow;function h(k,O,Q){if(k.length===0)throw Error("empty string");if(k==="NaN"||k==="Infinity"||k==="+Infinity"||k==="-Infinity")return w;if(typeof O=="number"?(Q=O,O=!1):O=!!O,Q=Q||10,Q<2||36<Q)throw RangeError("radix");var le;if((le=k.indexOf("-"))>0)throw Error("interior hyphen");if(le===0)return h(k.substring(1),O,Q).neg();for(var K=a(u(Q,8)),ce=w,de=0;de<k.length;de+=8){var me=Math.min(8,k.length-de),Z=parseInt(k.substring(de,de+me),Q);if(me<8){var re=a(u(Q,me));ce=ce.mul(re).add(a(Z))}else ce=ce.mul(K),ce=ce.add(a(Z))}return ce.unsigned=O,ce}e.fromString=h;function p(k,O){return typeof k=="number"?a(k,O):typeof k=="string"?h(k,O):o(k.low,k.high,typeof O=="boolean"?O:k.unsigned)}e.fromValue=p;var m=65536,y=1<<24,v=m*m,S=v*v,T=S/2,E=s(y),w=s(0);e.ZERO=w;var C=s(0,!0);e.UZERO=C;var A=s(1);e.ONE=A;var I=s(1,!0);e.UONE=I;var F=s(-1);e.NEG_ONE=F;var U=o(-1,2147483647,!1);e.MAX_VALUE=U;var V=o(-1,-1,!0);e.MAX_UNSIGNED_VALUE=V;var G=o(0,-2147483648,!1);e.MIN_VALUE=G;var L=e.prototype;return L.toInt=function(){return this.unsigned?this.low>>>0:this.low},L.toNumber=function(){return this.unsigned?(this.high>>>0)*v+(this.low>>>0):this.high*v+(this.low>>>0)},L.toString=function(O){if(O=O||10,O<2||36<O)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(G)){var Q=a(O),le=this.div(Q),K=le.mul(Q).sub(this);return le.toString(O)+K.toInt().toString(O)}else return"-"+this.neg().toString(O);for(var ce=a(u(O,6),this.unsigned),de=this,me="";;){var Z=de.div(ce),re=de.sub(Z.mul(ce)).toInt()>>>0,ee=re.toString(O);if(de=Z,de.isZero())return ee+me;for(;ee.length<6;)ee="0"+ee;me=""+ee+me}},L.getHighBits=function(){return this.high},L.getHighBitsUnsigned=function(){return this.high>>>0},L.getLowBits=function(){return this.low},L.getLowBitsUnsigned=function(){return this.low>>>0},L.getNumBitsAbs=function(){if(this.isNegative())return this.eq(G)?64:this.neg().getNumBitsAbs();for(var O=this.high!=0?this.high:this.low,Q=31;Q>0&&(O&1<<Q)==0;Q--);return this.high!=0?Q+33:Q+1},L.isZero=function(){return this.high===0&&this.low===0},L.eqz=L.isZero,L.isNegative=function(){return!this.unsigned&&this.high<0},L.isPositive=function(){return this.unsigned||this.high>=0},L.isOdd=function(){return(this.low&1)===1},L.isEven=function(){return(this.low&1)===0},L.equals=function(O){return t(O)||(O=p(O)),this.unsigned!==O.unsigned&&this.high>>>31===1&&O.high>>>31===1?!1:this.high===O.high&&this.low===O.low},L.eq=L.equals,L.notEquals=function(O){return!this.eq(O)},L.neq=L.notEquals,L.ne=L.notEquals,L.lessThan=function(O){return this.comp(O)<0},L.lt=L.lessThan,L.lessThanOrEqual=function(O){return this.comp(O)<=0},L.lte=L.lessThanOrEqual,L.le=L.lessThanOrEqual,L.greaterThan=function(O){return this.comp(O)>0},L.gt=L.greaterThan,L.greaterThanOrEqual=function(O){return this.comp(O)>=0},L.gte=L.greaterThanOrEqual,L.ge=L.greaterThanOrEqual,L.compare=function(O){if(t(O)||(O=p(O)),this.eq(O))return 0;var Q=this.isNegative(),le=O.isNegative();return Q&&!le?-1:!Q&&le?1:this.unsigned?O.high>>>0>this.high>>>0||O.high===this.high&&O.low>>>0>this.low>>>0?-1:1:this.sub(O).isNegative()?-1:1},L.comp=L.compare,L.negate=function(){return!this.unsigned&&this.eq(G)?G:this.not().add(A)},L.neg=L.negate,L.add=function(O){t(O)||(O=p(O));var Q=this.high>>>16,le=this.high&65535,K=this.low>>>16,ce=this.low&65535,de=O.high>>>16,me=O.high&65535,Z=O.low>>>16,re=O.low&65535,ee=0,z=0,q=0,ve=0;return ve+=ce+re,q+=ve>>>16,ve&=65535,q+=K+Z,z+=q>>>16,q&=65535,z+=le+me,ee+=z>>>16,z&=65535,ee+=Q+de,ee&=65535,o(q<<16|ve,ee<<16|z,this.unsigned)},L.subtract=function(O){return t(O)||(O=p(O)),this.add(O.neg())},L.sub=L.subtract,L.multiply=function(O){if(this.isZero())return w;if(t(O)||(O=p(O)),r){var Q=r.mul(this.low,this.high,O.low,O.high);return o(Q,r.get_high(),this.unsigned)}if(O.isZero())return w;if(this.eq(G))return O.isOdd()?G:w;if(O.eq(G))return this.isOdd()?G:w;if(this.isNegative())return O.isNegative()?this.neg().mul(O.neg()):this.neg().mul(O).neg();if(O.isNegative())return this.mul(O.neg()).neg();if(this.lt(E)&&O.lt(E))return a(this.toNumber()*O.toNumber(),this.unsigned);var le=this.high>>>16,K=this.high&65535,ce=this.low>>>16,de=this.low&65535,me=O.high>>>16,Z=O.high&65535,re=O.low>>>16,ee=O.low&65535,z=0,q=0,ve=0,Ce=0;return Ce+=de*ee,ve+=Ce>>>16,Ce&=65535,ve+=ce*ee,q+=ve>>>16,ve&=65535,ve+=de*re,q+=ve>>>16,ve&=65535,q+=K*ee,z+=q>>>16,q&=65535,q+=ce*re,z+=q>>>16,q&=65535,q+=de*Z,z+=q>>>16,q&=65535,z+=le*ee+K*re+ce*Z+de*me,z&=65535,o(ve<<16|Ce,z<<16|q,this.unsigned)},L.mul=L.multiply,L.divide=function(O){if(t(O)||(O=p(O)),O.isZero())throw Error("division by zero");if(r){if(!this.unsigned&&this.high===-2147483648&&O.low===-1&&O.high===-1)return this;var Q=(this.unsigned?r.div_u:r.div_s)(this.low,this.high,O.low,O.high);return o(Q,r.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?C:w;var le,K,ce;if(this.unsigned){if(O.unsigned||(O=O.toUnsigned()),O.gt(this))return C;if(O.gt(this.shru(1)))return I;ce=C}else{if(this.eq(G)){if(O.eq(A)||O.eq(F))return G;if(O.eq(G))return A;var de=this.shr(1);return le=de.div(O).shl(1),le.eq(w)?O.isNegative()?A:F:(K=this.sub(O.mul(le)),ce=le.add(K.div(O)),ce)}else if(O.eq(G))return this.unsigned?C:w;if(this.isNegative())return O.isNegative()?this.neg().div(O.neg()):this.neg().div(O).neg();if(O.isNegative())return this.div(O.neg()).neg();ce=w}for(K=this;K.gte(O);){le=Math.max(1,Math.floor(K.toNumber()/O.toNumber()));for(var me=Math.ceil(Math.log(le)/Math.LN2),Z=me<=48?1:u(2,me-48),re=a(le),ee=re.mul(O);ee.isNegative()||ee.gt(K);)le-=Z,re=a(le,this.unsigned),ee=re.mul(O);re.isZero()&&(re=A),ce=ce.add(re),K=K.sub(ee)}return ce},L.div=L.divide,L.modulo=function(O){if(t(O)||(O=p(O)),r){var Q=(this.unsigned?r.rem_u:r.rem_s)(this.low,this.high,O.low,O.high);return o(Q,r.get_high(),this.unsigned)}return this.sub(this.div(O).mul(O))},L.mod=L.modulo,L.rem=L.modulo,L.not=function(){return o(~this.low,~this.high,this.unsigned)},L.and=function(O){return t(O)||(O=p(O)),o(this.low&O.low,this.high&O.high,this.unsigned)},L.or=function(O){return t(O)||(O=p(O)),o(this.low|O.low,this.high|O.high,this.unsigned)},L.xor=function(O){return t(O)||(O=p(O)),o(this.low^O.low,this.high^O.high,this.unsigned)},L.shiftLeft=function(O){return t(O)&&(O=O.toInt()),(O&=63)===0?this:O<32?o(this.low<<O,this.high<<O|this.low>>>32-O,this.unsigned):o(0,this.low<<O-32,this.unsigned)},L.shl=L.shiftLeft,L.shiftRight=function(O){return t(O)&&(O=O.toInt()),(O&=63)===0?this:O<32?o(this.low>>>O|this.high<<32-O,this.high>>O,this.unsigned):o(this.high>>O-32,this.high>=0?0:-1,this.unsigned)},L.shr=L.shiftRight,L.shiftRightUnsigned=function(O){if(t(O)&&(O=O.toInt()),O&=63,O===0)return this;var Q=this.high;if(O<32){var le=this.low;return o(le>>>O|Q<<32-O,Q>>>O,this.unsigned)}else return O===32?o(Q,0,this.unsigned):o(Q>>>O-32,0,this.unsigned)},L.shru=L.shiftRightUnsigned,L.shr_u=L.shiftRightUnsigned,L.toSigned=function(){return this.unsigned?o(this.low,this.high,!1):this},L.toUnsigned=function(){return this.unsigned?this:o(this.low,this.high,!0)},L.toBytes=function(O){return O?this.toBytesLE():this.toBytesBE()},L.toBytesLE=function(){var O=this.high,Q=this.low;return[Q&255,Q>>>8&255,Q>>>16&255,Q>>>24,O&255,O>>>8&255,O>>>16&255,O>>>24]},L.toBytesBE=function(){var O=this.high,Q=this.low;return[O>>>24,O>>>16&255,O>>>8&255,O&255,Q>>>24,Q>>>16&255,Q>>>8&255,Q&255]},e.fromBytes=function(O,Q,le){return le?e.fromBytesLE(O,Q):e.fromBytesBE(O,Q)},e.fromBytesLE=function(O,Q){return new e(O[0]|O[1]<<8|O[2]<<16|O[3]<<24,O[4]|O[5]<<8|O[6]<<16|O[7]<<24,Q)},e.fromBytesBE=function(O,Q){return new e(O[4]<<24|O[5]<<16|O[6]<<8|O[7],O[0]<<24|O[1]<<16|O[2]<<8|O[3],Q)},$_}var wR=aH();const ER=v0(wR),oH=pL({__proto__:null,default:ER},[wR]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pc=ER||oH;function Pm(r){return Pc.fromString(r,!0,16)}const bR=Pm("c3a5c85c97cb3127"),Rc=Pm("b492b66fbe98f273"),Ti=Pm("9ae16a3b2f90404f");function Kx(r){return r.xor(r.shru(47))}function TR(r,e,t){const n=r.slice(e,e+t);return Pc.fromBytes(Array.from(n),!0,!0)}function zn(r,e){return TR(r,e,8)}function uT(r,e){return TR(r,e,4)}function $r(r,e){return e===0?r:r.shru(e).or(r.shl(64-e))}function hu(r,e,t=Pm("9ddfea08eb382d69")){let n=r.xor(e).mul(t);n=n.xor(n.shru(47));let i=e.xor(n).mul(t);return i=i.xor(i.shru(47)),i=i.mul(t),i}function lH(r,e,t,n,i,s){i=i.add(r),s=$r(s.add(i).add(n),21);const a=i;return i=i.add(e),i=i.add(t),s=s.add($r(i,44)),[i.add(n),s.add(a)]}function Cy(r,e,t,n){return lH(zn(r,e),zn(r,e+8),zn(r,e+16),zn(r,e+24),t,n)}function uH(r,e=r.length){if(e>=8){const t=Ti.add(e*2),n=zn(r,0).add(Ti),i=zn(r,e-8),s=$r(i,37).mul(t).add(n),a=$r(n,25).add(i).mul(t);return hu(s,a,t)}if(e>=4){const t=Ti.add(e*2),n=uT(r,0);return hu(n.shl(3).add(e),uT(r,e-4),t)}if(e>0){const t=r[0],n=r[e>>1],i=r[e-1],s=t+(n<<8),a=e+(i<<2);return Kx(Ti.mul(s).xor(bR.mul(a))).mul(Ti)}return Ti}function cH(r,e=r.length){const t=Ti.add(e*2),n=zn(r,0).mul(Rc),i=zn(r,8),s=zn(r,e-8).mul(t),a=zn(r,e-16).mul(Ti);return hu($r(n.add(i),43).add($r(s,30)).add(a),n.add($r(i.add(Ti),18)).add(s),t)}function fH(r,e=r.length){const t=Ti.add(e*2),n=zn(r,0).mul(Ti),i=zn(r,8),s=zn(r,e-8).mul(t),a=zn(r,e-16).mul(Ti),o=$r(n.add(i),43).add($r(s,30)).add(a),u=hu(o,n.add($r(i.add(Ti),18)).add(s),t),h=zn(r,16).mul(t),p=zn(r,24),m=o.add(zn(r,e-32)).mul(t),y=u.add(zn(r,e-24)).mul(t);return hu($r(h.add(p),43).add($r(m,30)).add(y),h.add($r(p.add(n),18)).add(m),t)}function hH(r,e=r.length){const t=Pc.fromNumber(81,!0);if(e<=32)return e<=16?uH(r,e):cH(r,e);if(e<=64)return fH(r,e);let n=t,i=t.mul(Rc).add(113),s=Kx(i.mul(Ti).add(113)).mul(Ti),a=[Pc.UZERO,Pc.UZERO],o=[Pc.UZERO,Pc.UZERO];n=n.mul(Ti).add(zn(r,0));let u=0;const h=(e-1>>6)*64,p=h+(e-1&63)-63;do n=$r(n.add(i).add(a[0]).add(zn(r,u+8)),37).mul(Rc),i=$r(i.add(a[1]).add(zn(r,u+48)),42).mul(Rc),n=n.xor(o[1]),i=i.add(a[0]).add(zn(r,u+40)),s=$r(s.add(o[0]),33).mul(Rc),a=Cy(r,u,a[1].mul(Rc),n.add(o[0])),o=Cy(r,u+32,s.add(o[1]),i.add(zn(r,u+16))),[s,n]=[n,s],u+=64;while(u!==h);const m=Rc.add(s.and(255).shl(1));return u=p,o[0]=o[0].add(e-1&63),a[0]=a[0].add(o[0]),o[0]=o[0].add(a[0]),n=$r(n.add(i).add(a[0]).add(zn(r,u+8)),37).mul(m),i=$r(i.add(a[1]).add(zn(r,u+48)),42).mul(m),n=n.xor(o[1].mul(9)),i=i.add(a[0].mul(9).add(zn(r,u+40))),s=$r(s.add(o[0]),33).mul(m),a=Cy(r,u,a[1].mul(m),n.add(o[0])),o=Cy(r,u+32,s.add(o[1]),i.add(zn(r,u+16))),[s,n]=[n,s],hu(hu(a[0],o[0],m).add(Kx(i).mul(bR)).add(s),hu(a[1],o[1],m).add(n),m)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dH(r,e){return e==="string"?Lm(r):Y0([r],e)}function pH(r,e){return r instanceof Float32Array&&e==="float32"||r instanceof Int32Array&&e==="int32"||r instanceof Uint8Array&&e==="bool"}function Y0(r,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(r)&&(r=vu(r)),Ht().getBool("DEBUG")&&E2(r,e),pH(r,e))return r;if(e==null||e==="float32"||e==="complex64")return new Float32Array(r);if(e==="int32")return new Int32Array(r);if(e==="bool"){const t=new Uint8Array(r.length);for(let n=0;n<t.length;++n)Math.round(r[n])!==0&&(t[n]=1);return t}else throw new Error(`Unknown data type ${e}`)}function lm(){return Ht().platform.now()}function mH(r,e){return Ht().platform.fetch(r,e)}function Lm(r,e="utf-8"){return e=e||"utf-8",Ht().platform.encode(r,e)}function l0(r,e="utf-8"){return e=e||"utf-8",Ht().platform.decode(r,e)}function Gr(r){return Ht().platform.isTypedArray!=null?Ht().platform.isTypedArray(r):SR(r)}function vu(r,e=[],t=!1){if(e==null&&(e=[]),typeof r=="boolean"||typeof r=="number"||typeof r=="string"||yu(r)||r==null||Gr(r)&&t)e.push(r);else if(Array.isArray(r)||Gr(r))for(let n=0;n<r.length;++n)vu(r[n],e,t);else{let n=-1;for(const i of Object.keys(r))/^([1-9]+[0-9]*|0)$/.test(i)&&(n=Math.max(n,Number(i)));for(let i=0;i<=n;i++)vu(r[i],e,t)}return e}const gH=Object.freeze(Object.defineProperty({__proto__:null,arraysEqual:Ra,arraysEqualWithNull:x2,assert:j,assertNonNegativeIntegerDimensions:gs,assertNonNull:uf,assertShapesMatch:Ii,bytesFromStringArray:T2,bytesPerElement:s0,checkConversionForErrors:E2,clamp:sm,computeStrides:cd,convertBackendValuesAndArrayBuffer:AV,createScalarValue:dH,createShuffledIndices:EV,decodeString:l0,distSquared:_V,encodeString:Lm,fetch:mH,fingerPrint64:hH,flatten:vu,getArrayFromDType:c1,getTypedArrayFromDType:w2,hasEncodingLoss:MV,hexToLong:Pm,indexToLoc:RV,inferDtype:Im,inferFromImplicitShape:TV,isBoolean:M2,isFunction:gu,isInt:Jh,isNumber:A2,isPromise:yu,isScalarShape:xV,isString:su,isTypedArray:Gr,isValidDtype:b2,locToIndex:CV,makeOnesTypedArray:f1,makeZerosNestedTypedArray:NV,makeZerosTypedArray:K0,nearestDivisor:a0,nearestLargerEven:gV,now:lm,parseAxisParam:Rm,randUniform:vV,repeatedTry:bV,rightPad:Dp,shuffle:_2,shuffleCombo:mV,sizeFromShape:Rn,sizeToSquarishShape:wV,squeezeShape:S2,sum:yV,swap:i0,tanh:SV,toNestedArray:Gc,toTypedArray:Y0},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yH{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new _H)}profileKernel(e,t,n){let i;const s=()=>{i=n()};let a;const o=lm();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(const h of i)h.dataSync();a=Promise.resolve({kernelMs:lm()-o})}if(Ht().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let h=0;h<i.length;h++){const p=i[h];p.data().then(m=>{vH(m,p.dtype,e)})}return{kernelName:e,outputs:i,inputs:t,timeMs:a.then(h=>h.kernelMs),extraInfo:a.then(h=>h.getExtraProfileInfo!=null?h.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:i,inputs:s,extraInfo:a}=e;n.forEach(o=>{Promise.all([o.data(),i,a]).then(u=>{this.logger.logKernelProfile(t,o,u[0],u[1],s,u[2])})})}}function vH(r,e,t){if(e!=="float32")return!1;for(let n=0;n<r.length;n++){const i=r[n];if(isNaN(i)||!isFinite(i))return console.warn(`Found ${i} in the result of '${t}'`),!0}return!1}class _H{logKernelProfile(e,t,n,i,s,a){const o=typeof i=="number"?Dp(`${i}ms`,9):i.error,u=Dp(e,25),h=t.rank,p=t.size,m=Dp(t.shape.toString(),14);let y="";for(const v in s){const S=s[v];if(S!=null){const T=S.shape||t.shape,E=T.length;y+=`${v}: ${E}D ${E>0?T:""} `}}console.log(`%c${u}	%c${o}	%c${h}D ${m}	%c${p}	%c${y}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xH(r,e,t){const n={},i={};for(let u=0;u<e.length;u++)n[e[u].id]=!0;for(let u=0;u<r.length;u++){const h=r[u],p=h.inputs;for(const m in p){const y=p[m];let v=!1;for(let S=0;S<e.length;S++)if(n[y.id]){h.outputs.forEach(T=>n[T.id]=!0),v=!0,i[h.id]=!0;break}if(v)break}}const s={};s[t.id]=!0;const a={};for(let u=r.length-1;u>=0;u--){const h=r[u],p=h.inputs;for(let m=0;m<h.outputs.length;m++)if(s[h.outputs[m].id]){for(const y in p)s[p[y].id]=!0,a[h.id]=!0;break}}const o=[];for(let u=0;u<r.length;u++){const h=r[u];if(i[h.id]&&a[h.id]){const p={};for(const y in h.inputs){const v=h.inputs[y];n[v.id]&&(p[y]=v)}const m=Object.assign({},h);m.inputs=p,m.outputs=h.outputs,o.push(m)}}return o}function SH(r,e,t,n){for(let i=e.length-1;i>=0;i--){const s=e[i],a=[];if(s.outputs.forEach(u=>{const h=r[u.id];h!=null?a.push(h):a.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);const o=s.gradient(a);for(const u in s.inputs){if(!(u in o))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(o)}.`);const h=t(()=>o[u]());if(h.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${h.dtype}'`);const p=s.inputs[u];if(!Ra(h.shape,p.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${u}' has shape '${h.shape}', which does not match the shape of the input '${p.shape}'`);if(r[p.id]==null)r[p.id]=h;else{const m=r[p.id];r[p.id]=n(m,h),m.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cT=20,wp=3,G_=7;function wH(r,e,t,n){const i=cd(e),s=EH(r,e,t,i),a=e.length,o=Vy(r,e,t,i,s),u=["Tensor"];return n&&(u.push(`  dtype: ${t}`),u.push(`  rank: ${a}`),u.push(`  shape: [${e}]`),u.push("  values:")),u.push(o.map(h=>"    "+h).join(`
`)),u.join(`
`)}function EH(r,e,t,n){const i=Rn(e),s=n[n.length-1],a=new Array(s).fill(0),o=e.length,u=t==="complex64"?Np(r):r;if(o>1)for(let h=0;h<i/s;h++){const p=h*s;for(let m=0;m<s;m++)a[m]=Math.max(a[m],Ap(u[p+m],0,t).length)}return a}function Ap(r,e,t){let n;return Array.isArray(r)?n=`${parseFloat(r[0].toFixed(G_))} + ${parseFloat(r[1].toFixed(G_))}j`:su(r)?n=`'${r}'`:t==="bool"?n=MR(r):n=parseFloat(r.toFixed(G_)).toString(),Dp(n,e)}function MR(r){return r===0?"false":"true"}function Vy(r,e,t,n,i,s=!0){const a=t==="complex64"?2:1,o=e[0],u=e.length;if(u===0){if(t==="complex64"){const T=Np(r);return[Ap(T[0],0,t)]}return t==="bool"?[MR(r[0])]:[r[0].toString()]}if(u===1){if(o>cT){const E=wp*a;let w=Array.from(r.slice(0,E)),C=Array.from(r.slice((o-wp)*a,o*a));return t==="complex64"&&(w=Np(w),C=Np(C)),["["+w.map((A,I)=>Ap(A,i[I],t)).join(", ")+", ..., "+C.map((A,I)=>Ap(A,i[o-wp+I],t)).join(", ")+"]"]}return["["+(t==="complex64"?Np(r):Array.from(r)).map((E,w)=>Ap(E,i[w],t)).join(", ")+"]"]}const h=e.slice(1),p=n.slice(1),m=n[0]*a,y=[];if(o>cT){for(let T=0;T<wp;T++){const E=T*m,w=E+m;y.push(...Vy(r.slice(E,w),h,t,p,i,!1))}y.push("...");for(let T=o-wp;T<o;T++){const E=T*m,w=E+m;y.push(...Vy(r.slice(E,w),h,t,p,i,T===o-1))}}else for(let T=0;T<o;T++){const E=T*m,w=E+m;y.push(...Vy(r.slice(E,w),h,t,p,i,T===o-1))}const v=u===2?",":"";y[0]="["+(o>0?y[0]+v:"");for(let T=1;T<y.length-1;T++)y[T]=" "+y[T]+v;let S=`,
`;for(let T=2;T<u;T++)S+=`
`;return y[y.length-1]=" "+y[y.length-1]+"]"+(s?"":S),y}function Np(r){const e=[];for(let t=0;t<r.length;t+=2)e.push([r[t],r[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class u0{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=Rn(e),n!=null){const i=n.length;j(i===this.size,()=>`Length of values '${i}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||c1(t,this.size),this.strides=cd(e)}set(e,...t){t.length===0&&(t=[0]),j(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const n=this.locToIndex(t);this.values[n]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const i of e){if(i<0||i>=this.shape[t]){const s=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(s)}t++}let n=e[e.length-1];for(let i=0;i<e.length-1;++i)n+=this.strides[i]*e[i];return this.values[n]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Ta().makeTensor(this.values,this.shape,this.dtype)}}let Ta=null,kh=null;function bH(r){Ta=r}function TH(r){kh=r}class ur{constructor(e,t,n,i){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Rn(e),this.strides=cd(e),this.dataId=n,this.id=i,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return kh.buffer(this.shape,this.dtype,e)}bufferSync(){return kh.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return Gc(this.shape,e,this.dtype==="complex64")}arraySync(){return Gc(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=Ta().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(n=>l0(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Ta().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Ta().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>l0(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Ta().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Ta().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return kh.print(this,e)}clone(){return this.throwIfDisposed(),kh.clone(this)}toString(e=!1){const t=this.dataSync();return wH(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),kh.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),Ta().makeVariable(this,e,t,n)}}Object.defineProperty(ur,Symbol.hasInstance,{value:r=>!!r&&r.data!=null&&r.dataSync!=null&&r.throwIfDisposed!=null});function AR(){return d1("Tensor",()=>ur)}AR();class um extends ur{constructor(e,t,n,i){super(e.shape,e.dtype,e.dataId,i),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Ra(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Ta().disposeTensor(this),this.dataId=e.dataId,Ta().incRef(this,null)}dispose(){Ta().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(um,Symbol.hasInstance,{value:r=>r instanceof ur&&r.assign!=null&&r.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Yx;(function(r){r.R0="R0",r.R1="R1",r.R2="R2",r.R3="R3",r.R4="R4",r.R5="R5",r.R6="R6"})(Yx||(Yx={}));var Zx;(function(r){r.float32="float32",r.int32="int32",r.bool="int32",r.complex64="complex64"})(Zx||(Zx={}));var Jx;(function(r){r.float32="float32",r.int32="int32",r.bool="bool",r.complex64="complex64"})(Jx||(Jx={}));var Qx;(function(r){r.float32="float32",r.int32="float32",r.bool="float32",r.complex64="complex64"})(Qx||(Qx={}));var eS;(function(r){r.float32="complex64",r.int32="complex64",r.bool="complex64",r.complex64="complex64"})(eS||(eS={}));const MH={float32:Qx,int32:Zx,bool:Jx,complex64:eS};function Z0(r,e){if(r==="string"||e==="string"){if(r==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${r} with ${e}`)}return MH[r][e]}function AH(r){return Z0(r,"int32")}function NR(r){return r!=null&&typeof r=="object"&&"texture"in r&&r.texture instanceof WebGLTexture}function CR(r){return typeof GPUBuffer<"u"&&r!=null&&typeof r=="object"&&"buffer"in r&&r.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ir(r,e){if(r.dtype===e.dtype)return[r,e];const t=Z0(r.dtype,e.dtype);return[r.cast(t),e.cast(t)]}function RR(r,e){j(r.dtype===e.dtype,()=>`The dtypes of the first(${r.dtype}) and second(${e.dtype}) input must match`)}function NH(r,e){return e.some(t=>t.id===r.id)}function x1(r){const e=[];return IR(r,e,new Set),e}function IR(r,e,t){if(r==null)return;if(r instanceof ur){e.push(r);return}if(!CH(r))return;const n=r;for(const i in n){const s=n[i];t.has(s)||(t.add(s),IR(s,e,t))}}function CH(r){return Array.isArray(r)||typeof r=="object"}const RH=Object.freeze(Object.defineProperty({__proto__:null,assertTypesMatch:RR,getTensorsInContainer:x1,isTensorInList:NH,makeTypesMatch:ir},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W_(r){return r.kernelName!=null}class fT{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class ed{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new fT}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success){await this.setBackend(n);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(ru(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new yH(this.backendInstance),!0}setupRegisteredKernels(){o0(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){o0(e).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(n&&!(n instanceof v2)&&typeof n.then=="function"){const i=++this.pendingBackendInitId,s=n.then(a=>i<this.pendingBackendInitId?!1:(this.registry[e]=a,this.pendingBackendInit=null,!0)).catch(a=>(i<this.pendingBackendInitId||(this.pendingBackendInit=null,ru(`Initialization of backend ${e} failed`),ru(a.stack||a.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[e]=n,{success:!0,asyncInit:!1}}catch(n){return ru(`Initialization of backend ${e} failed`),ru(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:i,asyncInit:s}=this.initializeBackend(n);if(s||i)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),i=n.backend,s=this.readSync(t),a=i.refCount(t);i.disposeData(t,!0),n.backend=e,e.move(t,s,n.shape,n.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");n=e}let i;return this.scopedRun(()=>this.startScope(n),()=>this.endScope(i),()=>(i=t(),i instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),i))}scopedRun(e,t,n){e();try{const i=n();return t(),i}catch(i){throw t(),i}}nextTensorId(){return ed.nextTensorId++}nextVariableId(){return ed.nextVariableId++}clone(e){const t=ie.runKernel(y1,{x:e}),n={x:e},i=a=>({x:()=>{const o="float32",u={x:a},h={dtype:o};return ie.runKernel(m1,u,h)}}),s=[];return this.addTapeNode(this.state.activeScope.name,n,[t],i,s,{}),t}runKernel(e,t,n){if(this.backendName==null&&this.backend,!(om(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const i=this.backend.numDataIds();let s=0;n.forEach(u=>{s+=u.dtype==="complex64"?3:1});const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=i-t-s-a;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const i=this.isTapeOn(),s=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let u;const h=W_(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(W_(e)){const{kernelName:S,inputs:T,attrs:E}=e;this.backendName==null&&this.backend;const w=om(S,this.backendName);j(w!=null,()=>`Cannot find registered kernel '${S}' for backend '${this.backendName}'`),o=()=>{const C=this.backend.numDataIds();u=w.kernelFunc({inputs:T,attrs:E,backend:this.backend});const A=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(S,C,A);const I=A.map(F=>F.rank!=null?F:this.makeTensorFromTensorInfo(F));if(i){const F=this.getTensorsForGradient(S,T,I);n=this.saveTensorsForBackwardMode(F)}return I}}else{const{forwardFunc:S}=e,T=E=>{i&&(n=E.map(w=>this.keep(this.clone(w))))};o=()=>{const E=this.backend.numDataIds();u=this.tidy(()=>S(this.backend,T));const w=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(h,E,w),w}}const{inputs:p,attrs:m}=e,y=W_(e)?null:e.backwardsFunc;let v;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=o():(v=this.profiler.profileKernel(h,p,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(v),t=v.outputs)}),i&&this.addTapeNode(h,p,t,y,n,m),this.state.profiling&&this.state.activeProfile.kernels.push({name:h,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(p).map(S=>p[S]!=null?p[S].shape:null),outputShapes:t.map(S=>S.shape),kernelTimeMs:v.timeMs,extraInfo:v.extraInfo}),Array.isArray(u)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(e,t,n){const i=Xx(e);if(i!=null){const s=i.inputsToSave||[],a=i.outputsToSave||[];let o;i.saveAllInputs?(j(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(t).map(h=>t[h])):o=s.map(h=>t[h]);const u=n.filter((h,p)=>a[p]);return o.concat(u)}return[]}makeTensor(e,t,n,i){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",i=i||this.backend;let s=e;n==="string"&&su(e[0])&&(s=e.map(u=>Lm(u)));const a=i.write(s,t,n),o=new ur(t,n,a,this.nextTensorId());if(this.trackTensor(o,i),n==="string"){const u=this.state.tensorInfo.get(a),h=T2(s);this.state.numBytes+=h-u.bytes,u.bytes=h}return o}makeTensorFromDataId(e,t,n,i){n=n||"float32";const s={dataId:e,shape:t,dtype:n};return this.makeTensorFromTensorInfo(s,i)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:i,dtype:s}=e,a=new ur(i,s,n,this.nextTensorId());return this.trackTensor(a,t),a}makeVariable(e,t=!0,n,i){n=n||this.nextVariableId().toString(),i!=null&&i!==e.dtype&&(e=e.cast(i));const s=new um(e,t,n,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let n=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(n=e.size*s0(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof um||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const n=e.size*s0(e.dtype);this.state.numBytes-=n}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(i=>i.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const i of this.state.activeProfile.kernels)i.kernelTimeMs=await i.kernelTimeMs,i.extraInfo=await i.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,n,i,s,a){const o={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:s},u=Xx(e);u!=null&&(i=u.gradFunc),i!=null&&(o.gradient=h=>(h=h.map((p,m)=>{if(p==null){const y=n[m],v=K0(y.size,y.dtype);return this.makeTensor(v,y.shape,y.dtype)}return p}),i(h.length>1?h:h[0],s,a))),this.state.activeTape.push(o)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=x1(e),n=new Set(t.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){const a=this.state.activeScope.track[s];!a.kept&&!n.has(a.id)&&a.dispose()}const i=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(s=>{!s.kept&&s.scopeId===i.id&&this.track(s)})}gradients(e,t,n,i=!1){if(j(t.length>0,()=>"gradients() received an empty list of xs."),n!=null&&n.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));j(s instanceof ur,()=>"The result y returned by f() must be a tensor.");const a=xH(this.state.activeTape,t,s);if(!i&&a.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const o={};o[s.id]=n??IH(s.shape),SH(o,a,h=>this.tidy(h),PH);const u=t.map(h=>o[h.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(h=>{for(const p of h.saved)p.dispose()}),this.state.activeTape=null),{value:s,grads:u}})}customGrad(e){return j(gu(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{j(t.every(o=>o instanceof ur),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let n;const i={};t.forEach((o,u)=>{i[u]=o});const s=(o,u)=>(n=e(...t,u),j(n.value instanceof ur,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),j(gu(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),a=(o,u)=>{const h=n.gradFunc(o,u),p=Array.isArray(h)?h:[h];j(p.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),j(p.every(y=>y instanceof ur),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const m={};return p.forEach((y,v)=>{m[v]=()=>y}),m};return this.runKernelFunc({forwardFunc:s,backwardsFunc:a,inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=lm(),n=await this.backend.time(e);return n.wallMs=lm()-t,n}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new fT;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}ed.nextTensorId=0;ed.nextVariableId=0;function IH(r){const e=f1(Rn(r),"float32");return ie.makeTensor(e,r,"float32")}function PR(){const r=R2();if(r._tfengine==null){const e=new C2(r);r._tfengine=new ed(e)}return kV(r._tfengine.ENV),bH(()=>r._tfengine),r._tfengine}const ie=PR();function PH(r,e){const t={a:r,b:e};return ie.runKernel(p1,t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LH(){return typeof navigator<"u"&&navigator!=null}let tS;function kH(r){tS=r}function DH(r){if(tS!==void 0)return tS;if(r||LH()){if(r||(r=navigator),r.product==="ReactNative")return!0;const e=r.userAgent||r.vendor||(typeof window<"u"?window.opera:"");if(!e){const t=r;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function LR(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const OH=Object.freeze(Object.defineProperty({__proto__:null,isBrowser:LR,isMobile:DH,mockIsMobile:kH},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ji=Ht();ji.registerFlag("DEBUG",()=>!1,r=>{r&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});ji.registerFlag("IS_BROWSER",()=>LR());ji.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");ji.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));ji.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));ji.registerFlag("PROD",()=>!1);ji.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ji.getBool("DEBUG"));ji.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);ji.registerFlag("IS_TEST",()=>!1);ji.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>ji.getBool("DEBUG"));ji.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);ji.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);ji.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function so(r,e){let t=r;if(Gr(r))return e==="string"?[]:[r.length];if(NR(r)){const i=r.channels||"RGBA";return[r.height,r.width*i.length]}else if(CR(r))return[r.buffer.size/(e==null?4:s0(e))];if(!Array.isArray(r))return[];const n=[];for(;Array.isArray(t)||Gr(t)&&e!=="string";)n.push(t.length),t=t[0];return Array.isArray(r)&&Ht().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&kR(r,n,[]),n}function kR(r,e,t){if(t=t||[],!Array.isArray(r)&&!Gr(r)){j(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}j(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${r.length} elements`),j(r.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${r.length} elements`);const n=e.slice(1);for(let i=0;i<r.length;++i)kR(r[i],n,t.concat(i))}function hT(r,e,t,n){if(r!=="string_or_numeric"){if(r==null)throw new Error("Expected dtype cannot be null.");if(r!=="numeric"&&r!==e||r==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${n}' must be ${r} tensor, but got ${e} tensor`)}}function H(r,e,t,n="numeric"){if(r instanceof AR())return hT(n,r.dtype,e,t),r;let i=Im(r);if(i!=="string"&&["bool","int32","float32"].indexOf(n)>=0&&(i=n),hT(n,i,e,t),r==null||!Gr(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string"){const u=r==null?"null":r.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${u}'`)}const s=so(r,i);!Gr(r)&&!Array.isArray(r)&&(r=[r]);const o=i!=="string"?Y0(r,i):vu(r,[],!0);return ie.makeTensor(o,s,i)}function cm(r,e,t,n="numeric"){if(!Array.isArray(r))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return r.map((s,a)=>H(s,`${e}[${a}]`,t,n))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S1="__op";function ne(r){const e=Object.keys(r);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const n=r[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+S1;const i=(...s)=>{ie.startScope(t);try{const a=n(...s);return yu(a)&&console.error("Cannot return a Promise inside of tidy."),ie.endScope(a),a}catch(a){throw ie.endScope(null),a}};return Object.defineProperty(i,"name",{value:t,configurable:!0}),i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FH(r,e){const t=H(r,"real","complex"),n=H(e,"imag","complex");Ii(t.shape,n.shape,`real and imag shapes, ${t.shape} and ${n.shape}, must match in call to tf.complex().`);const i={real:t,imag:n};return ie.runKernel(Q2,i)}const fl=ne({complex_:FH});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mu(r,e,t,n){if(n==null)n=Im(r);else if(n==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(CR(r)||NR(r)){if(n!=="float32"&&n!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${n}.`);return ie.backend.createTensorFromGPUData(r,e||t,n)}if(!Gr(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){gs(e);const i=Rn(e),s=Rn(t);j(i===s,()=>`Based on the provided shape, [${e}], the tensor should have ${i} values but has ${s}`);for(let a=0;a<t.length;++a){const o=t[a],u=a===t.length-1?o!==Rn(e.slice(a)):!0;j(t[a]===e[a]||!u,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!Gr(r)&&!Array.isArray(r)&&(r=[r]),e=e||t,r=n!=="string"?Y0(r,n):vu(r,[],!0),ie.makeTensor(r,e,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aa(r,e,t){const n=so(r,t);return Mu(r,e,n,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zc={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class ka{static join(e){return new ka(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(n=>Gr(n)?n.buffer:n),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){const i=e[n];n!==e.length-1&&i.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const s=t+i.byteLength;this.shards.push({buffer:i,start:t,end:s}),t=s}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const n=this.findShardForByte(e);if(n===-1)throw new Error(`Could not find start shard for byte ${e}`);const i=t-e,s=new ArrayBuffer(i),a=new Uint8Array(s);let o=0;for(let u=n;u<this.shards.length;u++){const h=this.shards[u],m=e+o-h.start,y=o,S=Math.min(t,h.end)-h.start,T=new Uint8Array(h.buffer,m,S-m);if(a.set(T,y),o+=T.length,t<h.end)break}return s}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(i){return e<i.start?-1:e>=i.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const n=UH(this.shards,t);return n===-1?-1:(this.previousShardIndex=n,this.previousShardIndex)}}function UH(r,e){let t=0,n=r.length;for(;t<=n;){const i=Math.floor((n-t)/2)+t,s=e(r[i]);if(s===0)return i;s<0?n=i:t=i+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zH(){Ht().set("PROD",!0)}function BH(){Ht().set("DEBUG",!0)}function VH(){Ht().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function HH(r){Ht().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(r+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function $H(){ie.disposeVariables()}function GH(){return ie}function WH(){return ie.memory()}function jH(r){return ie.profile(r)}function bn(r,e){return ie.tidy(r,e)}function Ci(r){x1(r).forEach(t=>t.dispose())}function Ma(r){return ie.keep(r)}function qH(r){return ie.time(r)}function XH(r){return ie.setBackend(r)}function KH(){return ie.ready()}function DR(){return ie.backendName}function YH(r){ie.removeBackend(r)}function ZH(r){return ie.findBackend(r)}function JH(r){return ie.findBackendFactory(r)}function QH(r,e,t=1){return ie.registerBackend(r,e,t)}function OR(){return ie.backend}function e5(r,e){Ht().setPlatform(r,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _u=4;async function t5(r,e){const t=[],n=[],i=Array.isArray(r)?r.map(a=>a.name):Object.keys(r);for(let a=0;a<i.length;++a){const o=i[a],u=Array.isArray(r)?r[a].tensor:r[o];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${u.dtype}`);const h={name:o,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){const p=new Promise(async m=>{const y=await u.bytes(),v=y.reduce((E,w)=>E+w.length,0)+_u*y.length,S=new Uint8Array(v);let T=0;for(let E=0;E<y.length;E++){const w=y[E],C=new Uint8Array(new Uint32Array([w.length]).buffer);S.set(C,T),T+=_u,S.set(w,T),T+=w.length}m(S)});n.push(p)}else n.push(u.data());e!=null&&(h.group=e),t.push(h)}const s=await Promise.all(n);return{data:i5(s),specs:t}}function FR(r,e){const t=new ka(r),n={};let i=0;for(const s of e){const a=n5(s,(o,u)=>t.slice(i+o,i+u));n[s.name]=UR(s,t.slice(i,i+a)),i+=a}return n}function n5(r,e){const t=Rn(r.shape);let n;if("quantization"in r){const i=r.quantization;n=Zc[i.dtype]}else if(r.dtype==="string"){let i=0;for(let s=0;s<t;s++)i+=_u+new Uint32Array(e(i,i+_u))[0];return i}else n=Zc[r.dtype];return t*n}async function r5(r,e){const t=Rn(r.shape);let n;if("quantization"in r){const i=r.quantization;n=Zc[i.dtype]}else if(r.dtype==="string"){let i=0;for(let s=0;s<t;s++)i+=_u+new Uint32Array(await e(i,i+_u))[0];return i}else n=Zc[r.dtype];return t*n}function UR(r,e){const t=r.name,n=r.dtype,i=r.shape,s=Rn(i);let a,o=0;if("quantization"in r){const u=r.quantization;if(u.dtype==="uint8"||u.dtype==="uint16"){if(!("min"in u&&"scale"in u))throw new Error(`Weight ${r.name} with quantization ${u.dtype} doesn't have corresponding metadata min and scale.`)}else if(u.dtype==="float16"){if(n!=="float32")throw new Error(`Weight ${r.name} is quantized with ${u.dtype} which only supports weights of type float32 not ${n}.`)}else throw new Error(`Weight ${r.name} has unknown quantization dtype ${u.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const h=Zc[u.dtype],p=u.dtype==="uint8"?new Uint8Array(e):new Uint16Array(e);if(n==="float32")if(u.dtype==="uint8"||u.dtype==="uint16"){a=new Float32Array(p.length);for(let m=0;m<p.length;m++){const y=p[m];a[m]=y*u.scale+u.min}}else if(u.dtype==="float16")a=f5()(p);else throw new Error(`Unsupported quantization type ${u.dtype} for weight type float32.`);else if(n==="int32"){if(u.dtype!=="uint8"&&u.dtype!=="uint16")throw new Error(`Unsupported quantization type ${u.dtype} for weight type int32.`);a=new Int32Array(p.length);for(let m=0;m<p.length;m++){const y=p[m];a[m]=Math.round(y*u.scale+u.min)}}else throw new Error(`Unsupported dtype in weight '${t}': ${n}`);o+=s*h}else if(n==="string"){const u=Rn(r.shape);a=[];for(let h=0;h<u;h++){const p=new Uint32Array(e.slice(o,o+_u))[0];o+=_u;const m=new Uint8Array(e.slice(o,o+p));a.push(m),o+=p}}else{const u=Zc[n];if(n==="float32")a=new Float32Array(e);else if(n==="int32")a=new Int32Array(e);else if(n==="bool")a=new Uint8Array(e);else if(n==="complex64"){a=new Float32Array(e);const h=new Float32Array(a.length/2),p=new Float32Array(a.length/2);for(let S=0;S<h.length;S++)h[S]=a[S*2],p[S]=a[S*2+1];const m=Aa(h,i,"float32"),y=Aa(p,i,"float32"),v=fl(m,y);return m.dispose(),y.dispose(),v}else throw new Error(`Unsupported dtype in weight '${t}': ${n}`);o+=s*u}return Aa(a,i,n)}async function dT(r,e,t){let n=new Uint8Array(e);for(;n.byteLength<t;){const{done:i,value:s}=await r.read();if(i&&s==null){const o=t-n.byteLength;throw new Error(`Reader is done but ${o} bytes are still expected`)}const a=new Uint8Array(n.length+s.byteLength);a.set(n,0),a.set(new Uint8Array(s),n.length),n=a}return n.buffer}async function zR(r,e){const t={},n=r.getReader();let i=new ArrayBuffer(0);for(const s of e){const a=await r5(s,async(h,p)=>(i=await dT(n,i,p),i.slice(h,p)));i=await dT(n,i,a);const o=i.slice(0,a);i=i.slice(a);const u=UR(s,o);if(t[s.name]=u,DR()==="webgpu"){const h=OR();"uploadToGPU"in h&&Rn(u.shape)>=Ht().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&h.uploadToGPU(u.dataId)}}return t}function i5(r){if(r===null)throw new Error(`Invalid input value: ${JSON.stringify(r)}`);let e=0;const t=[];r.forEach(s=>{if(e+=s.byteLength,t.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});const n=new Uint8Array(e);let i=0;return t.forEach(s=>{n.set(new Uint8Array(s.buffer),i),i+=s.byteLength}),n.buffer}const w1=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function pT(r){return w1?Buffer.byteLength(r,"utf8"):new Blob([r]).size}function s5(r){if(w1)return Buffer.from(r).toString("base64");const e=new Uint8Array(r);let t="";for(let n=0,i=e.length;n<i;n++)t+=String.fromCharCode(e[n]);return btoa(t)}function a5(r){if(w1){const n=Buffer.from(r,"base64");return n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength)}const e=atob(r),t=new Uint8Array(e.length);for(let n=0;n<e.length;++n)t.set([e.charCodeAt(n)],n);return t.buffer}function o5(r){return ka.join(r)}function mT(r){const e="/";for(r=r.trim();r.endsWith(e);)r=r.slice(0,r.length-1);const t=r.split(e);return t[t.length-1]}function BR(r,e){const t={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy,weightsManifest:e};return r.signature!=null&&(t.signature=r.signature),r.userDefinedMetadata!=null&&(t.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(t.modelInitializer=r.modelInitializer),r.initializerSignature!=null&&(t.initializerSignature=r.initializerSignature),r.trainingConfig!=null&&(t.trainingConfig=r.trainingConfig),t}function E1(r,e,t){const n={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy};if(r.trainingConfig!=null&&(n.trainingConfig=r.trainingConfig),r.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");n.weightSpecs=e,n.weightData=t}return r.signature!=null&&(n.signature=r.signature),r.userDefinedMetadata!=null&&(n.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(n.modelInitializer=r.modelInitializer),r.initializerSignature!=null&&(n.initializerSignature=r.initializerSignature),n}async function b1(r,e){let t,n;return r.weightsManifest!=null&&([t,n]=await e(r.weightsManifest)),E1(r,t,n)}function km(r){if(r.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:r.modelTopology==null?0:pT(JSON.stringify(r.modelTopology)),weightSpecsBytes:r.weightSpecs==null?0:pT(JSON.stringify(r.weightSpecs)),weightDataBytes:r.weightData==null?0:new ka(r.weightData).byteLength}}function c0(r){const e=[];for(const t of r)e.push(...t.weights);return e}function l5(){const r=t=>{let n=t<<13,i=0;for(;(n&8388608)===0;)i-=8388608,n<<=1;return n&=-8388609,i+=947912704,n|i},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=r(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function u5(){const r=new Uint32Array(64);r[0]=0,r[31]=1199570944,r[32]=2147483648,r[63]=3347054592;for(let e=1;e<31;e++)r[e]=e<<23;for(let e=33;e<63;e++)r[e]=2147483648+(e-32<<23);return r}function c5(){const r=new Uint32Array(64);for(let e=0;e<64;e++)r[e]=1024;return r[0]=r[32]=0,r}function f5(){const r=l5(),e=u5(),t=c5();return n=>{const i=new ArrayBuffer(4*n.length),s=new Uint32Array(i);for(let a=0;a<n.length;a++){const o=n[a],u=r[t[o>>10]+(o&1023)]+e[o>>10];s[a]=u}return new Float32Array(i)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rr{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return rr.instance==null&&(rr.instance=new rr),rr.instance}static registerSaveRouter(e){rr.getInstance().saveRouters.push(e)}static registerLoadRouter(e){rr.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return rr.getHandlers(e,"save")}static getLoadHandlers(e,t){return rr.getHandlers(e,"load",t)}static getHandlers(e,t,n){const i=[];return(t==="load"?rr.getInstance().loadRouters:rr.getInstance().saveRouters).forEach(a=>{const o=a(e,n);o!==null&&i.push(o)}),i}}const h5=r=>rr.registerSaveRouter(r),d5=r=>rr.registerLoadRouter(r),p5=r=>rr.getSaveHandlers(r),m5=(r,e)=>rr.getLoadHandlers(r,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nS="tensorflowjs",rS=1,zc="models_store",au="model_info_store";function VR(){if(!Ht().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const r=typeof window>"u"?self:window,e=r.indexedDB||r.mozIndexedDB||r.webkitIndexedDB||r.msIndexedDB||r.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function iS(r){const e=r.result;e.createObjectStore(zc,{keyPath:"modelPath"}),e.createObjectStore(au,{keyPath:"modelPath"})}class Jc{constructor(e){if(this.indexedDB=VR(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((n,i)=>{const s=this.indexedDB.open(nS,rS);s.onupgradeneeded=()=>iS(s),s.onsuccess=()=>{const a=s.result;if(t==null){const o=a.transaction(zc,"readonly"),h=o.objectStore(zc).get(this.modelPath);h.onsuccess=()=>{if(h.result==null)return a.close(),i(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(h.result.modelArtifacts)},h.onerror=p=>(a.close(),i(h.error)),o.oncomplete=()=>a.close()}else{t.weightData=ka.join(t.weightData);const o=km(t),u=a.transaction(au,"readwrite");let h=u.objectStore(au),p;try{p=h.put({modelPath:this.modelPath,modelArtifactsInfo:o})}catch(y){return i(y)}let m;p.onsuccess=()=>{m=a.transaction(zc,"readwrite");const y=m.objectStore(zc);let v;try{v=y.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:o})}catch(S){return i(S)}v.onsuccess=()=>n({modelArtifactsInfo:o}),v.onerror=S=>{h=u.objectStore(au);const T=h.delete(this.modelPath);T.onsuccess=()=>(a.close(),i(v.error)),T.onerror=E=>(a.close(),i(v.error))}},p.onerror=y=>(a.close(),i(p.error)),u.oncomplete=()=>{m==null?a.close():m.oncomplete=()=>a.close()}}},s.onerror=a=>i(s.error)})}}Jc.URL_SCHEME="indexeddb://";const HR=r=>Ht().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(Jc.URL_SCHEME)?g5(r.slice(Jc.URL_SCHEME.length)):null;rr.registerSaveRouter(HR);rr.registerLoadRouter(HR);function g5(r){return new Jc(r)}function y5(r){return r.startsWith(Jc.URL_SCHEME)?r.slice(Jc.URL_SCHEME.length):r}class v5{constructor(){this.indexedDB=VR()}async listModels(){return new Promise((e,t)=>{const n=this.indexedDB.open(nS,rS);n.onupgradeneeded=()=>iS(n),n.onsuccess=()=>{const i=n.result,s=i.transaction(au,"readonly"),o=s.objectStore(au).getAll();o.onsuccess=()=>{const u={};for(const h of o.result)u[h.modelPath]=h.modelArtifactsInfo;e(u)},o.onerror=u=>(i.close(),t(o.error)),s.oncomplete=()=>i.close()},n.onerror=i=>t(n.error)})}async removeModel(e){return e=y5(e),new Promise((t,n)=>{const i=this.indexedDB.open(nS,rS);i.onupgradeneeded=()=>iS(i),i.onsuccess=()=>{const s=i.result,a=s.transaction(au,"readwrite"),o=a.objectStore(au),u=o.get(e);let h;u.onsuccess=()=>{if(u.result==null)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const p=o.delete(e),m=()=>{h=s.transaction(zc,"readwrite");const v=h.objectStore(zc).delete(e);v.onsuccess=()=>t(u.result.modelArtifactsInfo),v.onerror=S=>n(u.error)};p.onsuccess=m,p.onerror=y=>(m(),s.close(),n(u.error))}},u.onerror=p=>(s.close(),n(u.error)),a.oncomplete=()=>{h==null?s.close():h.oncomplete=()=>s.close()}},i.onerror=s=>n(i.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rl="/",Dh="tensorflowjs_models",$R="info",_5="model_topology",x5="weight_specs",S5="weight_data",w5="model_metadata";function GR(r){return{info:[Dh,r,$R].join(rl),topology:[Dh,r,_5].join(rl),weightSpecs:[Dh,r,x5].join(rl),weightData:[Dh,r,S5].join(rl),modelMetadata:[Dh,r,w5].join(rl)}}function WR(r){for(const e of Object.values(r))window.localStorage.removeItem(e)}function E5(r){const e=r.split(rl);if(e.length<3)throw new Error(`Invalid key format: ${r}`);return e.slice(1,e.length-1).join(rl)}function b5(r){return r.startsWith(Qc.URL_SCHEME)?r.slice(Qc.URL_SCHEME.length):r}class Qc{constructor(e){if(!Ht().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=GR(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),i=km(e),s=ka.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(i)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,s5(s));const a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:i}}catch{throw WR(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${i.modelTopologyBytes}, weightSpecsBytes=${i.weightSpecsBytes}, weightDataBytes=${i.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const i=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(i==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=i;const s=this.LS.getItem(this.keys.modelMetadata);if(s!=null){const o=JSON.parse(s);t.format=o.format,t.generatedBy=o.generatedBy,t.convertedBy=o.convertedBy,o.signature!=null&&(t.signature=o.signature),o.userDefinedMetadata!=null&&(t.userDefinedMetadata=o.userDefinedMetadata),o.modelInitializer!=null&&(t.modelInitializer=o.modelInitializer),o.initializerSignature!=null&&(t.initializerSignature=o.initializerSignature),o.trainingConfig!=null&&(t.trainingConfig=o.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=a5(a),t}}Qc.URL_SCHEME="localstorage://";const jR=r=>Ht().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(Qc.URL_SCHEME)?T5(r.slice(Qc.URL_SCHEME.length)):null;rr.registerSaveRouter(jR);rr.registerLoadRouter(jR);function T5(r){return new Qc(r)}class M5{constructor(){j(Ht().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),j(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=Dh+rl,n=rl+$R;for(let i=0;i<this.LS.length;++i){const s=this.LS.key(i);if(s.startsWith(t)&&s.endsWith(n)){const a=E5(s);e[a]=JSON.parse(this.LS.getItem(s))}}return e}async removeModel(e){e=b5(e);const t=GR(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const n=JSON.parse(this.LS.getItem(t.info));return WR(t),n}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $h="://";class bi{constructor(){this.managers={}}static getInstance(){return bi.instance==null&&(bi.instance=new bi),bi.instance}static registerManager(e,t){j(e!=null,()=>"scheme must not be undefined or null."),e.endsWith($h)&&(e=e.slice(0,e.indexOf($h))),j(e.length>0,()=>"scheme must not be an empty string.");const n=bi.getInstance();j(n.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),n.managers[e]=t}static getManager(e){const t=bi.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(bi.getInstance().managers)}}function Hy(r){if(r.indexOf($h)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${bi.getSchemes().join(",")}`);return{scheme:r.split($h)[0],path:r.split($h)[1]}}async function qR(r,e,t=!1){j(r!==e,()=>`Old path and new path are the same: '${r}'`);const n=rr.getLoadHandlers(r);j(n.length>0,()=>`Copying failed because no load handler is found for source URL ${r}.`),j(n.length<2,()=>`Copying failed because more than one (${n.length}) load handlers for source URL ${r}.`);const i=n[0],s=rr.getSaveHandlers(e);j(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),j(s.length<2,()=>`Copying failed because more than one (${n.length}) save handlers for destination URL ${e}.`);const a=s[0],o=Hy(r).scheme,u=Hy(r).path,h=o===Hy(r).scheme,p=await i.load();t&&h&&await bi.getManager(o).removeModel(u);const m=await a.save(p);return t&&!h&&await bi.getManager(o).removeModel(u),m.modelArtifactsInfo}async function A5(){const r=bi.getSchemes(),e={};for(const t of r){const n=await bi.getManager(t).listModels();for(const i in n){const s=t+$h+i;e[s]=n[i]}}return e}async function N5(r){const e=Hy(r);return bi.getManager(e.scheme).removeModel(e.path)}async function C5(r,e){return qR(r,e,!1)}async function R5(r,e){return qR(r,e,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class I5{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!Ht().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",n=>{if(n.source===window&&n.data.name===this.messageName){n.stopPropagation();const i=this.functionRefs[n.data.index];i(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return SR(e)}}if(Ht().get("IS_BROWSER")){Ht().setPlatform("browser",new I5);try{bi.registerManager(Qc.URL_SCHEME,new M5)}catch{}try{bi.registerManager(Jc.URL_SCHEME,new v5)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P5={importFetch:()=>require("node-fetch")};let j_;class L5{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return Ht().global.fetch!=null?Ht().global.fetch(e,t):(j_==null&&(j_=P5.importFetch()),j_(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}Ht().get("IS_NODE")&&!Ht().get("IS_BROWSER")&&Ht().setPlatform("node",new L5);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ao(r,e="float32",t){return e=e||"float32",gs(r),new u0(r,e,t)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k5(r,e){const t=H(r,"x","cast");if(!b2(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const n={x:t},i={dtype:e};return ie.runKernel(m1,n,i)}const $n=ne({cast_:k5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D5(r){const t={x:H(r,"x","clone","string_or_numeric")};return ie.runKernel(y1,t)}const al=ne({clone_:D5});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T1(r,e=!1){console.log(r.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */PR();const O5={buffer:ao,cast:$n,clone:al,print:T1};TH(O5);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F5(r,e){let t=H(r,"a","add"),n=H(e,"b","add");[t,n]=ir(t,n);const i={a:t,b:n};return ie.runKernel(p1,i)}const Vt=ne({add_:F5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U5(r,e){let t=H(r,"a","floorDiv"),n=H(e,"b","floorDiv");[t,n]=ir(t,n);const i={a:t,b:n};return ie.runKernel(IN,i)}const M1=ne({floorDiv_:U5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z5(r,e){let t=H(r,"a","div"),n=H(e,"b","div");if([t,n]=ir(t,n),t.dtype==="int32"&&n.dtype==="int32")return M1(t,n);const i={a:t,b:n},s={};return ie.runKernel(_N,i,s)}const Vn=ne({div_:z5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B5(r,e){let t=H(r,"a","mul"),n=H(e,"b","mul");[t,n]=ir(t,n);const i={a:t,b:n};return ie.runKernel(uC,i)}const st=ne({mul_:B5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V5(r){const e=H(r,"x","abs");if(e.dtype==="complex64"){const t={x:e};return ie.runKernel(eN,t)}else{const t={x:e};return ie.runKernel(I2,t)}}const cs=ne({abs_:V5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H5(r){const t={x:H(r,"x","acos")};return ie.runKernel(P2,t)}const XR=ne({acos_:H5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $5(r){const t={x:H(r,"x","acosh")};return ie.runKernel(L2,t)}const KR=ne({acosh_:$5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G5(r){j(Array.isArray(r),()=>"The argument passed to tf.addN() must be a list of tensors"),j(r.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${r.length}`);const e=r.map((i,s)=>H(i,`tensors${s}`,"addN")),t=e[0];e.forEach(i=>{if(i.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(i=>{if(!Ra(i.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const n=e;return ie.runKernel(k2,n)}const YR=ne({addN_:G5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W5(r,e=null,t=!1){const i={x:H(r,"x","all","bool")},s={axis:e,keepDims:t};return ie.runKernel(D2,i,s)}const ZR=ne({all_:W5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j5(r,e=null,t=!1){const i={x:H(r,"x","any","bool")},s={axis:e,keepDims:t};return ie.runKernel(O2,i,s)}const JR=ne({any_:j5});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q5(r,e=0){const n={x:H(r,"x","argMax")},i={axis:e};return ie.runKernel(F2,n,i)}const QR=ne({argMax_:q5});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X5(r,e=0){const n={x:H(r,"x","argMin")},i={axis:e};return ie.runKernel(U2,n,i)}const eI=ne({argMin_:X5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K5(r){const t={x:H(r,"x","asin")};return ie.runKernel(z2,t)}const tI=ne({asin_:K5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y5(r){const t={x:H(r,"x","asinh")};return ie.runKernel(B2,t)}const nI=ne({asinh_:Y5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z5(r){const t={x:H(r,"x","atan")};return ie.runKernel(V2,t)}const rI=ne({atan_:Z5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J5(r,e){let t=H(r,"a","atan2"),n=H(e,"b","atan2");[t,n]=ir(t,n);const i={a:t,b:n};return ie.runKernel($2,i)}const iI=ne({atan2_:J5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q5(r){const t={x:H(r,"x","atanh")};return ie.runKernel(H2,t)}const sI=ne({atanh_:Q5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e$(r,e,t,n,i="NHWC",s){const a=r[3],o=[...e,a],u=lI(i);return Dm(r,o,t,s,n,null,null,u)}function aI(r,e,t,n,i,s,a="channelsLast"){const[o,u]=fm(e);let h;if(a==="channelsLast")h=[o,u,r[3],r[3]];else if(a==="channelsFirst")h=[o,u,r[1],r[1]];else throw new Error(`Unknown dataFormat ${a}`);return Dm(r,h,t,n,i,s,!1,a)}function t$(r,e,t,n,i,s,a="NDHWC"){const[o,u,h]=sS(e);let p,m;if(a==="NDHWC")m="channelsLast",p=[o,u,h,r[4],r[4]];else if(a==="NCDHW")m="channelsFirst",p=[o,u,h,r[1],r[1]];else throw new Error(`Unknown dataFormat ${a}`);return oI(r,p,t,n,i,!1,m,s)}function Dm(r,e,t,n,i,s,a=!1,o="channelsLast"){let[u,h,p,m]=[-1,-1,-1,-1];if(o==="channelsLast")[u,h,p,m]=r;else if(o==="channelsFirst")[u,m,h,p]=r;else throw new Error(`Unknown dataFormat ${o}`);const[y,v,,S]=e,[T,E]=fm(t),[w,C]=fm(n),A=Gh(y,w),I=Gh(v,C),{padInfo:F,outHeight:U,outWidth:V}=i$(i,h,p,T,E,A,I,s,o),G=a?S*m:S;let L;return o==="channelsFirst"?L=[u,G,U,V]:o==="channelsLast"&&(L=[u,U,V,G]),{batchSize:u,dataFormat:o,inHeight:h,inWidth:p,inChannels:m,outHeight:U,outWidth:V,outChannels:G,padInfo:F,strideHeight:T,strideWidth:E,filterHeight:y,filterWidth:v,effectiveFilterHeight:A,effectiveFilterWidth:I,dilationHeight:w,dilationWidth:C,inShape:r,outShape:L,filterShape:e}}function oI(r,e,t,n,i,s=!1,a="channelsLast",o){let[u,h,p,m,y]=[-1,-1,-1,-1,-1];if(a==="channelsLast")[u,h,p,m,y]=r;else if(a==="channelsFirst")[u,y,h,p,m]=r;else throw new Error(`Unknown dataFormat ${a}`);const[v,S,T,,E]=e,[w,C,A]=sS(t),[I,F,U]=sS(n),V=Gh(v,I),G=Gh(S,F),L=Gh(T,U),{padInfo:k,outDepth:O,outHeight:Q,outWidth:le}=s$(i,h,p,m,w,C,A,V,G,L,o),K=s?E*y:E;let ce;return a==="channelsFirst"?ce=[u,K,O,Q,le]:a==="channelsLast"&&(ce=[u,O,Q,le,K]),{batchSize:u,dataFormat:a,inDepth:h,inHeight:p,inWidth:m,inChannels:y,outDepth:O,outHeight:Q,outWidth:le,outChannels:K,padInfo:k,strideDepth:w,strideHeight:C,strideWidth:A,filterDepth:v,filterHeight:S,filterWidth:T,effectiveFilterDepth:V,effectiveFilterHeight:G,effectiveFilterWidth:L,dilationDepth:I,dilationHeight:F,dilationWidth:U,inShape:r,outShape:ce,filterShape:e}}function n$(r,e,t,n,i){n==null&&(n=A1(r,e,t));const s=r[0],a=r[1],o=hm((s-e+2*n)/t+1,i),u=hm((a-e+2*n)/t+1,i);return[o,u]}function r$(r,e,t,n,i,s){i==null&&(i=A1(r,e[0],n[0]));const a=[0,0,0,t];for(let o=0;o<3;o++)r[o]+2*i>=e[o]&&(a[o]=hm((r[o]-e[o]+2*i)/n[o]+1,s));return a}function A1(r,e,t,n=1){const i=Gh(e,n);return Math.floor((r[0]*(t-1)-t+i)/2)}function fm(r){return typeof r=="number"?[r,r,r]:r.length===2?[r[0],r[1],1]:r}function sS(r){return typeof r=="number"?[r,r,r]:r}function Gh(r,e){return e<=1?r:r+(r-1)*(e-1)}function i$(r,e,t,n,i,s,a,o,u){let h,p,m;if(typeof r=="number"){h={top:r,bottom:r,left:r,right:r,type:r===0?"VALID":"NUMBER"};const v=n$([e,t],s,n,r,o);p=v[0],m=v[1]}else if(r==="same"){p=Math.ceil(e/n),m=Math.ceil(t/i);const y=Math.max(0,(p-1)*n+s-e),v=Math.max(0,(m-1)*i+a-t),S=Math.floor(y/2),T=y-S,E=Math.floor(v/2),w=v-E;h={top:S,bottom:T,left:E,right:w,type:"SAME"}}else if(r==="valid")h={top:0,bottom:0,left:0,right:0,type:"VALID"},p=Math.ceil((e-s+1)/n),m=Math.ceil((t-a+1)/i);else if(typeof r=="object"){const y=u==="channelsLast"?r[1][0]:r[2][0],v=u==="channelsLast"?r[1][1]:r[2][1],S=u==="channelsLast"?r[2][0]:r[3][0],T=u==="channelsLast"?r[2][1]:r[3][1];h={top:y,bottom:v,left:S,right:T,type:y===0&&v===0&&S===0&&T===0?"VALID":"EXPLICIT"},p=hm((e-s+y+v)/n+1,o),m=hm((t-a+S+T)/i+1,o)}else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:h,outHeight:p,outWidth:m}}function s$(r,e,t,n,i,s,a,o,u,h,p){let m,y,v,S;if(r==="valid"&&(r=0),typeof r=="number"){m={top:r,bottom:r,left:r,right:r,front:r,back:r,type:r===0?"VALID":"NUMBER"};const E=r$([e,t,n,1],[o,u,h],1,[i,s,a],r,p);y=E[0],v=E[1],S=E[2]}else if(r==="same"){y=Math.ceil(e/i),v=Math.ceil(t/s),S=Math.ceil(n/a);const T=(y-1)*i+o-e,E=(v-1)*s+u-t,w=(S-1)*a+h-n,C=Math.floor(T/2),A=T-C,I=Math.floor(E/2),F=E-I,U=Math.floor(w/2),V=w-U;m={top:I,bottom:F,left:U,right:V,front:C,back:A,type:"SAME"}}else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:m,outDepth:y,outHeight:v,outWidth:S}}function hm(r,e){if(!e)return Math.trunc(r);switch(e){case"round":return Math.round(r);case"ceil":return Math.ceil(r);case"floor":return Math.floor(r);default:throw new Error(`Unknown roundingMode ${e}`)}}function dm(r){const[e,t,n]=fm(r);return e===1&&t===1&&n===1}function dl(r,e){return dm(r)||dm(e)}function ef(r){return fm(r).every(e=>e>0)}function lI(r){if(r==="NHWC")return"channelsLast";if(r==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${r}`)}function qs(r,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${r}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")j(Jh(e),()=>`Error in ${r}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(n=>{n.forEach(i=>{j(Jh(i),()=>`Error in ${r}: pad must be an integer when using dimRoundingMode ${t} but got pad ${i}.`)})});else throw Error(`Error in ${r}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a$(r,e){const n={x:H(r,"x","reshape","string_or_numeric")},i={shape:e};return ie.runKernel(CC,n,i)}const Le=ne({reshape_:a$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o$(r,e,t,n,i){const s=H(r,"x","avgPool","float32"),a=1;j(dl(t,a),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`);let o=s,u=!1;s.rank===3&&(u=!0,o=Le(s,[1,s.shape[0],s.shape[1],s.shape[2]])),j(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),qs("avgPool",n,i);const h={x:o},p={filterSize:e,strides:t,pad:n,dimRoundingMode:i};let m=ie.runKernel(G2,h,p);return m=$n(m,s.dtype),u?Le(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const N1=ne({avgPool_:o$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l$(r,e,t,n,i,s="NDHWC"){const a=H(r,"x","avgPool3d","float32");let o=a,u=!1;a.rank===4&&(u=!0,o=Le(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),j(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),j(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),j(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),qs("avgPool3d",n,i);const h={x:o},p={filterSize:e,strides:t,pad:n,dimRoundingMode:i,dataFormat:s};let m=ie.runKernel(W2,h,p);return m=$n(m,o.dtype),u?Le(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const uI=ne({avgPool3d_:l$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u$(r,e=0){j(r.length>=1,()=>"Pass at least one tensor to concat");const t=cm(r,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),t.length===1)return al(t[0]);const n=t,i={axis:e};return ie.runKernel(tN,n,i)}const di=ne({concat_:u$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c$(r,e,t=!1,n=!1){let i=H(r,"a","matMul"),s=H(e,"b","matMul");[i,s]=ir(i,s);const a={a:i,b:s},o={transposeA:t,transposeB:n};return ie.runKernel(j2,a,o)}const En=ne({matMul_:c$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f$(r){const t={x:H(r,"x","sigmoid","float32")};return ie.runKernel(WC,t)}const Wc=ne({sigmoid_:f$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h$(r,e,t){const n=H(r,"x","slice","string_or_numeric");if(n.rank===0)throw new Error("Slicing scalar is not possible");const i={x:n},s={begin:e,size:t};return ie.runKernel(VC,i,s)}const On=ne({slice_:h$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d$(r){const t={x:H(r,"x","tanh","float32")};return ie.runKernel(fR,t)}const f0=ne({tanh_:d$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p$(r,e,t,n,i,s){const a=H(r,"forgetBias","basicLSTMCell"),o=H(e,"lstmKernel","basicLSTMCell"),u=H(t,"lstmBias","basicLSTMCell"),h=H(n,"data","basicLSTMCell"),p=H(i,"c","basicLSTMCell"),m=H(s,"h","basicLSTMCell"),y=di([h,m],1),v=En(y,o),S=Vt(v,u),T=S.shape[0],E=S.shape[1]/4,w=[T,E],C=On(S,[0,0],w),A=On(S,[0,E],w),I=On(S,[0,E*2],w),F=On(S,[0,E*3],w),U=Vt(st(Wc(C),f0(A)),st(p,Wc(Vt(a,I)))),V=st(f0(U),Wc(F));return[U,V]}const cI=ne({basicLSTMCell_:p$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m$(r,e,t){const n=H(r,"x","batchToSpaceND"),i=e.reduce((o,u)=>o*u);j(n.rank>=1+e.length,()=>`input rank is ${n.rank} but should be > than blockShape.length ${e.length}`),j(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),j(n.shape[0]%i===0,()=>`input tensor batch is ${n.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${i}`);const s={x:n},a={blockShape:e,crops:t};return ie.runKernel(q2,s,a)}const C1=ne({batchToSpaceND_:m$});function g$(r){let e;return r.rank===0||r.rank===1?e=Le(r,[1,1,1,r.size]):r.rank===2?e=Le(r,[1,1,r.shape[0],r.shape[1]]):r.rank===3?e=Le(r,[1,r.shape[0],r.shape[1],r.shape[2]]):e=r,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y$(r,e,t,n,i,s){s==null&&(s=.001);const a=H(r,"x","batchNorm"),o=H(e,"mean","batchNorm"),u=H(t,"variance","batchNorm");let h;i!=null&&(h=H(i,"scale","batchNorm"));let p;n!=null&&(p=H(n,"offset","batchNorm")),j(o.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),j(p==null||o.rank===p.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),j(h==null||o.rank===h.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const y={x:g$(a),scale:h,offset:p,mean:o,variance:u},v={varianceEpsilon:s},S=ie.runKernel(PN,y,v);return Le(S,a.shape)}const Om=ne({batchNorm_:y$});function v$(r,e,t,n,i,s){const a=H(r,"x","batchNorm"),o=H(e,"mean","batchNorm"),u=H(t,"variance","batchNorm");let h;i!=null&&(h=H(i,"scale","batchNorm"));let p;return n!=null&&(p=H(n,"offset","batchNorm")),j(a.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`),j(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),j(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),h!=null&&j(h.rank===2||h.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${h.rank}.`),p!=null&&j(p.rank===2||p.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${p.rank}.`),Om(a,o,u,p,h,s)}const fI=ne({batchNorm2d_:v$});function _$(r,e,t,n,i,s){const a=H(r,"x","batchNorm"),o=H(e,"mean","batchNorm"),u=H(t,"variance","batchNorm");let h;i!=null&&(h=H(i,"scale","batchNorm"));let p;return n!=null&&(p=H(n,"offset","batchNorm")),j(a.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`),j(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),j(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),h!=null&&j(h.rank===3||h.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${h.rank}.`),p!=null&&j(p.rank===3||p.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${p.rank}.`),Om(a,o,u,p,h,s)}const hI=ne({batchNorm3d_:_$});function x$(r,e,t,n,i,s){const a=H(r,"x","batchNorm"),o=H(e,"mean","batchNorm"),u=H(t,"variance","batchNorm");let h;i!=null&&(h=H(i,"scale","batchNorm"));let p;return n!=null&&(p=H(n,"offset","batchNorm")),j(a.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`),j(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),j(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),h!=null&&j(h.rank===4||h.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${h.rank}.`),p!=null&&j(p.rank===4||p.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${p.rank}.`),Om(a,o,u,p,h,s)}const dI=ne({batchNorm4d_:x$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S$(r,e,t){const n=H(r,"x","bincount"),i=H(e,"weights","bincount");j(n.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${n.dtype}`),j(t>=0,()=>`size must be non-negative, but got ${t}.`),j(i.size===n.size||i.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${n.shape}, weights shape: ${i.shape}.`);const s={x:n,weights:i},a={size:t};return ie.runKernel(X2,s,a)}const R1=ne({bincount_:S$});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w$(r,e){const t=H(r,"x","bitwiseAnd"),n=H(e,"y","bitwiseAnd");if(!Ra(t.shape,n.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${t.shape}, y: ${n.shape}`);if(t.dtype!=="int32"||n.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${t.dtype} and type of y: ${n.dtype}`);const i={a:t,b:n};return ie.runKernel(K2,i)}const pI=ne({bitwiseAnd_:w$});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E$(r,e){const t=H(r,"s0","broadcastArgs","int32"),n=H(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(n.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${n.rank}`);const i={s0:t,s1:n};return ie.runKernel(Y2,i)}const mI=ne({broadcastArgs_:E$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b$(r,e){let t=H(r,"broadcastTo","x");const n=t.shape;if(gs(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const h=t.shape.slice();for(;h.length<e.length;)h.unshift(1);t=Le(t,h)}const i=t.shape,s=Array.from(e);for(let h=e.length-1;h>=0;h--)if(i[h]===e[h])s[h]=1;else if(t.shape[h]!==1)throw new Error(`broadcastTo(): [${n}] cannot be broadcast to [${e}].`);if(s.map((h,p)=>h>1?p:-1).filter(h=>h>=0).length===0)return al(t);const o={x:t},u={reps:s};return ie.runKernel(v1,o,u)}const Op=ne({broadcastTo_:b$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T$(r){const t={x:H(r,"x","ceil","float32")};return ie.runKernel(Z2,t)}const gI=ne({ceil_:T$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fd(r,e,t){gs(r),t=t||Im(e);const n={shape:r,value:e,dtype:t};return ie.runKernel(NN,{},n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M$(r,e,t){const n=H(r,"x","clipByValue");if(j(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return fd(n.shape,e,n.dtype);const i={x:n},s={clipValueMin:e,clipValueMax:t};return ie.runKernel(J2,i,s)}const yI=ne({clipByValue_:M$});function A$(r){return di(r,0)}const vI=ne({concat1d_:A$});function N$(r,e){return di(r,e)}const _I=ne({concat2d_:N$});function C$(r,e){return di(r,e)}const xI=ne({concat3d_:C$});function R$(r,e){return di(r,e)}const SI=ne({concat4d_:R$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I$(r,e,t,n,i="NHWC",s=[1,1],a){const o=H(r,"x","conv2d","float32"),u=H(e,"filter","conv2d","float32");let h=o,p=!1;o.rank===3&&(p=!0,h=Le(o,[1,o.shape[0],o.shape[1],o.shape[2]])),j(h.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${h.rank}.`),j(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),qs("conv2d",n,a);const m=i==="NHWC"?h.shape[3]:h.shape[1];j(m===u.shape[2],()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${u.shape[2]}.`),j(dl(t,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),j(ef(s),()=>"Error in conv2D: Dilated rates should be larger than 0."),j(ef(t),()=>"Error in conv2D: Strides should be larger than 0.");const y={x:h,filter:u},v={strides:t,pad:n,dataFormat:i,dilations:s,dimRoundingMode:a},S=ie.runKernel(nN,y,v);return p?Le(S,[S.shape[1],S.shape[2],S.shape[3]]):S}const Fm=ne({conv2d_:I$});function P$(r,e,t,n,i="NWC",s=1,a){const o=H(r,"x","conv1d"),u=H(e,"filter","conv1d");let h=o,p=!1;o.rank===2&&(p=!0,h=Le(o,[1,o.shape[0],o.shape[1]])),j(h.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${h.rank}.`),j(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),qs("conv1d",n,a),j(h.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${h.shape[2]}) must match input depth for filter ${u.shape[1]}.`),j(dl(t,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${s}'`),j(ef(s),()=>"Error in conv1D: Dilated rates should be larger than 0."),j(ef(t),()=>"Error in conv1D: Stride should be larger than 0."),j(i==="NWC",()=>`Error in conv1d: got dataFormat of ${i} but only NWC is currently supported.`);const m=Le(u,[1,u.shape[0],u.shape[1],u.shape[2]]),y=Le(h,[h.shape[0],1,h.shape[1],h.shape[2]]),E=Fm(y,m,[1,t],n,"NHWC",[1,s],a);return p?Le(E,[E.shape[2],E.shape[3]]):Le(E,[E.shape[0],E.shape[2],E.shape[3]])}const wI=ne({conv1d_:P$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L$(r,e,t,n,i,s="NHWC",a){j(r.length===e.rank,()=>`Length of inShape (${r.length}) and rank of dy (${e.rank}) must match`);let o=r,u=e,h=!1;e.rank===3&&(h=!0,u=Le(e,[1,e.shape[0],e.shape[1],e.shape[2]]),o=[1,r[0],r[1],r[2]]),j(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),j(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),j(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const p=s==="NHWC"?o[3]:o[1],m=s==="NHWC"?u.shape[3]:u.shape[1];j(p===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${p}) must match input depth for filter ${t.shape[2]}.`),j(m===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${m}) must match output depth for filter ${t.shape[3]}.`),qs("conv2dDerInput",i,a);const y={dy:u,filter:t},v={strides:n,pad:i,dataFormat:s,dimRoundingMode:a,inputShape:o},S=ie.runKernel(iN,y,v);return h?Le(S,[S.shape[1],S.shape[2],S.shape[3]]):S}const EI=ne({conv2DBackpropInput_:L$});function k$(r,e,t,n,i,s){const a=H(r,"x","conv2dTranspose"),o=H(e,"filter","conv2dTranspose");return EI(t,a,o,n,i,"NHWC",s)}const bI=ne({conv2dTranspose_:k$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D$(r,e,t,n,i="NDHWC",s=[1,1,1]){const a=H(r,"x","conv3d"),o=H(e,"filter","conv3d");let u=a,h=!1;a.rank===4&&(h=!0,u=Le(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),j(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),j(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),j(u.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${o.shape[3]}.`),j(dl(t,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),j(i==="NDHWC",()=>`Error in conv3d: got dataFormat of ${i} but only NDHWC is currently supported.`),j(ef(s),()=>"Error in conv3D: Dilated rates should be larger than 0."),j(ef(t),()=>"Error in conv3D: Strides should be larger than 0.");const p={x:u,filter:o},m={strides:t,pad:n,dataFormat:i,dilations:s},y=ie.runKernel(sN,p,m);return h?Le(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}const TI=ne({conv3d_:D$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O$(r,e,t,n,i){j(r.length===e.rank,()=>`Length of inShape (${r.length}) and rank of dy (${e.rank}) must match`);let s=r,a=e,o=!1;e.rank===4&&(o=!0,a=Le(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),s=[1,r[0],r[1],r[2],r[3]]);const u=s[4],h=a.shape[4];j(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),j(a.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`),j(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),j(u===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${t.shape[3]}.`),j(h===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${h}) must match output depth for filter ${t.shape[4]}.`);const p={dy:a,filter:t},m={pad:i,strides:n,inputShape:s},y=ie.runKernel(aN,p,m);return o?Le(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}const F$=ne({conv3DBackpropInput_:O$});function U$(r,e,t,n,i){const s=H(r,"x","conv3dTranspose"),a=H(e,"filter","conv3dTranspose");return F$(t,s,a,n,i)}const MI=ne({conv3dTranspose_:U$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z$(r){const t={x:H(r,"x","cos","float32")};return ie.runKernel(oN,t)}const AI=ne({cos_:z$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B$(r){const t={x:H(r,"x","cosh","float32")};return ie.runKernel(lN,t)}const NI=ne({cosh_:B$});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V$(r,e=0,t=!1,n=!1){const s={x:H(r,"x","cumprod")},a={axis:e,exclusive:t,reverse:n};return ie.runKernel(uN,s,a)}const CI=ne({cumprod_:V$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H$(r,e=0,t=!1,n=!1){const s={x:H(r,"x","cumsum")},a={axis:e,exclusive:t,reverse:n};return ie.runKernel(cN,s,a)}const RI=ne({cumsum_:H$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $$(r,e,t,n=!1){const i=H(r,"x","denseBincount"),s=H(e,"weights","denseBincount");j(i.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${i.dtype}`),j(i.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${i.rank}.`),j(t>=0,()=>`size must be non-negative, but got ${t}.`),j(s.size===i.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${i.shape}, weights shape: ${s.shape}.`);const a={x:i,weights:s},o={size:t,binaryOutput:n};return ie.runKernel(hN,a,o)}const II=ne({denseBincount_:$$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G$(r,e,t="NHWC"){const n=H(r,"x","depthToSpace","float32"),i=t==="NHWC"?n.shape[1]:n.shape[2],s=t==="NHWC"?n.shape[2]:n.shape[3],a=t==="NHWC"?n.shape[3]:n.shape[1];j(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),j(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${e}  for depthToSpace with input shape
    ${n.shape}`),j(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e} for depthToSpace with input shape
        ${n.shape}`),j(a%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${a} for depthToSpace with input shape ${n.shape}`);const o={x:n},u={blockSize:e,dataFormat:t};return ie.runKernel(dN,o,u)}const PI=ne({depthToSpace_:G$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W$(r,e,t,n,i="NHWC",s=[1,1],a){const o=H(r,"x","depthwiseConv2d","float32"),u=H(e,"filter","depthwiseConv2d","float32");let h=o,p=!1;o.rank===3&&(p=!0,h=Le(o,[1,o.shape[0],o.shape[1],o.shape[2]])),j(h.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${h.rank}.`),j(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);const m=i==="NHWC"?h.shape[3]:h.shape[1];j(m===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${m}) must match the inChannels dimension in filter ${u.shape[2]}.`),qs("depthwiseConv2d",n,a);const y={x:h,filter:u},v={strides:t,pad:n,dataFormat:i,dilations:s,dimRoundingMode:a},S=ie.runKernel(pN,y,v);return p?Le(S,[S.shape[1],S.shape[2],S.shape[3]]):S}const J0=ne({depthwiseConv2d_:W$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j$(r){const t={x:H(r,"x","diag")};return ie.runKernel(yN,t)}const LI=ne({diag_:j$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q$(r,e,t,n,i=[1,1],s="NHWC"){const a=H(r,"x","dilation2d"),o=H(e,"filter","dilation2d");j(a.rank===3||a.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),j(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),j(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let u=a,h=!1;a.rank===3&&(u=Le(a,[1,a.shape[0],a.shape[1],a.shape[2]]),h=!0),j(u.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${u.shape[3]} vs ${o.shape[2]}`);const p={x:u,filter:o},m={strides:t,pad:n,dilations:i},y=ie.runKernel(vN,p,m);return h?Le(y,[y.shape[1],y.shape[2],y.shape[3]]):y}const kI=ne({dilation2d_:q$});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DI(r,e){const t=r.length,n=[];for(let i=0;i<t;i++){const s=t-1-i,a=r[s]||1;(e[e.length-1-i]||1)>1&&a===1&&n.unshift(s)}return n}function I1(r,e){const t=[];for(let n=0;n<e.length;n++){const i=r[r.length-n-1],s=e.length-n-1,a=e[s];(i==null||i===1&&a>1)&&t.unshift(s)}return t}function Tr(r,e){const t=Math.max(r.length,e.length),n=new Array(t);for(let i=0;i<t;i++){let s=r[r.length-i-1];s==null&&(s=1);let a=e[e.length-i-1];if(a==null&&(a=1),s===1)n[t-i-1]=a;else if(a===1)n[t-i-1]=s;else if(s!==a){const o=`Operands could not be broadcast together with shapes ${r} and ${e}.`;throw Error(o)}else n[t-i-1]=s}return n}const X$=Object.freeze(Object.defineProperty({__proto__:null,assertAndGetBroadcastShape:Tr,getBroadcastDims:DI,getReductionAxes:I1},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K$(r,e){let t=H(r,"a","equal","string_or_numeric"),n=H(e,"b","equal","string_or_numeric");[t,n]=ir(t,n),Tr(t.shape,n.shape);const i={a:t,b:n};return ie.runKernel(EN,i)}const P1=ne({equal_:K$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y$(r,e,t){const n=H(e,"a","where"),i=H(t,"b","where"),s=H(r,"condition","where","bool"),a=Tr(Tr(s.shape,n.shape),i.shape),o=Op(s,a),u=Op(n,a),h=Op(i,a),p={condition:o,t:u,e:h};return ie.runKernel(zC,p)}const ol=ne({where_:Y$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z$(r){const t={x:H(r,"x","zerosLike")};return ie.runKernel(yR,t)}const ps=ne({zerosLike_:Z$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J$(r,e){let t=H(r,"a","div"),n=H(e,"b","div");[t,n]=ir(t,n);const i=Vn(t,n),s=ps(i),a=P1(n,s);return ol(a,s,i)}const OI=ne({divNoNan_:J$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q$(r,e){const t=H(r,"t1","dot"),n=H(e,"t2","dot");j((t.rank===1||t.rank===2)&&(n.rank===1||n.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${n.rank}.`);const i=t.rank===1?t.size:t.shape[1],s=n.rank===1?n.size:n.shape[0];if(j(i===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${i} and ${s}.`),t.rank===1&&n.rank===1){const a=Le(t,[1,-1]),o=Le(n,[-1,1]),u=En(a,o);return Le(u,[])}else if(t.rank===1&&n.rank===2){const a=Le(t,[1,-1]),o=Le(n,[n.shape[0],n.shape[1]]),u=En(a,o);return Le(u,[u.size])}else if(t.rank===2&&n.rank===1){const a=Le(n,[-1,1]),o=En(t,a);return Le(o,[o.size])}else{const a=Le(n,[n.shape[0],n.shape[1]]);return En(t,a)}}const FI=ne({dot_:Q$});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eG(r,...e){const t=e.map((i,s)=>H(i,`tensors${s}`,"einsum")),n={equation:r};return ie.runKernel(xN,t,n)}const Lc=ne({einsum_:eG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tG(r){const t={x:H(r,"x","elu","float32")};return ie.runKernel(SN,t)}const L1=ne({elu_:tG});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nG(r,e){const t=H(r,"x","ensureShape","string_or_numeric");if(!x2(t.shape,e))throw new Error(`EnsureShape: Shape of tensor ${t.shape} is not compatible with expected shape ${e}`);return r}const UI=ne({ensureShape_:nG});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rG(r){let e=H(r,"x","erf");j(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=$n(e,"float32"));const t={x:e};return ie.runKernel(wN,t)}const zI=ne({erf_:rG});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k1(r,e){for(let t=0;t<r.length;++t)if(r[r.length-t-1]!==e-1-t)return!1;return!0}function BI(r,e,t){const n=r.length+e.length,i=[];let s=0,a=0;for(let o=0;o<n;o++)t.indexOf(o)===-1?i.push(r[s++]):i.push(e[a++]);return i}function iG(r,e){const t=[],n=r.length;for(let s=0;s<n;s++)e.indexOf(s)===-1&&t.push(r[s]);const i=e.map(s=>r[s]);return[t,i]}function Um(r,e){const t=e.map(n=>1);return BI(r,t,e)}function sG(r,e,t){j(k1(e,t),()=>`${r} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function aG(r,e){if(k1(r,e))return null;const t=[];for(let n=0;n<e;++n)r.indexOf(n)===-1&&t.push(n);return r.forEach(n=>t.push(n)),t}function oG(r){return r.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function lG(r,e){const t=[];for(let n=e-r;n<e;++n)t.push(n);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uG(r,e=null,t=!1){const i={x:H(r,"x","max")},s={reductionIndices:e,keepDims:t};return ie.runKernel(JN,i,s)}const jc=ne({max_:uG});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cG(r,e=null,t=!1){const i={x:H(r,"x","min")},s={axis:e,keepDims:t};return ie.runKernel(iC,i,s)}const h0=ne({min_:cG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fG(r,e){let t=H(r,"base","pow"),n=H(e,"exp","pow");[t,n]=ir(t,n);const i={a:t,b:n};return ie.runKernel(_C,i)}const td=ne({pow_:fG});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dn(r,e){if((Gr(r)&&e!=="string"||Array.isArray(r))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&Gr(r)&&!(r instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Mu(r,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hG(r){const t={x:H(r,"x","sqrt","float32")};return ie.runKernel(qC,t)}const oo=ne({sqrt_:hG});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dG(r){const e=H(r,"x","square"),t={};return ie.runKernel("Square",{x:e},t)}const js=ne({square_:dG});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pG(r,e=null,t=!1){let n=H(r,"x","sum");n.dtype==="bool"&&(n=$n(n,"int32"));const i={x:n},s={axis:e,keepDims:t};return ie.runKernel(XC,i,s)}const Bn=ne({sum_:pG});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mG(r,e="euclidean",t=null,n=!1){r=H(r,"x","norm");const i=VI(r,e,t);let s=i.shape;if(n){const a=Rm(t,r.shape);s=Um(i.shape,a)}return Le(i,s)}function VI(r,e,t=null){if(r.rank===0)return cs(r);if(r.rank!==1&&t===null)return VI(Le(r,[-1]),e,t);if(r.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return Bn(cs(r),t);if(e===1/0)return jc(cs(r),t);if(e===-1/0)return h0(cs(r),t);if(e==="euclidean"||e===2)return oo(Bn(td(cs(r),dn(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return jc(Bn(cs(r),t[0]),t[1]-1);if(e===1/0)return jc(Bn(cs(r),t[1]),t[0]);if(e===-1/0)return h0(Bn(cs(r),t[1]),t[0]);if(e==="fro"||e==="euclidean")return oo(Bn(js(r),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const zm=ne({norm_:mG});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gG(r,e=null,t=!1){return zm(r,"euclidean",e,t)}const HI=ne({euclideanNorm_:gG});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yG(r){const t={x:H(r,"x","exp")};return ie.runKernel(bN,t)}const xu=ne({exp_:yG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vG(r,e=0){const t=H(r,"x","expandDims","string_or_numeric");j(e<=t.rank,()=>"Axis must be <= rank of the tensor");const n={input:t},i={dim:e};return ie.runKernel(TN,n,i)}const Qo=ne({expandDims_:vG});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _G(r){const t={x:H(r,"x","expm1")};return ie.runKernel(MN,t)}const $I=ne({expm1_:_G});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xG(r,e){const t=H(r,"x","tile","string_or_numeric");j(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const n={x:t},i={reps:e};return ie.runKernel(v1,n,i)}const Wh=ne({tile_:xG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SG(r,e,t,n="float32"){e==null&&(e=r);const i=ao([r,e],n),s=r<=e?r:e;for(let o=0;o<s;++o)i.set(1,o,o);const a=Le(i.toTensor(),[r,e]);if(t==null)return a;if(t.length===1)return Wh(Qo(a,0),[t[0],1,1]);if(t.length===2)return Wh(Qo(Qo(a,0),0),[t[0],t[1],1,1]);if(t.length===3)return Wh(Qo(Qo(Qo(a,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const D1=ne({eye_:SG});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wG(r){const t={x:H(r,"x","floor","float32")};return ie.runKernel(RN,t)}const O1=ne({floor_:wG});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EG(r,e,t=0,n=0){const i=H(r,"x","gather"),s=H(e,"indices","gather","int32"),a={x:i,indices:s},o={axis:t,batchDims:n};return ie.runKernel(LN,a,o)}const F1=ne({gather_:EG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bG(r,e){let t=H(r,"a","greater","string_or_numeric"),n=H(e,"b","greater","string_or_numeric");[t,n]=ir(t,n),Tr(t.shape,n.shape);const i={a:t,b:n};return ie.runKernel(DN,i)}const Bm=ne({greater_:bG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TG(r,e){let t=H(r,"a","greaterEqual","string_or_numeric"),n=H(e,"b","greaterEqual","string_or_numeric");[t,n]=ir(t,n),Tr(t.shape,n.shape);const i={a:t,b:n};return ie.runKernel(ON,i)}const U1=ne({greaterEqual_:TG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MG(r){const t={input:H(r,"input","imag")};return ie.runKernel(UN,t)}const Vm=ne({imag_:MG});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AG(r){const t={x:H(r,"x","isFinite")};return ie.runKernel(zN,t)}const GI=ne({isFinite_:AG});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NG(r){const t={x:H(r,"x","isInf")};return ie.runKernel(BN,t)}const WI=ne({isInf_:NG});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CG(r){const t={x:H(r,"x","isNaN")};return ie.runKernel(VN,t)}const jI=ne({isNaN_:CG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RG(r,e=.2){const n={x:H(r,"x","leakyRelu")},i={alpha:e};return ie.runKernel(HN,n,i)}const z1=ne({leakyRelu_:RG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IG(r,e){let t=H(r,"a","less","string_or_numeric"),n=H(e,"b","less","string_or_numeric");[t,n]=ir(t,n),Tr(t.shape,n.shape);const i={a:t,b:n};return ie.runKernel($N,i)}const d0=ne({less_:IG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PG(r,e){let t=H(r,"a","lessEqual","string_or_numeric"),n=H(e,"b","lessEqual","string_or_numeric");[t,n]=ir(t,n),Tr(t.shape,n.shape);const i={a:t,b:n};return ie.runKernel(GN,i)}const Q0=ne({lessEqual_:PG});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qI(r,e,t){if(t<=0)throw new Error("The number of values should be positive.");const n={start:r,stop:e,num:t};return ie.runKernel(WN,{},n)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LG(r,e=5,t=1,n=1,i=.5){const s=H(r,"x","localResponseNormalization");j(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),j(Jh(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let a=s,o=!1;s.rank===3&&(o=!0,a=Le(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const u={x:a},h={depthRadius:e,bias:t,alpha:n,beta:i},p=ie.runKernel(ZN,u,h);return o?Le(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const XI=ne({localResponseNormalization_:LG});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kG(r){const t={x:H(r,"x","log","float32")};return ie.runKernel(jN,t)}const nd=ne({log_:kG});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DG(r){const t={x:H(r,"x","log1p")};return ie.runKernel(qN,t)}const B1=ne({log1p_:DG});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OG(r){return j(gu(r),()=>"The f passed in grad(f) must be a function"),(e,t)=>{const n=H(e,"x","tf.grad","string_or_numeric"),i=t!=null?H(t,"dy","tf.grad"):null;return ie.tidy(()=>{const{value:s,grads:a}=ie.gradients(()=>r(n),[n],i);return i!=null&&Ii(s.shape,i.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),ev(a),a[0]})}}function FG(r){return j(gu(r),()=>"The f passed in grads(f) must be a function"),(e,t)=>{j(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const n=cm(e,"args","tf.grads","string_or_numeric"),i=t!=null?H(t,"dy","tf.grads"):null;return ie.tidy(()=>{const{value:s,grads:a}=ie.gradients(()=>r(...n),n,i);return i!=null&&Ii(s.shape,i.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),ev(a),a})}}function UG(r){return j(gu(r),()=>"The f passed in valueAndGrad(f) must be a function"),(e,t)=>{j(e instanceof ur,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),j(t==null||t instanceof ur,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:n,value:i}=ie.gradients(()=>r(e),[e],t);return ev(n),{grad:n[0],value:i}}}function zG(r){return j(gu(r),()=>"The f passed in valueAndGrads(f) must be a function"),(e,t)=>{j(Array.isArray(e)&&e.every(i=>i instanceof ur),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),j(t==null||t instanceof ur,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const n=ie.gradients(()=>r(...e),e,t);return t!=null&&Ii(n.value.shape,t.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),ev(n.grads),n}}function KI(r,e){j(gu(r),()=>"The f passed in variableGrads(f) must be a function"),j(e==null||Array.isArray(e)&&e.every(h=>h instanceof um),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const h in ie.registeredVariables)e.push(ie.registeredVariables[h])}const n=t?e.filter(h=>!h.trainable):null,i=e.length;e=e.filter(h=>h.trainable),j(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${i} variables is trainable.`);const s=!0,{value:a,grads:o}=ie.gradients(r,e,null,s);j(o.some(h=>h!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),j(a.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);const u={};return e.forEach((h,p)=>{o[p]!=null&&(u[h.name]=o[p])}),n!=null&&n.forEach(h=>u[h.name]=null),{value:a,grads:u}}function lo(r){return ie.customGrad(r)}function ev(r){if(r.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BG(r){const t={x:H(r,"x","neg")};return ie.runKernel(cC,t)}const Na=ne({neg_:BG});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VG(r){const t={x:H(r,"x","softplus")};return ie.runKernel(jC,t)}const V1=ne({softplus_:VG});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HG(r){const e=H(r,"x","logSigmoid");return lo(n=>({value:Na(V1(Na(n))),gradFunc:a=>st(a,Wc(Na(n)))}))(e)}const YI=ne({logSigmoid_:HG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $G(r,e){let t=H(r,"a","sub"),n=H(e,"b","sub");[t,n]=ir(t,n);const i={a:t,b:n};return ie.runKernel(uR,i)}const sn=ne({sub_:$G});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GG(r,e=-1){const t=H(r,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return lo((i,s)=>{const o=jc(i,e,!0),u=sn(i,o),h=sn($n(u,"float32"),nd(Bn(xu(u),e,!0)));return s([h]),{value:h,gradFunc:(m,y)=>{const[v]=y,S=!0,T=xu(v);return sn(m,st(Bn(m,e,S),T))}}})(t)}const ZI=ne({logSoftmax_:GG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WG(r,e=null,t=!1){const n=H(r,"x","logSumExp"),i=Rm(e,n.shape),s=jc(n,i,!0),a=sn(n,s),o=xu(a),u=Bn(o,i),h=nd(u),p=Vt(Le(s,h.shape),h);if(t){const m=Um(p.shape,i);return Le(p,m)}return p}const H1=ne({logSumExp_:WG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jG(r,e){const t=H(r,"a","logicalAnd","bool"),n=H(e,"b","logicalAnd","bool");Tr(t.shape,n.shape);const i={a:t,b:n};return ie.runKernel(XN,i)}const pm=ne({logicalAnd_:jG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qG(r){const t={x:H(r,"x","logicalNot","bool")};return ie.runKernel(KN,t)}const $1=ne({logicalNot_:qG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XG(r,e){const t=H(r,"a","logicalOr","bool"),n=H(e,"b","logicalOr","bool");Tr(t.shape,n.shape);const i={a:t,b:n};return ie.runKernel(YN,i)}const G1=ne({logicalOr_:XG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KG(r,e){const t=H(r,"a","logicalXor","bool"),n=H(e,"b","logicalXor","bool");return Tr(t.shape,n.shape),pm(G1(r,e),$1(pm(r,e)))}const JI=ne({logicalXor_:KG});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ry=2147483648;function YG(r,e,t="left"){const n=H(r,"sortedSequence","searchSorted"),i=H(e,"values","searchSorted"),s=n.shape[n.shape.length-1],a=i.shape[i.shape.length-1],o=Le(n,[-1,s]),u=Le(i,[-1,a]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Rn(u.shape)>=Ry)throw new Error(`values tensor size must less than ${Ry}`);if(o.shape[1]>=Ry)throw new Error(`trailing dim_size must less than ${Ry} for int32 output type, was ${o.shape[1]}`);const h={sortedSequence:o,values:u},p={side:t};return ie.runKernel(UC,h,p)}const tv=ne({searchSorted_:YG});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QI(r,e){return tv(r,e,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZG(r,e,t,n,i){const s=H(r,"x","maxPool"),a=1;let o=s,u=!1;s.rank===3&&(u=!0,o=Le(s,[1,s.shape[0],s.shape[1],s.shape[2]])),j(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),j(dl(t,a),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),qs("maxPool",n,i);const h={x:o},p={filterSize:e,strides:t,pad:n,dimRoundingMode:i},m=ie.runKernel(eC,h,p);return u?Le(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const W1=ne({maxPool_:ZG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JG(r,e=[1,1,1],t,n,i,s="NDHWC"){const a=H(r,"x","maxPool3d");let o=a,u=!1;a.rank===4&&(u=!0,o=Le(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),j(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),j(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),qs("maxPool3d",n,i);const h={x:o},p={filterSize:e,strides:t,pad:n,dimRoundingMode:i,dataFormat:s},m=ie.runKernel(tC,h,p);return u?Le(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const eP=ne({maxPool3d_:JG});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QG(r,e,t,n,i=!1){const a={x:H(r,"x","maxPoolWithArgmax")},o={filterSize:e,strides:t,pad:n,includeBatchInIndex:i},u=ie.runKernel(nC,a,o);return{result:u[0],indexes:u[1]}}const tP=ne({maxPoolWithArgmax_:QG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eW(r,e){let t=H(r,"a","maximum"),n=H(e,"b","maximum");[t,n]=ir(t,n),t.dtype==="bool"&&(t=$n(t,"int32"),n=$n(n,"int32")),Tr(t.shape,n.shape);const i={a:t,b:n};return ie.runKernel(QN,i)}const j1=ne({maximum_:eW});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tW(r,e=null,t=!1){const i={x:H(r,"x","mean")},s={axis:e,keepDims:t};return ie.runKernel(rC,i,s)}const mm=ne({mean_:tW});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tf(r,e="float32"){if(gs(r),e==="complex64"){const n=tf(r,"float32"),i=tf(r,"float32");return fl(n,i)}const t=K0(Rn(r),e);return ie.makeTensor(t,r,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ou(r,e="float32"){if(gs(r),e==="complex64"){const n=ou(r,"float32"),i=tf(r,"float32");return fl(n,i)}const t=f1(Rn(r),e);return ie.makeTensor(t,r,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nP(r,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(r===void 0)return[];let n=H(r,"x","meshgrid",r instanceof ur?r.dtype:"float32");if(e===void 0)return[n];let i=H(e,"y","meshgrid",e instanceof ur?e.dtype:"float32");const s=Rn(n.shape),a=Rn(i.shape);return t==="xy"?(n=Le(n,[1,-1]),i=Le(i,[-1,1]),[En(ou([a,1],n.dtype),n),En(i,ou([1,s],i.dtype))]):(n=Le(n,[-1,1]),i=Le(i,[1,-1]),[En(n,ou([1,a],n.dtype)),En(ou([s,1],i.dtype),i)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nW(r,e){let t=H(r,"a","minimum"),n=H(e,"b","minimum");[t,n]=ir(t,n),t.dtype==="bool"&&(t=$n(t,"int32"),n=$n(n,"int32")),Tr(t.shape,n.shape);const i={a:t,b:n};return ie.runKernel(sC,i)}const gm=ne({minimum_:nW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rW(r,e,t){j(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const n=H(r,"x","mirrorPad");if(n.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");j(e.length===n.rank,()=>`Padding doesn't match input. Must be ${n.rank}. Got ${e.length}.`);const i=t==="reflect"?1:0;for(let o=0;o<n.rank;o++)j(e[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),j(e[o][0]>=0&&e[o][0]<=n.shape[o]-i&&e[o][1]>=0&&e[o][1]<=n.shape[o]-i,()=>`Padding in dimension ${o} cannot be greater than or equal to ${n.shape[o]-i} or less than 0 for input of shape ${n.shape}`);const s={paddings:e,mode:t},a={x:n};return ie.runKernel(aC,a,s)}const rP=ne({mirrorPad_:rW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iW(r,e){let t=H(r,"a","mod"),n=H(e,"b","mod");[t,n]=ir(t,n);const i={a:t,b:n};return ie.runKernel(oC,i)}const iP=ne({mod_:iW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sW(r,e=null,t=!1){r=H(r,"x","moments");const n=Rm(e,r.shape),i=mm(r,n,t);let s=i.shape;t||(s=Um(i.shape,n));const a=js(sn($n(r,"float32"),Le(i,s))),o=mm(a,n,t);return{mean:i,variance:o}}const sP=ne({moments_:sW});function aW(r,e,t,n){const i=H(e,"data","multiRNNCell"),s=cm(t,"c","multiRNNCell"),a=cm(n,"h","multiRNNCell");let o=i;const u=[];for(let m=0;m<r.length;m++){const y=r[m](o,s[m],a[m]);u.push(y[0]),u.push(y[1]),o=y[1]}const h=[],p=[];for(let m=0;m<u.length;m+=2)h.push(u[m]),p.push(u[m+1]);return[h,p]}const aP=ne({multiRNNCell_:aW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oW(r,e,t,n=!1){const i=H(r,"logits","multinomial"),s=i.size,a=i.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(a>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`);t=t||Math.random();const u={logits:a===1?Le(i,[1,-1]):i},h={numSamples:e,seed:t,normalized:n},p=ie.runKernel(lC,u,h);return a===1?Le(p,[p.size]):p}const oP=ne({multinomial_:oW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lW(r,e){let t=H(r,"a","notEqual","string_or_numeric"),n=H(e,"b","notEqual","string_or_numeric");[t,n]=ir(t,n),Tr(t.shape,n.shape);const i={a:t,b:n};return ie.runKernel(fC,i)}const q1=ne({notEqual_:lW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uW(r,e,t=1,n=0,i="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const a={indices:H(r,"indices","oneHot","int32")},o={dtype:i,depth:e,onValue:t,offValue:n};return ie.runKernel(gC,a,o)}const p0=ne({oneHot_:uW});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cW(r){const t={x:H(r,"x","onesLike")};return ie.runKernel(mC,t)}const lP=ne({onesLike_:cW});function fW(r,e){const t=H(r,"v1","outerProduct"),n=H(e,"v2","outerProduct");j(t.rank===1&&n.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${n.rank}.`);const i=Le(t,[-1,1]),s=Le(n,[1,-1]);return En(i,s)}const uP=ne({outerProduct_:fW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hW(r,e,t=0){const n=H(r,"x","pad");if(n.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const i={paddings:e,constantValue:t},s={x:n};return ie.runKernel(vC,s,i)}const hd=ne({pad_:hW});function dW(r,e,t=0){return j(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),hd(r,[e],t)}const cP=ne({pad1d_:dW});function pW(r,e,t=0){return j(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),hd(r,e,t)}const fP=ne({pad2d_:pW});function mW(r,e,t=0){return j(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),hd(r,e,t)}const hP=ne({pad3d_:mW});function gW(r,e,t=0){return j(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),hd(r,e,t)}const dP=ne({pad4d_:gW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yW(r,e,t){const n=H(r,"x","spaceToBatchND");j(n.rank>=1+e.length,()=>`input rank ${n.rank} should be > than [blockShape] ${e.length}`),j(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),j(n.shape.reduce((a,o,u)=>u>0&&u<=e.length?a&&(o+t[u-1][0]+t[u-1][1])%e[u-1]===0:a,!0),()=>`input spatial dimensions ${n.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const i={x:n},s={blockShape:e,paddings:t};return ie.runKernel(KC,i,s)}const X1=ne({spaceToBatchND_:yW});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vW(r,e,t,n,i,s,a){i==null&&(i=[1,1]),s==null&&(s=1),n===0&&(n="valid");const o=H(r,"x","maxPool");let u=o,h=!1;o.rank===3&&(h=!0,u=Le(o,[1,o.shape[0],o.shape[1],o.shape[2]])),j(dl(s,i),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${i}'`);const p=aI(u.shape,e,s,i,n),m=[p.dilationHeight,p.dilationWidth];let y;n==="same"?y=xW([p.filterHeight,p.filterWidth],m):y=[[0,0],[0,0]];const v=m[0]===1&&m[1]===1,[S,T]=_W([p.inHeight,p.inWidth],m,y),E=v?n:"valid",w=v?u:X1(u,m,S),A=(t==="avg"?()=>N1(w,e,s,E,a):()=>W1(w,e,s,E,a))(),I=v?A:C1(A,m,T);return h?Le(I,[I.shape[1],I.shape[2],I.shape[3]]):I}function _W(r,e,t){const n=t.map(p=>p[0]),i=t.map(p=>p[1]),s=r.concat(n,i),a=e.map((p,m)=>(p-s[m]%p)%p),o=i.map((p,m)=>p+a[m]),u=e.map((p,m)=>[n[m],o[m]]),h=e.map((p,m)=>[0,a[m]]);return[u,h]}function xW(r,e){const n=r.map((a,o)=>a+(a-1)*(e[o]-1)).map(a=>a-1),i=n.map(a=>Math.floor(a/2)),s=n.map((a,o)=>a-i[o]);return n.map((a,o)=>[i[o],s[o]])}const pP=ne({pool_:vW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SW(r,e){const t=H(r,"x","prelu"),n=H(e,"alpha","prelu"),i={x:t,alpha:n};return ie.runKernel(xC,i)}const K1=ne({prelu_:SW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wW(r,e=null,t=!1){let n=H(r,"x","prod");n.dtype==="bool"&&(n=$n(n,"int32"));const i={x:n},s={axis:e,keepDims:t};return ie.runKernel(SC,i,s)}const mP=ne({prod_:wW});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EW(r,e,t,n){const i=r.map((p,m)=>H(p,`tensors${m}`,"raggedGather","int32")),s=H(e,"paramsDenseValues","raggedGather"),a=H(t,"indices","raggedGather","int32"),o={paramsNestedSplits:i,paramsDenseValues:s,indices:a},u={outputRaggedRank:n},h=ie.runKernel(wC,o,u);return{outputNestedSplits:h.slice(0,h.length-1),outputDenseValues:h[h.length-1]}}const gP=ne({raggedGather_:EW});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bW(r,e,t){const n=H(r,"starts","raggedRange"),i=H(e,"limits","raggedRange",n.dtype),s=H(t,"deltas","raggedRange",n.dtype),a={starts:n,limits:i,deltas:s},o=ie.runKernel(EC,a);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}const yP=ne({raggedRange_:bW});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TW(r,e,t,n,i){const s=H(r,"shape","raggedTensorToTensor","int32"),a=H(e,"values","raggedTensorToTensor"),o=H(t,"defaultValue","raggedTensorToTensor",a.dtype),u=n.map((m,y)=>H(m,`tensors${y}`,"raggedTensorToTensor","int32")),h={shape:s,values:a,defaultValue:o,rowPartitionTensors:u},p={rowPartitionTypes:i};return ie.runKernel(bC,h,p)}const vP=ne({raggedTensorToTensor_:TW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MW(r,e,t){gs(r);const n=Rn(r);let i=null;if(t==null||t==="float32")i=new Float32Array(n);else if(t==="int32")i=new Int32Array(n);else if(t==="bool")i=new Uint8Array(n);else throw new Error(`Unknown data type ${t}`);for(let s=0;s<n;s++)i[s]=e();return ie.makeTensor(i,r,t)}const _P=ne({rand_:MW});var $y={exports:{}},AW=$y.exports,gT;function NW(){return gT||(gT=1,function(r){(function(e,t,n){function i(u){var h=this,p=o();h.next=function(){var m=2091639*h.s0+h.c*23283064365386963e-26;return h.s0=h.s1,h.s1=h.s2,h.s2=m-(h.c=m|0)},h.c=1,h.s0=p(" "),h.s1=p(" "),h.s2=p(" "),h.s0-=p(u),h.s0<0&&(h.s0+=1),h.s1-=p(u),h.s1<0&&(h.s1+=1),h.s2-=p(u),h.s2<0&&(h.s2+=1),p=null}function s(u,h){return h.c=u.c,h.s0=u.s0,h.s1=u.s1,h.s2=u.s2,h}function a(u,h){var p=new i(u),m=h&&h.state,y=p.next;return y.int32=function(){return p.next()*4294967296|0},y.double=function(){return y()+(y()*2097152|0)*11102230246251565e-32},y.quick=y,m&&(typeof m=="object"&&s(m,p),y.state=function(){return s(p,{})}),y}function o(){var u=4022871197,h=function(p){p=String(p);for(var m=0;m<p.length;m++){u+=p.charCodeAt(m);var y=.02519603282416938*u;u=y>>>0,y-=u,y*=u,u=y>>>0,y-=u,u+=y*4294967296}return(u>>>0)*23283064365386963e-26};return h}t&&t.exports?t.exports=a:this.alea=a})(AW,r)}($y)),$y.exports}var Gy={exports:{}},CW=Gy.exports,yT;function RW(){return yT||(yT=1,function(r){(function(e,t,n){function i(o){var u=this,h="";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var m=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^m^m>>>8},o===(o|0)?u.x=o:h+=o;for(var p=0;p<h.length+64;p++)u.x^=h.charCodeAt(p)|0,u.next()}function s(o,u){return u.x=o.x,u.y=o.y,u.z=o.z,u.w=o.w,u}function a(o,u){var h=new i(o),p=u&&u.state,m=function(){return(h.next()>>>0)/4294967296};return m.double=function(){do var y=h.next()>>>11,v=(h.next()>>>0)/4294967296,S=(y+v)/(1<<21);while(S===0);return S},m.int32=h.next,m.quick=m,p&&(typeof p=="object"&&s(p,h),m.state=function(){return s(h,{})}),m}t&&t.exports?t.exports=a:this.xor128=a})(CW,r)}(Gy)),Gy.exports}var Wy={exports:{}},IW=Wy.exports,vT;function PW(){return vT||(vT=1,function(r){(function(e,t,n){function i(o){var u=this,h="";u.next=function(){var m=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^(m^m<<1))|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,o===(o|0)?u.x=o:h+=o;for(var p=0;p<h.length+64;p++)u.x^=h.charCodeAt(p)|0,p==h.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function s(o,u){return u.x=o.x,u.y=o.y,u.z=o.z,u.w=o.w,u.v=o.v,u.d=o.d,u}function a(o,u){var h=new i(o),p=u&&u.state,m=function(){return(h.next()>>>0)/4294967296};return m.double=function(){do var y=h.next()>>>11,v=(h.next()>>>0)/4294967296,S=(y+v)/(1<<21);while(S===0);return S},m.int32=h.next,m.quick=m,p&&(typeof p=="object"&&s(p,h),m.state=function(){return s(h,{})}),m}t&&t.exports?t.exports=a:this.xorwow=a})(IW,r)}(Wy)),Wy.exports}var jy={exports:{}},LW=jy.exports,_T;function kW(){return _T||(_T=1,function(r){(function(e,t,n){function i(o){var u=this;u.next=function(){var p=u.x,m=u.i,y,v;return y=p[m],y^=y>>>7,v=y^y<<24,y=p[m+1&7],v^=y^y>>>10,y=p[m+3&7],v^=y^y>>>3,y=p[m+4&7],v^=y^y<<7,y=p[m+7&7],y=y^y<<13,v^=y^y<<9,p[m]=v,u.i=m+1&7,v};function h(p,m){var y,v=[];if(m===(m|0))v[0]=m;else for(m=""+m,y=0;y<m.length;++y)v[y&7]=v[y&7]<<15^m.charCodeAt(y)+v[y+1&7]<<13;for(;v.length<8;)v.push(0);for(y=0;y<8&&v[y]===0;++y);for(y==8?v[7]=-1:v[y],p.x=v,p.i=0,y=256;y>0;--y)p.next()}h(u,o)}function s(o,u){return u.x=o.x.slice(),u.i=o.i,u}function a(o,u){o==null&&(o=+new Date);var h=new i(o),p=u&&u.state,m=function(){return(h.next()>>>0)/4294967296};return m.double=function(){do var y=h.next()>>>11,v=(h.next()>>>0)/4294967296,S=(y+v)/(1<<21);while(S===0);return S},m.int32=h.next,m.quick=m,p&&(p.x&&s(p,h),m.state=function(){return s(h,{})}),m}t&&t.exports?t.exports=a:this.xorshift7=a})(LW,r)}(jy)),jy.exports}var qy={exports:{}},DW=qy.exports,xT;function OW(){return xT||(xT=1,function(r){(function(e,t,n){function i(o){var u=this;u.next=function(){var p=u.w,m=u.X,y=u.i,v,S;return u.w=p=p+1640531527|0,S=m[y+34&127],v=m[y=y+1&127],S^=S<<13,v^=v<<17,S^=S>>>15,v^=v>>>12,S=m[y]=S^v,u.i=y,S+(p^p>>>16)|0};function h(p,m){var y,v,S,T,E,w=[],C=128;for(m===(m|0)?(v=m,m=null):(m=m+"\0",v=0,C=Math.max(C,m.length)),S=0,T=-32;T<C;++T)m&&(v^=m.charCodeAt((T+32)%m.length)),T===0&&(E=v),v^=v<<10,v^=v>>>15,v^=v<<4,v^=v>>>13,T>=0&&(E=E+1640531527|0,y=w[T&127]^=v+E,S=y==0?S+1:0);for(S>=128&&(w[(m&&m.length||0)&127]=-1),S=127,T=4*128;T>0;--T)v=w[S+34&127],y=w[S=S+1&127],v^=v<<13,y^=y<<17,v^=v>>>15,y^=y>>>12,w[S]=v^y;p.w=E,p.X=w,p.i=S}h(u,o)}function s(o,u){return u.i=o.i,u.w=o.w,u.X=o.X.slice(),u}function a(o,u){o==null&&(o=+new Date);var h=new i(o),p=u&&u.state,m=function(){return(h.next()>>>0)/4294967296};return m.double=function(){do var y=h.next()>>>11,v=(h.next()>>>0)/4294967296,S=(y+v)/(1<<21);while(S===0);return S},m.int32=h.next,m.quick=m,p&&(p.X&&s(p,h),m.state=function(){return s(h,{})}),m}t&&t.exports?t.exports=a:this.xor4096=a})(DW,r)}(qy)),qy.exports}var Xy={exports:{}},FW=Xy.exports,ST;function UW(){return ST||(ST=1,function(r){(function(e,t,n){function i(o){var u=this,h="";u.next=function(){var m=u.b,y=u.c,v=u.d,S=u.a;return m=m<<25^m>>>7^y,y=y-v|0,v=v<<24^v>>>8^S,S=S-m|0,u.b=m=m<<20^m>>>12^y,u.c=y=y-v|0,u.d=v<<16^y>>>16^S,u.a=S-m|0},u.a=0,u.b=0,u.c=-1640531527,u.d=1367130551,o===Math.floor(o)?(u.a=o/4294967296|0,u.b=o|0):h+=o;for(var p=0;p<h.length+20;p++)u.b^=h.charCodeAt(p)|0,u.next()}function s(o,u){return u.a=o.a,u.b=o.b,u.c=o.c,u.d=o.d,u}function a(o,u){var h=new i(o),p=u&&u.state,m=function(){return(h.next()>>>0)/4294967296};return m.double=function(){do var y=h.next()>>>11,v=(h.next()>>>0)/4294967296,S=(y+v)/(1<<21);while(S===0);return S},m.int32=h.next,m.quick=m,p&&(typeof p=="object"&&s(p,h),m.state=function(){return s(h,{})}),m}t&&t.exports?t.exports=a:this.tychei=a})(FW,r)}(Xy)),Xy.exports}var Ky={exports:{}};const zW={},BW=Object.freeze(Object.defineProperty({__proto__:null,default:zW},Symbol.toStringTag,{value:"Module"})),VW=SS(BW);var HW=Ky.exports,wT;function $W(){return wT||(wT=1,function(r){(function(e,t,n){var i=256,s=6,a=52,o="random",u=n.pow(i,s),h=n.pow(2,a),p=h*2,m=i-1,y;function v(I,F,U){var V=[];F=F==!0?{entropy:!0}:F||{};var G=w(E(F.entropy?[I,A(t)]:I??C(),3),V),L=new S(V),k=function(){for(var O=L.g(s),Q=u,le=0;O<h;)O=(O+le)*i,Q*=i,le=L.g(1);for(;O>=p;)O/=2,Q/=2,le>>>=1;return(O+le)/Q};return k.int32=function(){return L.g(4)|0},k.quick=function(){return L.g(4)/4294967296},k.double=k,w(A(L.S),t),(F.pass||U||function(O,Q,le,K){return K&&(K.S&&T(K,L),O.state=function(){return T(L,{})}),le?(n[o]=O,Q):O})(k,G,"global"in F?F.global:this==n,F.state)}function S(I){var F,U=I.length,V=this,G=0,L=V.i=V.j=0,k=V.S=[];for(U||(I=[U++]);G<i;)k[G]=G++;for(G=0;G<i;G++)k[G]=k[L=m&L+I[G%U]+(F=k[G])],k[L]=F;(V.g=function(O){for(var Q,le=0,K=V.i,ce=V.j,de=V.S;O--;)Q=de[K=m&K+1],le=le*i+de[m&(de[K]=de[ce=m&ce+Q])+(de[ce]=Q)];return V.i=K,V.j=ce,le})(i)}function T(I,F){return F.i=I.i,F.j=I.j,F.S=I.S.slice(),F}function E(I,F){var U=[],V=typeof I,G;if(F&&V=="object")for(G in I)try{U.push(E(I[G],F-1))}catch{}return U.length?U:V=="string"?I:I+"\0"}function w(I,F){for(var U=I+"",V,G=0;G<U.length;)F[m&G]=m&(V^=F[m&G]*19)+U.charCodeAt(G++);return A(F)}function C(){try{var I;return y&&(I=y.randomBytes)?I=I(i):(I=new Uint8Array(i),(e.crypto||e.msCrypto).getRandomValues(I)),A(I)}catch{var F=e.navigator,U=F&&F.plugins;return[+new Date,e,U,e.screen,A(t)]}}function A(I){return String.fromCharCode.apply(0,I)}if(w(n.random(),t),r.exports){r.exports=v;try{y=VW}catch{}}else n["seed"+o]=v})(typeof self<"u"?self:HW,[],Math)}(Ky)),Ky.exports}var q_,ET;function GW(){if(ET)return q_;ET=1;var r=NW(),e=RW(),t=PW(),n=kW(),i=OW(),s=UW(),a=$W();return a.alea=r,a.xor128=e,a.xorwow=t,a.xorshift7=n,a.xor4096=i,a.tychei=s,q_=a,q_}var Y1=GW();/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WW=.001,xP=.1;function jW(r,e,t){return t==null&&(t=Z1()),aS(r,e,(n,i)=>J1(n,i,t))}function Z1(){return ie.backend.floatPrecision()===32?WW:xP}function aS(r,e,t){let n=!0;if((Gr(r)||Gr(e))&&(n=!1),Gr(r)&&Gr(e)&&(n=!0),n){const a=r.constructor.name,o=e.constructor.name;if(a!==o)throw new Error(`Arrays are of different type. Actual: ${a}. Expected: ${o}`)}if(Array.isArray(r)&&Array.isArray(e)){const a=so(r),o=so(e);if(!Ra(a,o))throw new Error(`Arrays have different shapes. Actual: [${a}]. Expected: [${o}]`)}const i=Gr(r)?r:vu(r),s=Gr(e)?e:vu(e);if(i.length!==s.length)throw new Error(`Arrays have different lengths actual: ${i.length} vs expected: ${s.length}.
Actual:   ${i}.
Expected: ${s}.`);for(let a=0;a<s.length;++a){const o=i[a],u=s[a];if(!t(o,u))throw new Error(`Arrays differ: actual[${a}] = ${o}, expected[${a}] = ${u}.
Actual:   ${i}.
Expected: ${s}.`)}typeof expect<"u"&&expect().nothing()}function qW(r,e){r().then(()=>e.fail(),()=>e()),typeof expect<"u"&&expect().nothing()}function XW(r,e){const t=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return su(r)||su(r[0])||su(e)||su(e[0])?aS(r,t,(n,i)=>n==i):aS(r,e,(n,i)=>J1(n,i,0))}function KW(r,e,t){if(t==null&&(t=Z1()),!J1(r,e,t))throw new Error(`Numbers differ: actual === ${r}, expected === ${e}`);typeof expect<"u"&&expect().nothing()}function J1(r,e,t){return!isFinite(r)&&!isFinite(e)?!0:!(isNaN(r)||isNaN(e)||Math.abs(r-e)>t)}function YW(r,e,t){for(let n=0;n<r.length;n++)if(r[n]<e||r[n]>t)throw new Error(`Value out of range:${r[n]} low: ${e}, high: ${t}`)}function ZW(r,e){const t=new Float32Array(r),n=new Float32Array(e);if(t.length!==n.length)throw new Error(`Expected ArrayBuffer to be of length ${n.length}, but it was ${t.length}`);for(let i=0;i<n.length;i++)if(t[i]!==n[i])throw new Error(`Expected ArrayBuffer value at ${i} to be ${n[i]} but got ${t[i]} instead`)}function SP(r){for(let e=0;e<r.length;e++){const t=r[e];Array.isArray(t)?SP(t):r[e]=Lm(t)}return r}function JW(r){const e=document.createElement("video");return"playsInline"in e&&(e.playsInline=!0),e.muted=!0,e.loop=!0,e.style.position="fixed",e.style.left="0px",e.style.top="0px",e.preload="auto",e.appendChild(r),new Promise(t=>{e.addEventListener("loadeddata",n=>t(e)),e.load()})}async function QW(r){await r.play(),"requestVideoFrameCallback"in r&&await new Promise(e=>{r.requestVideoFrameCallback(e)})}const e6=Object.freeze(Object.defineProperty({__proto__:null,TEST_EPSILON_FLOAT16:xP,createVideoElement:JW,encodeStrings:SP,expectArrayBuffersEqual:ZW,expectArraysClose:jW,expectArraysEqual:XW,expectNumbersClose:KW,expectPromiseToFail:qW,expectValuesInRange:YW,play:QW,testEpsilon:Z1},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Q1{constructor(e,t,n,i,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=i,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const a=s||Math.random();this.random=Y1.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const i=this.nextVal;return this.nextVal=NaN,i}let e,t,n=!1;for(;!n;){let i,s,a;do i=2*this.random()-1,s=2*this.random()-1,a=i*i+s*s;while(a>=1||a===0);const o=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*i*o,t=this.mean+this.stdDev*s*o,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class t6{constructor(e,t,n,i){this.alpha=e,this.beta=1/t,this.dtype=n;const s=i||Math.random();this.randu=Y1.alea(s.toString()),this.randn=new Q1(0,1,n,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,i,s,a;for(;;){do i=this.randn.nextValue(),a=1+this.c*i;while(a<=0);if(a*=a*a,e=i*i,t=1-.331*e*e,n=.5*e+this.d*(1-a+Math.log(a)),s=this.randu(),s<t||Math.log(s)<n)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class n6{constructor(e=0,t=1,n,i){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=n,i==null&&(i=Math.random()),typeof i=="number"&&(i=i.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Y1.alea(i)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r6(r,e,t=1,n="float32",i){if(gs(r),t==null&&(t=1),n==null&&(n="float32"),n!=="float32"&&n!=="int32")throw new Error(`Unsupported data type ${n}`);const s=new t6(e,t,n,i),a=ao(r,n);for(let o=0;o<a.values.length;o++)a.values[o]=s.nextValue();return a.toTensor()}const wP=ne({randomGamma_:r6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i6(r,e=0,t=1,n,i){if(gs(r),n!=null&&n==="bool")throw new Error(`Unsupported data type ${n}`);const s=new Q1(e,t,n,!1,i),a=ao(r,n);for(let o=0;o<a.values.length;o++)a.values[o]=s.nextValue();return a.toTensor()}const ew=ne({randomNormal_:i6});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s6(r,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return ew(r,0,1,e,t)}const EP=ne({randomStandardNormal_:s6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a6(r,e=0,t=1,n="float32",i){gs(r);const s=ao(r,n),a=new n6(e,t,null,i);for(let o=0;o<s.values.length;o++)s.values[o]=a.nextValue();return s.toTensor()}const nv=ne({randomUniform_:a6});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o6(r,e,t,n){return nv(r,e,t,"int32",n)}const bP=ne({randomUniformInt_:o6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rd(r,e,t=1,n="float32"){if(t===0)throw new Error("Cannot have a step of zero");const i={start:r,stop:e,step:t,dtype:n};return ie.runKernel(TC,{},i)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l6(r){const t={input:H(r,"input","real")};return ie.runKernel(MC,t)}const id=ne({real_:l6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u6(r){const t={x:H(r,"x","reciprocal")};return ie.runKernel(AC,t)}const TP=ne({reciprocal_:u6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c6(r){const t={x:H(r,"x","relu")};return ie.runKernel(NC,t)}const Hm=ne({relu_:c6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f6(r){const t={x:H(r,"x","relu6")};return ie.runKernel(PC,t)}const tw=ne({relu6_:f6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h6(r,e){const n={x:H(r,"x","reverse")},i={dims:e};return ie.runKernel(LC,n,i)}const Su=ne({reverse_:h6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d6(r){const e=H(r,"x","reverse");return j(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),Su(e,0)}const MP=ne({reverse1d_:d6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p6(r,e){const t=H(r,"x","reverse");return j(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),Su(t,e)}const AP=ne({reverse2d_:p6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m6(r,e){const t=H(r,"x","reverse");return j(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),Su(t,e)}const NP=ne({reverse3d_:m6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g6(r,e){const t=H(r,"x","reverse");return j(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),Su(t,e)}const CP=ne({reverse4d_:g6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y6(r){const t={x:H(r,"x","round")};return ie.runKernel(kC,t)}const nw=ne({round_:y6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v6(r){const t={x:H(r,"x","rsqrt","float32")};return ie.runKernel(DC,t)}const RP=ne({rsqrt_:v6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _6(r){const t={x:H(r,"x","selu")};return ie.runKernel(BC,t)}const IP=ne({selu_:_6});function x6(r,e,t,n,i,s=[1,1],a="NHWC"){const o=H(r,"x","separableConv2d"),u=H(e,"depthwiseFilter","separableConv2d"),h=H(t,"pointwiseFilter","separableConv2d");let p=o,m=!1;if(o.rank===3&&(m=!0,p=Le(o,[1,o.shape[0],o.shape[1],o.shape[2]])),a==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");j(p.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${p.rank}.`),j(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),j(h.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),j(h.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${h.shape[0]}.`),j(h.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${h.shape[1]}.`);const y=u.shape[2],v=u.shape[3];j(h.shape[2]===y*v,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${y*v}, but got ${h.shape[2]}.`);const S=J0(p,u,n,i,a,s),E=Fm(S,h,1,"valid",a);return m?Le(E,[E.shape[1],E.shape[2],E.shape[3]]):E}const PP=ne({separableConv2d_:x6});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function S6(r,e){const t=H(r,"x","setdiff1d"),n=H(e,"y","setdiff1d");j(t.dtype===n.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${n.dtype}).`),j(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),j(n.rank===1,()=>`y should be 1D tensor, but got y (${n.shape}).`);const i=await t.data(),s=await n.data(),a=new Set(s);let o=0;for(let p=0;p<i.length;p++)a.has(i[p])||o++;const u=new u0([o],t.dtype),h=new u0([o],"int32");for(let p=0,m=0;p<i.length;p++)a.has(i[p])||(u.values[m]=i[p],h.values[m]=p,m++);return[u.toTensor(),h.toTensor()]}const LP=S6;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w6(r){const t={x:H(r,"x","sign")};return ie.runKernel(GC,t)}const kP=ne({sign_:w6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E6(r){const t={x:H(r,"x","sin","float32")};return ie.runKernel(HC,t)}const DP=ne({sin_:E6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b6(r){const t={x:H(r,"x","sinh")};return ie.runKernel($C,t)}const OP=ne({sinh_:b6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T6(r,e,t){const n=H(r,"x","slice1d");return j(n.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${n.rank} tensor`),On(n,[e],[t])}const FP=ne({slice1d_:T6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M6(r,e,t){const n=H(r,"x","slice2d");return j(n.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${n.rank} tensor`),On(n,e,t)}const UP=ne({slice2d_:M6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A6(r,e,t){const n=H(r,"x","slice3d");return j(n.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${n.rank} tensor`),On(n,e,t)}const zP=ne({slice3d_:A6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N6(r,e,t){const n=H(r,"x","slice4d");return j(n.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${n.rank} tensor`),On(n,e,t)}const BP=ne({slice4d_:N6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C6(r,e=-1){const t=H(r,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const n={logits:t},i={dim:e};return ie.runKernel(ZC,n,i)}const VP=ne({softmax_:C6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R6(r){j(r.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${r.dtype}.`);const e={input:r};return ie.runKernel(AN,e)}const rv=ne({fft_:R6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I6(r){j(r.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${r.dtype}.`);const e={input:r};return ie.runKernel(FN,e)}const ym=ne({ifft_:I6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P6(r){const e=r.shape[r.shape.length-1],t=r.size/e;let n;if(e<=2){const i=Le(r,[t,e]);n=ym(i)}else{const i=[t,2*(e-1)],s=Le(id(r),[t,e]),a=Le(Vm(r),[t,e]),o=Su(On(s,[0,1],[t,e-2]),1),u=st(Su(On(a,[0,1],[t,e-2]),1),dn(-1)),h=di([s,o],1),p=di([a,u],1),m=Le(fl(h,p),[i[0],i[1]]);n=ym(m)}if(n=id(n),r.rank===3&&r.shape[0]!==0){const i=n,s=r.shape[0];n=Le(n,[s,n.shape[0]/s,n.shape[1]]),i.dispose()}return n}const rw=ne({irfft_:P6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L6(r,e,t=0){const i={x:H(r,"x","split")},s={numOrSizeSplits:e,axis:t};return ie.runKernel(YC,i,s)}const sd=ne({split_:L6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k6(r,e){j(r.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${r.dtype}`);let t=r.shape[r.shape.length-1];const n=r.size/t;let i;if(e!=null&&e<t){const S=r.shape.map(E=>0),T=r.shape.map(E=>E);T[r.shape.length-1]=e,i=On(r,S,T),t=e}else if(e!=null&&e>t){const S=r.shape.map(T=>T);S[r.shape.length-1]=e-t,i=di([r,tf(S)],r.shape.length-1),t=e}else i=r;const s=ps(i),a=Le(fl(i,s),[n,t]),o=rv(a),u=Math.floor(t/2)+1,h=id(o),p=Vm(o),m=sd(h,[u,t-u],h.shape.length-1),y=sd(p,[u,t-u],p.shape.length-1),v=i.shape.slice();return v[i.shape.length-1]=u,Le(fl(m[0],y[0]),v)}const iv=ne({rfft_:k6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D6(r,e){let t=H(r,"a","squaredDifference"),n=H(e,"b","squaredDifference");[t,n]=ir(t,n),Tr(t.shape,n.shape);const i={a:t,b:n},s={};return ie.runKernel(rR,i,s)}const iw=ne({squaredDifference_:D6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O6(r,e){const t=H(r,"x","squeeze","string_or_numeric");return Le(t,S2(t.shape,e).newShape)}const sv=ne({squeeze_:O6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F6(r,e=0){const t=cm(r,"tensors","stack","string_or_numeric");j(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&j(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const n=t,i={axis:e};return ie.runKernel(yC,n,i)}const uo=ne({stack_:F6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U6(r,e=0){const n={x:H(r,"x","step")},i={alpha:e};return ie.runKernel(vR,n,i)}const sw=ne({step_:U6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z6(r,e,t,n,i=0,s=0,a=0,o=0,u=0){const p={x:H(r,"x","stridedSlice","string_or_numeric")},m={begin:e,end:t,strides:n,beginMask:i,endMask:s,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:u};return ie.runKernel(sR,p,m)}const HP=ne({stridedSlice_:z6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B6(r){const t={x:H(r,"x","tan","float32")};return ie.runKernel(cR,t)}const $P=ne({tan_:B6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Is(r,e){uf(r);const t=so(r,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Mu(r,null,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jh(r,e,t){if(uf(r),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const n=so(r,t);if(n.length!==2&&n.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Mu(r,e,n,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aw(r,e,t){if(uf(r),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const n=so(r,t);if(n.length!==3&&n.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Mu(r,e,n,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GP(r,e,t){if(uf(r),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const n=so(r,t);if(n.length!==4&&n.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Mu(r,e,n,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WP(r,e,t){if(uf(r),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const n=so(r,t);if(n.length!==5&&n.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Mu(r,e,n,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jP(r,e,t){if(uf(r),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const n=so(r,t);if(n.length!==6&&n.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||n,Mu(r,e,n,t)}function ow(r,e,t){const n=e.rank>1?e.shape[e.rank-1]:1,i=e.rank>1?e.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${r}, sliceDim: ${n}, and batchDim: ${i}.`;if(t.rank<i)throw new Error(s+` update.rank < ${i}. `);if(r.length<n+(t.rank-i))throw new Error(s+` Output shape length < ${n+(t.rank-i)}`);if(t.rank!==i+r.length-n)throw new Error(s+` update.rank != ${i+r.length-n}`);for(let a=0;a<i;++a)if(t.shape[a]!==e.shape[a])throw new Error(s+` updates.shape[${a}] (${t.shape[a]}) != indices.shape[${a}] (${e.shape[a]}).`);for(let a=0;a<t.rank-i;++a)if(t.shape[a+i]!==r[a+n])throw new Error(s+` updates.shape[${a+i}] (${t.shape[a+i]}) != shape[${a+i}] (${r[a+i]})`)}function av(r,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(r.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${r.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(r.size===0)throw new Error(`Updates specified for empty output. updates shape: ${r.shape}`)}ow(t,e,r)}function qP(r,e,t){const n=e.shape.length,i=n>1?e.shape[n-1]:1,s=t.length;let a=1;for(let m=i;m<s;++m)a*=t[m];const o=i<1?1:i,u=Rn(e.shape)/o,h=[...cd(t.slice(0,i)),1],p=Rn(t);return{sliceRank:i,numUpdates:u,sliceSize:a,strides:h,outputSize:p}}const V6=Object.freeze(Object.defineProperty({__proto__:null,calculateShapes:qP,validateInput:av,validateUpdateShape:ow},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H6(r,e,t){const n=H(r,"tensor","tensorScatterupdate"),i=H(e,"indices","tensorScatterupdate","int32"),s=H(t,"updates","tensorScatterupdate");if(av(s,i,n.shape),n.dtype!==s.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${n.dtype} and ${s.dtype}.`);const a={tensor:n,indices:i,updates:s},o={};return ie.runKernel(FC,a,o)}const XP=ne({tensorScatterUpdate_:H6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $6(r,e=1,t=!0){const n=H(r,"x","topk");if(n.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const i=n.shape[n.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>i)throw new Error(`'k' passed to topk() must be <= the last dimension (${i}) but got ${e}`);const s={x:n},a={k:e,sorted:t},[o,u]=ie.runKernel(hR,s,a);return{values:o,indices:u}}const KP=ne({topk_:$6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G6(r,e=0,t=1,n,i){if(gs(r),n!=null&&n==="bool")throw new Error("Unsupported data type $ { dtype }");const s=new Q1(e,t,n,!0,i),a=ao(r,n);for(let o=0;o<a.values.length;o++)a.values[o]=s.nextValue();return a.toTensor()}const YP=ne({truncatedNormal_:G6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W6(r,e=0){const t=H(r,"x","unique","string_or_numeric");j(t.rank>0,()=>"The input tensor must be at least 1D");const n={x:t},i={axis:e},[s,a]=ie.runKernel(pR,n,i);return{values:s,indices:a}}const ZP=ne({unique_:W6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j6(r,e,t){const n=H(r,"x","unsortedSegmentSum"),i=H(e,"segmentIds","unsortedSegmentSum","int32");j(Jh(t),()=>"numSegments must be of dtype int");const s={x:n,segmentIds:i},a={numSegments:t};return ie.runKernel(gR,s,a)}const JP=ne({unsortedSegmentSum_:j6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q6(r,e=0){const t=H(r,"x","unstack","string_or_numeric");j(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const n={value:t},i={axis:e};return ie.runKernel(mR,n,i)}const Au=ne({unstack_:q6});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QP(r,e){return tv(r,e,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e3(r,e=!0,t,n){return ie.makeVariable(r,e,t,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t3(r,e){const t=[];for(let s=0;s<e.length;s++)e[s]&&t.push(s);const n=ao(r,"int32"),i=ao([t.length,r.length],"int32");for(let s=0;s<t.length;s++){const a=n.indexToLoc(t[s]),o=s*r.length;i.values.set(a,o)}return i.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function X6(r){const e=H(r,"condition","whereAsync","bool"),t=await e.data(),n=t3(e.shape,t);return r!==e&&e.dispose(),n}const lw=X6;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function K6(r,e,t){const n=H(r,"tensor","boolMask"),i=H(e,"mask","boolMask","bool"),s=t??0,a=i.rank,o=n.shape;j(a>0,()=>"mask cannot be scalar"),Ii(o.slice(s,s+a),i.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let T=s;T<s+a;T++)u*=o[T];const h=o.slice(0,s).concat([u],o.slice(s+a)),p=Le(n,h),m=Le(i,[-1]),y=await lw(m),v=sv(y,[1]),S=F1(p,v,s);return r!==n&&n.dispose(),e!==i&&i.dispose(),v.dispose(),p.dispose(),m.dispose(),y.dispose(),S}const n3=K6;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y6(r,e,t){const n=H(r,"x","transpose");if(e==null&&(e=n.shape.map((a,o)=>o).reverse()),j(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${e}.`),e.forEach(a=>{j(a>=0&&a<n.rank,()=>`All entries in 'perm' must be between 0 and ${n.rank-1} but got ${e}`)}),n.rank<=1)return n.clone();const i={x:n},s={perm:e};return n.dtype==="complex64"?bn(()=>{let a=id(n),o=Vm(n);return a=ie.runKernel(By,{x:a},s),o=ie.runKernel(By,{x:o},s),t&&(o=Na(o)),fl(a,o)}):ie.runKernel(By,i,s)}const vm=ne({transpose_:Y6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z6(r,e,t,n,i=!0){const s=H(r,"v","movingAverage"),a=H(e,"x","movingAverage"),o=H(t,"decay","movingAverage");RR(s,a),j(Ra(s.shape,a.shape),()=>"Shape mismatch in v and x");const u=dn(1),h=sn(u,o);let p=st(sn(a,s),h);if(i){j(n!=null,()=>"When using zeroDebias: true, step is required.");const m=H(n,"step","movingAverage");p=Vn(p,sn(u,td(o,m)))}return Vt(s,p)}const r3=ne({movingAverage_:Z6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J6(r,e,t){gs(t);const n=H(r,"indices","scatterND","int32"),i=H(e,"updates","scatterND");av(i,n,t);const s={indices:n,updates:i},a={shape:t};return ie.runKernel(OC,s,a)}const i3=ne({scatterND_:J6});function Q6(r,e,t,n){if(r.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${r.dtype}.`);if(r.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${r.shape}.`);const i=r.rank>0?r.shape[0]:1,s=r.rank>1?r.shape[1]:1;if(t.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${s}.`);const a=e.size;if(!(e.rank===0||e.rank===1&&a===i))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${i}]`);if(e.dtype!==n.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e8(r,e,t,n=0){gs(t);const i=H(r,"sparseIndices","sparseToDense","int32"),s=H(e,"sparseValues","sparseToDense","string_or_numeric"),a=H(n,"defaultValue","sparseToDense",s.dtype);Q6(i,s,t,a);const o={sparseIndices:i,sparseValues:s,defaultValue:a},u={outputShape:t};return ie.runKernel(nR,o,u)}const s3=ne({sparseToDense_:e8});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t8(r,e){const t=H(e,"indices","gatherND","int32"),i={params:H(r,"x","gatherND","string_or_numeric"),indices:t};return ie.runKernel(kN,i)}const a3=ne({gatherND_:t8});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n8(r,e){if(e==null)return r.shape.slice();if(Ra(r.shape,e))return e;if(r.shape.length===e.length){const t=[];for(let n=0;n<r.shape.length;n++)e[n]==null&&r.shape[n]!=null?t.push(r.shape[n]):t.push(e[n]);return t}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r8(r,e,t,n){const i=H(r,"x","dropout");if(j(i.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${i.dtype} tensor instead.`),j(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return r instanceof ur?i.clone():i;const s=n8(i,t),a=1-e,o=Vn(O1(Vt(nv(s,0,1,"float32",n),a)),a);return st(i,o)}const o3=ne({dropout_:r8});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uw(r){return Math.floor(Math.pow(2,Math.ceil(Math.log(r)/Math.log(2))))}function ov(r,e,t){const n=1-r%2,i=new Float32Array(r);for(let s=0;s<r;++s){const a=2*Math.PI*s/(r+n-1);i[s]=e-t*Math.cos(a)}return Is(i,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function i8(r,e,t=1){const n=H(r,"predictions","inTopK"),i=H(e,"targets","inTopK");j(n.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${n.rank}`),j(n.rank-1===i.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${n.rank} and targets rank ${i.rank}`),Ii(n.shape.slice(0,n.shape.length-1),i.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const s=n.shape[n.shape.length-1];j(t>0&&t<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${t}`);const a=await n.data(),o=await i.data(),[u,h]=[a.length/s,s],p=w2("bool",u);for(let m=0;m<u;m++){const y=m*h,v=a.subarray(y,y+h),S=[];for(let T=0;T<v.length;T++)S.push({value:v[T],index:T});S.sort((T,E)=>E.value-T.value),p[m]=0;for(let T=0;T<t;T++)if(S[T].index===o[m]){p[m]=1;break}}return r!==n&&n.dispose(),e!==i&&i.dispose(),Aa(p,i.shape,"bool")}const l3=i8;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s8(r,e,t,n,i,s="NHWC",a){let o=r;r.rank===3&&(o=Le(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let u=e;u.rank===3&&(u=Le(e,[1,e.shape[0],e.shape[1],e.shape[2]])),j(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),j(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),j(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const h=s==="NHWC"?o.shape[3]:o.shape[1],p=s==="NHWC"?u.shape[3]:u.shape[1];j(h===t[2],()=>`Error in conv2dDerFilter: depth of input ${h}) must match input depth in filter (${t[2]}.`),j(p===t[3],()=>`Error in conv2dDerFilter: depth of dy (${p}) must match output depth for filter (${t[3]}).`),qs("conv2dDerFilter",i,a);const m={x:o,dy:u},y={strides:n,pad:i,dataFormat:s,dimRoundingMode:a,filterShape:t};return ie.runKernel(rN,m,y)}const a8=ne({conv2DBackpropFilter_:s8});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lv(r,e,t){if(t==null||t==="linear")return r;if(t==="relu")return st(r,sw(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function uv(r,e){let t=e;const n=I1(r.shape,e.shape);return n.length>0&&(t=Bn(t,n)),Le(t,r.shape)}function cv(r,e,t,n){if(e==="linear")return r;if(e==="relu")return Hm(r);if(e==="elu")return L1(r);if(e==="relu6")return tw(r);if(e==="prelu")return K1(r,t);if(e==="leakyrelu")return z1(r,n);if(e==="sigmoid")return Wc(r);throw new Error(`Unknown fused activation ${e}.`)}const fv=(r,e)=>!(r>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o8({x:r,filter:e,strides:t,pad:n,dataFormat:i="NHWC",dilations:s=[1,1],dimRoundingMode:a,bias:o,activation:u="linear",preluActivationWeights:h,leakyreluAlpha:p}){if(u=u||"linear",fv(ie.state.gradientDepth,u)===!1){j(i==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${i} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let U=Fm(r,e,t,n,i,s,a);return o!=null&&(U=Vt(U,o)),cv(U,u,h,p)}const m=H(r,"x","conv2d","float32"),y=H(e,"filter","conv2d","float32");let v=m,S=!1;m.rank===3&&(S=!0,v=Le(m,[1,m.shape[0],m.shape[1],m.shape[2]])),j(v.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${v.rank}.`),j(y.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${y.rank}.`),qs("fused conv2d",n,a);const T=i==="NHWC"?v.shape[3]:v.shape[1];j(y.shape[2]===T,()=>`Error in conv2d: depth of input (${T}) must match input depth for filter ${y.shape[2]}.`),j(dl(t,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`);const E=Dm(v.shape,y.shape,t,s,n,a);let w;o!=null&&(w=H(o,"bias","fused conv2d"),[w]=ir(w,m),i==="NHWC"?Tr(E.outShape,w.shape):(j(w.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${w.shape.length}.`),j(w.shape.length===0||w.shape[0]===E.outChannels||w.shape[0]===1,()=>`Error in fused conv2d: bias shape (${w.shape}) is not compatible with the number of output channels (${E.outChannels})`)));let C;if(h!=null){const U=h.shape;if(j(U.length<=1||U.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${U.length}.`),U.length===1)j(U[0]===1||U[0]===E.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${U}) is not compatible with the number of output channels (${E.outChannels}).`);else if(U.length===3)try{Tr(U,E.outShape)}catch{const G=`Error in fused conv2d: PReLU activation weights (${U}) is not compatible with the output shape of the conv2d (${E.outShape}).`;throw Error(G)}C=H(h,"prelu weights","fused conv2d")}const A=(U,V)=>{j(i==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${i} but only NHWC is currently supported.`);const[G,L,k,O]=V,Q=lv(U,k,u);j(dm(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const le=EI(L.shape,Q,G,t,n),K=a8(L,Q,G.shape,t,n),ce=[le,K];if(O!=null){const de=uv(O,Q);ce.push(de)}return ce},I={x:v,filter:y,bias:w,preluActivationWeights:C},F={strides:t,pad:n,dataFormat:i,dilations:s,dimRoundingMode:a,activation:u,leakyreluAlpha:p};return o==null?lo((V,G,L)=>{let k=ie.runKernel(jx,I,F);return L([G,V,k]),S&&(k=Le(k,[k.shape[1],k.shape[2],k.shape[3]])),{value:k,gradFunc:A}})(v,y):lo((V,G,L,k)=>{let O=ie.runKernel(jx,I,F);return k([G,V,O,L]),S&&(O=Le(O,[O.shape[1],O.shape[2],O.shape[3]])),{value:O,gradFunc:A}})(v,y,w)}const l8=ne({fusedConv2d_:o8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u8(r,e,t,n,i,s=[1,1],a){let o=r;r.rank===3&&(o=Le(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let u=e;u.rank===3&&(u=Le(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const h={x:o,dy:u},p={strides:n,pad:i,dimRoundingMode:a,dilations:s,filterShape:t};return ie.runKernel(mN,h,p)}const c8=ne({depthwiseConv2dNativeBackpropFilter_:u8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f8(r,e,t,n,i,s=[1,1],a){let o=e,u=!1;e.rank===3&&(u=!0,o=Le(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const h={dy:o,filter:t},p={strides:n,pad:i,dimRoundingMode:a,dilations:s,inputShape:r},m=ie.runKernel(gN,h,p);return u?Le(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const h8=ne({depthwiseConv2dNativeBackpropInput_:f8});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d8({x:r,filter:e,strides:t,pad:n,dataFormat:i="NHWC",dilations:s=[1,1],dimRoundingMode:a,bias:o,activation:u="linear",preluActivationWeights:h,leakyreluAlpha:p}){if(fv(ie.state.gradientDepth,u)===!1){let F=J0(r,e,t,n,i,s,a);return o!=null&&(F=Vt(F,o)),cv(F,u,h,p)}const m=H(r,"x","depthwiseConv2d","float32"),y=H(e,"filter","depthwiseConv2d","float32");let v=m,S=!1;m.rank===3&&(S=!0,v=Le(m,[1,m.shape[0],m.shape[1],m.shape[2]])),j(v.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${v.rank}.`),j(y.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${y.rank}.`),j(v.shape[3]===y.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${v.shape[3]}) must match the inChannels dimension in filter ${y.shape[2]}.`),s==null&&(s=[1,1]),j(dl(t,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),qs("fused depthwiseConv2d",n,a);const T=Dm(v.shape,y.shape,t,s,n,a,!0);let E;o!=null&&(E=H(o,"bias","fused conv2d"),[E]=ir(E,m),Tr(T.outShape,E.shape));let w;h!=null&&(w=H(h,"prelu weights","fused depthwiseConv2d"));const C=(F,U)=>{j(dm(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);const[V,G,L,k]=U,O=lv(F,L,u),Q=h8(G.shape,O,V,t,n,s,a),le=c8(G,O,V.shape,t,n,s,a);if(k!=null){const K=uv(E,O);return[Q,le,K]}return[Q,le]},A={x:v,filter:y,bias:E,preluActivationWeights:w},I={strides:t,pad:n,dataFormat:i,dilations:s,dimRoundingMode:a,activation:u,leakyreluAlpha:p};return o==null?lo((U,V,G)=>{let L=ie.runKernel(qx,A,I);return G([V,U,L]),S&&(L=Le(L,[L.shape[1],L.shape[2],L.shape[3]])),{value:L,gradFunc:C}})(v,y):lo((U,V,G,L)=>{let k=ie.runKernel(qx,A,I);return L([V,U,k,G]),S&&(k=Le(k,[k.shape[1],k.shape[2],k.shape[3]])),{value:k,gradFunc:C}})(v,y,E)}const p8=ne({fusedDepthwiseConv2d_:d8});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m8({a:r,b:e,transposeA:t=!1,transposeB:n=!1,bias:i,activation:s="linear",preluActivationWeights:a,leakyreluAlpha:o=.2}){if(fv(ie.state.gradientDepth,s)===!1){let O=En(r,e,t,n);return i!=null&&(O=Vt(O,i)),cv(O,s,a,o)}let u=H(r,"a","fused matMul"),h=H(e,"b","fused matMul");[u,h]=ir(u,h);const p=t?u.shape[u.rank-2]:u.shape[u.rank-1],m=n?h.shape[h.rank-1]:h.shape[h.rank-2],y=t?u.shape[u.rank-1]:u.shape[u.rank-2],v=n?h.shape[h.rank-2]:h.shape[h.rank-1],S=u.shape.slice(0,-2),T=h.shape.slice(0,-2),E=Rn(S),w=Rn(T);j(p===m,()=>`Error in fused matMul: inner shapes (${p}) and (${m}) of Tensors with shapes ${u.shape} and ${h.shape} and transposeA=${t} and transposeB=${n} must match.`);const A=Tr(u.shape.slice(0,-2),h.shape.slice(0,-2)).concat([y,v]),I=t?Le(u,[E,p,y]):Le(u,[E,y,p]),F=n?Le(h,[w,v,m]):Le(h,[w,m,v]);let U;i!=null&&(U=H(i,"bias","fused matMul"),[U]=ir(U,u),Tr(A,U.shape));let V;a!=null&&(V=H(a,"prelu weights","fused matMul"));const G=(O,Q)=>{const[le,K,ce,de]=Q,me=lv(Le(O,ce.shape),ce,s);let Z,re;if(!t&&!n?(Z=En(me,K,!1,!0),re=En(le,me,!0,!1)):!t&&n?(Z=En(me,K,!1,!1),re=En(me,le,!0,!1)):t&&!n?(Z=En(K,me,!1,!0),re=En(le,me,!1,!1)):(Z=En(K,me,!0,!0),re=En(me,le,!0,!0)),i!=null){const ee=uv(de,me);return[Z,re,ee]}else return[Z,re]},L={a:I,b:F,bias:U,preluActivationWeights:V},k={transposeA:t,transposeB:n,activation:s,leakyreluAlpha:o};return i==null?lo((Q,le,K)=>{const ce=ie.runKernel(Wx,L,k);return K([Q,le,ce]),{value:Le(ce,A),gradFunc:G}})(I,F):lo((Q,le,K,ce)=>{const de=ie.runKernel(Wx,L,k);return ce([Q,le,de,K]),{value:Le(de,A),gradFunc:G}})(I,F,U)}const g8=ne({fusedMatMul_:m8});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u3=Object.freeze(Object.defineProperty({__proto__:null,conv2d:l8,depthwiseConv2d:p8,matMul:g8},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y8(r){return ov(r,.54,.46)}const v8=ne({hammingWindow_:y8});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _8(r){return ov(r,.5,.5)}const c3=ne({hannWindow_:_8});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x8(r,e,t,n=!1,i=0){let s=0;const a=[];for(;s+e<=r.size;)a.push(On(r,s,e)),s+=t;if(n)for(;s<r.size;){const o=s+e-r.size,u=di([On(r,s,e-o),fd([o],i)]);a.push(u),s+=t}return a.length===0?jh([],[0,e]):Le(di(a),[a.length,e])}const f3=ne({frame_:x8});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S8(r,e,t,n,i=c3){n==null&&(n=uw(e));const s=f3(r,e,t),a=st(s,i(e));return iv(a,n)}const w8=ne({stft_:S8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E8(r,e,t,n,i="bilinear",s=0){const a=H(r,"image","cropAndResize"),o=H(e,"boxes","cropAndResize","float32"),u=H(t,"boxInd","cropAndResize","int32"),h=o.shape[0];j(a.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),j(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${h},4] but had shape ${o.shape}.`),j(u.rank===1&&u.shape[0]===h,()=>`Error in cropAndResize: boxInd must be have size [${h}] but had shape ${o.shape}.`),j(n.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${n.length}.`),j(n[0]>=1&&n[1]>=1,()=>`cropSize must be atleast [1,1], but was ${n}`),j(i==="bilinear"||i==="nearest",()=>`method must be bilinear or nearest, but was ${i}`);const p={image:a,boxes:o,boxInd:u},m={method:i,extrapolationValue:s,cropSize:n};return ie.runKernel(fN,p,m)}const b8=ne({cropAndResize_:E8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T8(r){const e=H(r,"image","flipLeftRight","float32");j(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return ie.runKernel(CN,t,{})}const M8=ne({flipLeftRight_:T8});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A8(r){const e=H(r,"image","grayscaleToRGB"),t=e.rank-1,n=e.shape[t];j(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),j(n===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${n}.`);const i=new Array(e.rank);return i.fill(1,0,t),i[t]=3,Wh(e,i)}const N8=ne({grayscaleToRGB_:A8});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C8(r){const e=H(r,"image","RGBToGrayscale"),t=e.rank-1,n=e.shape[t];j(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),j(n===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${n}.`);const i=e.dtype,s=$n(e,"float32"),a=Is([.2989,.587,.114]);let o;switch(e.rank){case 2:o=Lc("ij,j->i",s,a);break;case 3:o=Lc("ijk,k->ij",s,a);break;case 4:o=Lc("ijkl,l->ijk",s,a);break;case 5:o=Lc("ijklm,m->ijkl",s,a);break;case 6:o=Lc("ijklmn,n->ijklm",s,a);break;default:throw new Error("Not a valid tensor rank.")}return o=Qo(o,-1),$n(o,i)}const R8=ne({rgbToGrayscale_:C8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I8(r,e,t=0,n=.5){const i=H(r,"image","rotateWithOffset","float32");j(i.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${i.rank}.`);const s={image:i},a={radians:e,fillValue:t,center:n};return ie.runKernel(_R,s,a)}const P8=ne({rotateWithOffset_:I8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dd(r,e,t,n,i,s){n==null&&(n=.5),i==null&&(i=Number.NEGATIVE_INFINITY),s==null&&(s=0);const a=r.shape[0];return t=Math.min(t,a),j(0<=n&&n<=1,()=>`iouThreshold must be in [0, 1], but was '${n}'`),j(r.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${r.rank}'`),j(r.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${r.shape[1]}`),j(e.rank===1,()=>"scores must be a 1D tensor"),j(e.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${e.shape[0]}`),j(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:t,iouThreshold:n,scoreThreshold:i,softNmsSigma:s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L8(r,e,t,n=.5,i=Number.NEGATIVE_INFINITY){const s=H(r,"boxes","nonMaxSuppression","float32"),a=H(e,"scores","nonMaxSuppression","float32"),o=dd(s,a,t,n,i);t=o.maxOutputSize,n=o.iouThreshold,i=o.scoreThreshold;const u={maxOutputSize:t,iouThreshold:n,scoreThreshold:i};return ie.runKernel(hC,{boxes:s,scores:a},u)}const k8=ne({nonMaxSuppression_:L8});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D8(r,e,t){const n=O8(r,e,t),i=n<0?-(n+1):n;r.splice(i,0,e)}function O8(r,e,t){return U8(r,e,t||F8)}function F8(r,e){return r>e?1:r<e?-1:0}function U8(r,e,t){let n=0,i=r.length,s=0,a=!1;for(;n<i;){s=n+(i-n>>>1);const o=t(e,r[s]);o>0?n=s+1:(i=s,a=!o)}return a?n:-n-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h3(r,e,t,n,i){return cw(r,e,t,n,i,0)}function d3(r,e,t,n,i,s){return cw(r,e,t,n,i,0,!1,s,!0)}function p3(r,e,t,n,i,s){return cw(r,e,t,n,i,s,!0)}function cw(r,e,t,n,i,s,a=!1,o=!1,u=!1){const h=[];for(let E=0;E<e.length;E++)e[E]>i&&h.push({score:e[E],boxIndex:E,suppressBeginIndex:0});h.sort(bT);const p=s>0?-.5/s:0,m=[],y=[];for(;m.length<t&&h.length>0;){const E=h.pop(),{score:w,boxIndex:C,suppressBeginIndex:A}=E;if(w<i)break;let I=!1;for(let F=m.length-1;F>=A;--F){const U=z8(r,C,m[F]);if(U>=n){I=!0;break}if(E.score=E.score*B8(n,p,U),E.score<=i)break}E.suppressBeginIndex=m.length,I||(E.score===w?(m.push(C),y.push(E.score)):E.score>i&&D8(h,E,bT))}const v=m.length,S=t-v;o&&S>0&&(m.push(...new Array(S).fill(0)),y.push(...new Array(S).fill(0)));const T={selectedIndices:m};return a&&(T.selectedScores=y),u&&(T.validOutputs=v),T}function z8(r,e,t){const n=r.subarray(e*4,e*4+4),i=r.subarray(t*4,t*4+4),s=Math.min(n[0],n[2]),a=Math.min(n[1],n[3]),o=Math.max(n[0],n[2]),u=Math.max(n[1],n[3]),h=Math.min(i[0],i[2]),p=Math.min(i[1],i[3]),m=Math.max(i[0],i[2]),y=Math.max(i[1],i[3]),v=(o-s)*(u-a),S=(m-h)*(y-p);if(v<=0||S<=0)return 0;const T=Math.max(s,h),E=Math.max(a,p),w=Math.min(o,m),C=Math.min(u,y),A=Math.max(w-T,0)*Math.max(C-E,0);return A/(v+S-A)}function B8(r,e,t){const n=Math.exp(e*t*t);return t<=r?n:0}function bT(r,e){return r.score-e.score||r.score===e.score&&e.boxIndex-r.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function V8(r,e,t,n=.5,i=Number.NEGATIVE_INFINITY){const s=H(r,"boxes","nonMaxSuppressionAsync"),a=H(e,"scores","nonMaxSuppressionAsync"),o=dd(s,a,t,n,i);t=o.maxOutputSize,n=o.iouThreshold,i=o.scoreThreshold;const u=await Promise.all([s.data(),a.data()]),h=u[0],p=u[1],{selectedIndices:m}=h3(h,p,t,n,i);return s!==r&&s.dispose(),a!==e&&a.dispose(),Is(m,"int32")}const H8=V8;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $8(r,e,t,n=.5,i=Number.NEGATIVE_INFINITY,s=0){const a=H(r,"boxes","nonMaxSuppression"),o=H(e,"scores","nonMaxSuppression"),u=dd(a,o,t,n,i,s);t=u.maxOutputSize,n=u.iouThreshold,i=u.scoreThreshold,s=u.softNmsSigma;const h={boxes:a,scores:o},p={maxOutputSize:t,iouThreshold:n,scoreThreshold:i,softNmsSigma:s},m=ie.runKernel(pC,h,p);return{selectedIndices:m[0],selectedScores:m[1]}}const G8=ne({nonMaxSuppressionWithScore_:$8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function W8(r,e,t,n=.5,i=Number.NEGATIVE_INFINITY,s=0){const a=H(r,"boxes","nonMaxSuppressionAsync"),o=H(e,"scores","nonMaxSuppressionAsync"),u=dd(a,o,t,n,i,s);t=u.maxOutputSize,n=u.iouThreshold,i=u.scoreThreshold,s=u.softNmsSigma;const h=await Promise.all([a.data(),o.data()]),p=h[0],m=h[1],{selectedIndices:y,selectedScores:v}=p3(p,m,t,n,i,s);return a!==r&&a.dispose(),o!==e&&o.dispose(),{selectedIndices:Is(y,"int32"),selectedScores:Is(v)}}const j8=W8;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q8(r,e,t,n=.5,i=Number.NEGATIVE_INFINITY,s=!1){const a=H(r,"boxes","nonMaxSuppression"),o=H(e,"scores","nonMaxSuppression"),u=dd(a,o,t,n,i,null),h=u.maxOutputSize,p=u.iouThreshold,m=u.scoreThreshold,y={boxes:a,scores:o},v={maxOutputSize:h,iouThreshold:p,scoreThreshold:m,padToMaxOutputSize:s},S=ie.runKernel(dC,y,v);return{selectedIndices:S[0],validOutputs:S[1]}}const X8=ne({nonMaxSuppressionPadded_:q8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function K8(r,e,t,n=.5,i=Number.NEGATIVE_INFINITY,s=!1){const a=H(r,"boxes","nonMaxSuppressionAsync"),o=H(e,"scores","nonMaxSuppressionAsync"),u=dd(a,o,t,n,i,null),h=u.maxOutputSize,p=u.iouThreshold,m=u.scoreThreshold,[y,v]=await Promise.all([a.data(),o.data()]),{selectedIndices:S,validOutputs:T}=d3(y,v,h,p,m,s);return a!==r&&a.dispose(),o!==e&&o.dispose(),{selectedIndices:Is(S,"int32"),validOutputs:dn(T,"int32")}}const Y8=K8;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z8(r,e,t=!1,n=!1){const i=H(r,"images","resizeBilinear");j(i.rank===3||i.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${i.rank}.`),j(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),j(n===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=i,a=!1;i.rank===3&&(a=!0,s=Le(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const o={images:s},u={alignCorners:t,halfPixelCenters:n,size:e},h=ie.runKernel(IC,o,u);return a?Le(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const J8=ne({resizeBilinear_:Z8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q8(r,e,t=!1,n=!1){const i=H(r,"images","resizeNearestNeighbor");j(i.rank===3||i.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${i.rank}.`),j(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),j(i.dtype==="float32"||i.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),j(n===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=i,a=!1;i.rank===3&&(a=!0,s=Le(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const o={images:s},u={alignCorners:t,halfPixelCenters:n,size:e},h=ie.runKernel(RC,o,u);return a?Le(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const e7=ne({resizeNearestNeighbor_:Q8});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t7(r,e="binary",t=!1,n=.5){const i=H(r,"image","threshold"),s=.2989,a=.587,o=.114,u=i.shape[0]*i.shape[1];let h=st(Is([n]),255),p,m,y,v;if(j(i.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${i.rank}.`),j(i.shape[2]===3||i.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${i.shape[2]}.`),j(i.dtype==="int32"||i.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${i.dtype}.`),j(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),i.shape[2]===3){[p,m,y]=sd(i,[1,1,1],-1);const E=st(p,s),w=st(m,a),C=st(y,o);v=Vt(Vt(E,w),C)}else v=r;if(e==="otsu"){const E=R1($n(nw(v),"int32"),Aa([]),256);h=n7(E,u)}const S=t?Q0(v,h):Bm(v,h);return $n(st(S,255),"int32")}function n7(r,e){let t=Is([-1]),n=Is([0]),i=Is([0]),s,a,o,u,h,p;for(let m=0;m<r.size-1;m++){s=On(r,0,m+1),a=On(r,m+1),h=Vn(Bn(s),e),p=Vn(Bn(a),e);const y=Bn(st(s,rd(0,s.size)));o=Vn(y,Bn(s));const v=fd(a.shape,s.size),S=Vt(rd(0,a.size),v),T=st(a,S);u=Vn(Bn(T),Bn(a));const E=sn(o,u),w=sn(o,u),C=st(h,p);i=st(st(C,E),w);const A=Bm(i,n);n=ol(A,i,n),t=ol(A,Is([m]),t)}return t}const r7=ne({threshold_:t7});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i7(r,e,t="nearest",n="constant",i=0,s){const a=H(r,"image","transform","float32"),o=H(e,"transforms","transform","float32");j(a.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`),j(o.rank===2&&(o.shape[0]===a.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),j(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);const u={image:a,transforms:o},h={interpolation:t,fillMode:n,fillValue:i,outputShape:s};return ie.runKernel(dR,u,h)}const s7=ne({transform_:i7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a7(r,e,t){const n=H(r,"a","bandPart");j(n.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${n.rank}.`);const i=n.shape,[s,a]=n.shape.slice(-2);let o,u;typeof e=="number"?(j(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),j(e<=s,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${s}).`),o=H(e<0?s:e,"numLower","bandPart")):(j(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),o=ol(d0(e,0),s,gm(e,s))),typeof t=="number"?(j(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),j(t<=a,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${a}).`),u=H(t<0?a:t,"numUpper","bandPart")):(j(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),u=ol(d0(t,0),a,gm(t,a)));const h=Le(rd(0,s,1,"int32"),[-1,1]),p=rd(0,a,1,"int32"),m=sn(h,p),y=pm(Q0(m,o),U1(m,Na(u))),v=tf([s,a],n.dtype);return Le(uo(Au(Le(n,[-1,s,a])).map(S=>ol(y,S,v))),i)}const o7=ne({bandPart_:a7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l7(r){let e;if(Array.isArray(r)){e=!1,j(r!=null&&r.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const i=r[0].shape[0];for(let s=1;s<r.length;++s)j(r[s].shape[0]===i,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${r[s].shape[0]} vs. ${i})`)}else e=!0,r=sd(r,r.shape[0],0).map(i=>sv(i,[0]));j(r.length<=r[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${r.length}) exceeds number of dimensions (${r[0].shape[0]}).`);const t=[],n=r;for(let i=0;i<r.length;++i)t.push(ie.tidy(()=>{let s=n[i];if(i>0)for(let a=0;a<i;++a){const o=st(Bn(st(t[a],s)),t[a]);s=sn(s,o)}return Vn(s,zm(s,"euclidean"))}));return e?uo(t,0):t}const u7=ne({gramSchmidt_:l7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c7(r,e=!1){if(j(r.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${r.rank}`),r.rank===2)return TT(r,e);{const t=r.shape.slice(0,r.shape.length-2).reduce((u,h)=>u*h),n=Au(Le(r,[t,r.shape[r.shape.length-2],r.shape[r.shape.length-1]]),0),i=[],s=[];n.forEach(u=>{const[h,p]=TT(u,e);i.push(h),s.push(p)});const a=Le(uo(i,0),r.shape),o=Le(uo(s,0),r.shape);return[a,o]}}function TT(r,e=!1){return ie.tidy(()=>{j(r.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${r.shape.length}D Tensor.`);const t=r.shape[0],n=r.shape[1];let i=D1(t),s=al(r);const a=jh([[1]],[1,1]);let o=al(a);const u=t>=n?n:t;for(let h=0;h<u;++h){const p=s,m=o,y=i;[o,s,i]=ie.tidy(()=>{const v=On(s,[h,h],[t-h,1]),S=zm(v),T=On(s,[h,h],[1,1]),E=ol(Bm(T,0),jh([[-1]]),jh([[1]])),w=sn(T,st(E,S)),C=Vn(v,w);C.shape[0]===1?o=al(a):o=di([a,On(C,[1,0],[C.shape[0]-1,C.shape[1]])],0);const A=Na(Vn(En(E,w),S)),I=On(s,[h,0],[t-h,n]),F=st(A,o),U=vm(o);if(h===0)s=sn(I,En(F,En(U,I)));else{const L=sn(I,En(F,En(U,I)));s=di([On(s,[0,0],[h,n]),L],0)}const V=vm(F),G=On(i,[0,h],[t,i.shape[1]-h]);if(h===0)i=sn(G,En(En(G,o),V));else{const L=sn(G,En(En(G,o),V));i=di([On(i,[0,0],[t,h]),L],1)}return[o,s,i]}),Ci([p,m,y])}return!e&&t>n&&(i=On(i,[0,0],[t,n]),s=On(s,[0,0],[n,n])),[i,s]})}const f7=ne({qr_:c7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ai;(function(r){r[r.NONE=0]="NONE",r[r.MEAN=1]="MEAN",r[r.SUM=2]="SUM",r[r.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Ai||(Ai={}));function h7(r,e,t=Ai.SUM_BY_NONZERO_WEIGHTS){const n=H(r,"losses","computeWeightedLoss");let i=null;e!=null&&(i=H(e,"weights","computeWeightedLoss"));const s=i==null?n:st(n,i);if(t===Ai.NONE)return s;if(t===Ai.SUM)return Bn(s);if(t===Ai.MEAN){if(i==null)return mm(s);{const a=n.size/i.size,o=Vn(Bn(s),Bn(i));return a>1?Vn(o,dn(a)):o}}if(t===Ai.SUM_BY_NONZERO_WEIGHTS){if(i==null)return Vn(Bn(s),dn(n.size));{const a=st(i,ou(n.shape)),o=$n(Bn(q1(a,dn(0))),"float32");return Vn(Bn(s),o)}}throw Error(`Unknown reduction: ${t}`)}const pl=ne({computeWeightedLoss_:h7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d7(r,e,t,n=Ai.SUM_BY_NONZERO_WEIGHTS){const i=H(r,"labels","absoluteDifference"),s=H(e,"predictions","absoluteDifference");let a=null;t!=null&&(a=H(t,"weights","absoluteDifference")),Ii(i.shape,s.shape,"Error in absoluteDifference: ");const o=cs(sn(i,s));return pl(o,a,n)}const p7=ne({absoluteDifference_:d7});function m7(r,e,t,n,i=Ai.SUM_BY_NONZERO_WEIGHTS){const s=H(r,"labels","cosineDistance"),a=H(e,"predictions","cosineDistance");let o=null;n!=null&&(o=H(n,"weights","cosineDistance")),Ii(s.shape,a.shape,"Error in cosineDistance: ");const u=dn(1),h=sn(u,Bn(st(s,a),t,!0));return pl(h,o,i)}const g7=ne({cosineDistance_:m7});function y7(r,e,t,n=Ai.SUM_BY_NONZERO_WEIGHTS){let i=H(r,"labels","hingeLoss");const s=H(e,"predictions","hingeLoss");let a=null;t!=null&&(a=H(t,"weights","hingeLoss")),Ii(i.shape,s.shape,"Error in hingeLoss: ");const o=dn(1);i=sn(st(dn(2),i),o);const u=Hm(sn(o,st(i,s)));return pl(u,a,n)}const v7=ne({hingeLoss_:y7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _7(r,e,t,n=1,i=Ai.SUM_BY_NONZERO_WEIGHTS){const s=H(r,"labels","huberLoss"),a=H(e,"predictions","huberLoss");let o=null;t!=null&&(o=H(t,"weights","huberLoss")),Ii(s.shape,a.shape,"Error in huberLoss: ");const u=dn(n),h=cs(sn(a,s)),p=gm(h,u),m=sn(h,p),y=Vt(st(dn(.5),js(p)),st(u,m));return pl(y,o,i)}const x7=ne({huberLoss_:_7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S7(r,e,t,n=1e-7,i=Ai.SUM_BY_NONZERO_WEIGHTS){const s=H(r,"labels","logLoss"),a=H(e,"predictions","logLoss");let o=null;t!=null&&(o=H(t,"weights","logLoss")),Ii(s.shape,a.shape,"Error in logLoss: ");const u=dn(1),h=dn(n),p=Na(st(s,nd(Vt(a,h)))),m=st(sn(u,s),nd(Vt(sn(u,a),h))),y=sn(p,m);return pl(y,o,i)}const w7=ne({logLoss_:S7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E7(r,e,t,n=Ai.SUM_BY_NONZERO_WEIGHTS){const i=H(r,"labels","meanSquaredError"),s=H(e,"predictions","meanSquaredError");let a=null;t!=null&&(a=H(t,"weights","meanSquaredError")),Ii(i.shape,s.shape,"Error in meanSquaredError: ");const o=iw(i,s);return pl(o,a,n)}const b7=ne({meanSquaredError_:E7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T7(r,e){const t=H(r,"labels","sigmoidCrossEntropyWithLogits"),n=H(e,"logits","sigmoidCrossEntropyWithLogits");Ii(t.shape,n.shape,"Error in sigmoidCrossEntropyWithLogits: ");const i=Hm(n),s=st(n,t),a=B1(xu(Na(cs(n))));return Vt(sn(i,s),a)}function M7(r,e,t,n=0,i=Ai.SUM_BY_NONZERO_WEIGHTS){let s=H(r,"multiClassLabels","sigmoidCrossEntropy");const a=H(e,"logits","sigmoidCrossEntropy");let o=null;if(t!=null&&(o=H(t,"weights","sigmoidCrossEntropy")),Ii(s.shape,a.shape,"Error in sigmoidCrossEntropy: "),n>0){const h=dn(n),p=dn(1),m=dn(.5);s=Vt(st(s,sn(p,h)),st(m,h))}const u=T7(s,a);return pl(u,o,i)}const A7=ne({sigmoidCrossEntropy_:M7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N7(r,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return lo((i,s,a)=>{const u=H1(s,[t],!0),h=sn($n(s,"float32"),u);a([i,h]);const p=Na(st(h,i));return{value:Bn(p,[t]),gradFunc:(v,S)=>{const[T,E]=S,w=Um(v.shape,[t]);return[st(Le(v,w),sn($n(T,"float32"),xu(E))),st(Le(v,w),sn(xu(E),$n(T,"float32")))]}}})(r,e)}function C7(r,e,t,n=0,i=Ai.SUM_BY_NONZERO_WEIGHTS){let s=H(r,"onehotLabels","softmaxCrossEntropy");const a=H(e,"logits","softmaxCrossEntropy");let o=null;if(t!=null&&(o=H(t,"weights","softmaxCrossEntropy")),Ii(s.shape,a.shape,"Error in softmaxCrossEntropy: "),n>0){const h=dn(n),p=dn(1),m=dn(s.shape[1]);s=Vt(st(s,sn(p,h)),Vn(h,m))}const u=N7(s,a);return pl(u,o,i)}const R7=ne({softmaxCrossEntropy_:C7});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I7(r,e,t,n){const i=H(r,"indices","sparseFillEmptyRows","int32"),s=H(e,"values","sparseFillEmptyRows"),a=H(t,"denseShape","sparseFillEmptyRows","int32"),o=H(n,"defaultValue","sparseFillEmptyRows",s.dtype);if(i.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${i.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(a.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${a.shape}`);if(o.rank!==0)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const u={indices:i,values:s,denseShape:a,defaultValue:o},h=ie.runKernel(JC,u);return{outputIndices:h[0],outputValues:h[1],emptyRowIndicator:h[2],reverseIndexMap:h[3]}}const P7=ne({sparseFillEmptyRows_:I7});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L7(r,e,t){const n=H(r,"inputIndices","sparseReshape","int32"),i=H(e,"inputShape","sparseReshape","int32"),s=H(t,"newShape","sparseReshape","int32");if(n.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${n.shape}`);if(i.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${i.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);const a={inputIndices:n,inputShape:i,newShape:s},o=ie.runKernel(QC,a);return{outputIndices:o[0],outputShape:o[1]}}const k7=ne({sparseReshape_:L7});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D7(r,e,t){const n=H(r,"data","sparseSegmentMean"),i=H(e,"indices","sparseSegmentMean","int32"),s=H(t,"segmentIds","sparseSegmentMean","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${i.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);const a={data:n,indices:i,segmentIds:s};return ie.runKernel(eR,a)}const O7=ne({sparseSegmentMean_:D7});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F7(r,e,t){const n=H(r,"data","sparseSegmentSum"),i=H(e,"indices","sparseSegmentSum","int32"),s=H(t,"segmentIds","sparseSegmentSum","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${i.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);const a={data:n,indices:i,segmentIds:s};return ie.runKernel(tR,a)}const U7=ne({sparseSegmentSum_:F7});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z7(r,e,t,n,i,s,a,o){const u=H(r,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);const h=H(e,"dataSplits","stringNGrams");if(h.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const p={separator:t,nGramWidths:n,leftPad:i,rightPad:s,padWidth:a,preserveShortSequences:o},m={data:u,dataSplits:h},y=ie.runKernel(aR,m,p);return{nGrams:y[0],nGramsSplits:y[1]}}const B7=ne({stringNGrams_:z7});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V7(r,e,t=!0){const n=H(r,"input","stringSplit","string"),i=H(e,"delimiter","stringSplit","string");if(n.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${n.shape}`);if(i.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${i.shape}`);const s={skipEmpty:t},a={input:n,delimiter:i},o=ie.runKernel(oR,a,s);return{indices:o[0],values:o[1],shape:o[2]}}const H7=ne({stringSplit_:V7});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $7(r,e){const t=H(r,"input","stringToHashBucketFast","string"),n={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const i={input:t};return ie.runKernel(lR,i,n)}const G7=ne({stringToHashBucketFast_:$7});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W7(r,e,t,n=!0){const i=H(r,"input","staticRegexReplace","string"),s={pattern:e,rewrite:t,replaceGlobal:n};return ie.runKernel(iR,{x:i},s)}const j7=ne({staticRegexReplace_:W7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m3={fft:rv,ifft:ym,rfft:iv,irfft:rw},g3={hammingWindow:v8,hannWindow:c3,frame:f3,stft:w8},y3={flipLeftRight:M8,grayscaleToRGB:N8,resizeNearestNeighbor:e7,resizeBilinear:J8,rgbToGrayscale:R8,rotateWithOffset:P8,cropAndResize:b8,nonMaxSuppression:k8,nonMaxSuppressionAsync:H8,nonMaxSuppressionWithScore:G8,nonMaxSuppressionWithScoreAsync:j8,nonMaxSuppressionPadded:X8,nonMaxSuppressionPaddedAsync:Y8,threshold:r7,transform:s7},v3={bandPart:o7,gramSchmidt:u7,qr:f7},_3={absoluteDifference:p7,computeWeightedLoss:pl,cosineDistance:g7,hingeLoss:v7,huberLoss:x7,logLoss:w7,meanSquaredError:b7,sigmoidCrossEntropy:A7,softmaxCrossEntropy:R7},x3={sparseFillEmptyRows:P7,sparseReshape:k7,sparseSegmentMean:O7,sparseSegmentSum:U7},S3={stringNGrams:B7,stringSplit:H7,stringToHashBucketFast:G7,staticRegexReplace:j7};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q7=new Map,oS=new Map;class w3{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class iu{constructor(){this.classNameMap={}}static getMap(){return iu.instance==null&&(iu.instance=new iu),iu.instance}static register(e){iu.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function E3(r,e,t){j(r.className!=null,()=>"Class being registered does not have the static className property defined."),j(typeof r.className=="string",()=>"className is required to be a string, but got type "+typeof r.className),j(r.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof t>"u"&&(t=r.className);const n=t,i=e+">"+n;return iu.register(r),q7.set(i,r),oS.set(r,i),r}function X7(r){return oS.has(r)?oS.get(r):r.className}const K7=Object.freeze(Object.defineProperty({__proto__:null,Serializable:w3,SerializationMap:iu,getRegisteredName:X7,registerClass:E3},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nu extends w3{minimize(e,t=!1,n){const{value:i,grads:s}=this.computeGradients(e,n);if(n!=null){const a=n.map(o=>({name:o.name,tensor:s[o.name]}));this.applyGradients(a)}else this.applyGradients(s);return Ci(s),t?i:(i.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return KI(e,t)}dispose(){this.iterations_!=null&&Ci(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:dn(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Nu,Symbol.hasInstance,{value:r=>r.minimize!=null&&r.computeGradients!=null&&r.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fw extends Nu{static get className(){return"Adadelta"}constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],n==null&&(this.epsilon=ie.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,i)=>{const s=ie.registeredVariables[n],a=!1;this.accumulatedGrads[i]==null&&(this.accumulatedGrads[i]={originalName:`${n}/accum_grad`,variable:bn(()=>ps(s).variable(a))}),this.accumulatedUpdates[i]==null&&(this.accumulatedUpdates[i]={originalName:`${n}/accum_var`,variable:bn(()=>ps(s).variable(a))});const o=Array.isArray(e)?e[i].tensor:e[n];if(o==null)return;const u=this.accumulatedGrads[i].variable,h=this.accumulatedUpdates[i].variable;bn(()=>{const p=Vt(st(u,this.rho),st(js(o),1-this.rho)),m=st(Vn(oo(Vt(h,this.epsilon)),oo(Vt(u,this.epsilon))),o),y=Vt(st(h,this.rho),st(js(m),1-this.rho));u.assign(p),h.assign(y);const v=Vt(st(m,-this.learningRate),s);s.assign(v)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Ci(this.accumulatedGrads.map(e=>e.variable)),Ci(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map(i=>({originalName:i.name,variable:i.tensor.variable(n)})),this.accumulatedUpdates=e.slice(t,t*2).map(i=>({originalName:i.name,variable:i.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hw extends Nu{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,i)=>{const s=ie.registeredVariables[n];this.accumulatedGrads[i]==null&&(this.accumulatedGrads[i]={originalName:`${n}/accumulator`,variable:bn(()=>fd(s.shape,this.initialAccumulatorValue).variable(!1))});const a=Array.isArray(e)?e[i].tensor:e[n];if(a==null)return;const o=this.accumulatedGrads[i].variable;bn(()=>{const u=Vt(o,js(a));o.assign(u);const h=Vt(st(Vn(a,oo(Vt(u,ie.backend.epsilon()))),-this.learningRate),s);s.assign(h)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Ci(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dw extends Nu{static get className(){return"Adam"}constructor(e,t,n,i=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=i,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],bn(()=>{this.accBeta1=dn(t).variable(),this.accBeta2=dn(n).variable()}),i==null&&(this.epsilon=ie.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);bn(()=>{const n=sn(1,this.accBeta1),i=sn(1,this.accBeta2);t.forEach((s,a)=>{const o=ie.registeredVariables[s],u=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${s}/m`,variable:bn(()=>ps(o).variable(u))}),this.accumulatedSecondMoment[a]==null&&(this.accumulatedSecondMoment[a]={originalName:`${s}/v`,variable:bn(()=>ps(o).variable(u))});const h=Array.isArray(e)?e[a].tensor:e[s];if(h==null)return;const p=this.accumulatedFirstMoment[a].variable,m=this.accumulatedSecondMoment[a].variable,y=Vt(st(p,this.beta1),st(h,1-this.beta1)),v=Vt(st(m,this.beta2),st(js(h),1-this.beta2)),S=Vn(y,n),T=Vn(v,i);p.assign(y),m.assign(v);const E=Vt(st(Vn(S,Vt(oo(T),this.epsilon)),-this.learningRate),o);o.assign(E)}),this.accBeta1.assign(st(this.accBeta1,this.beta1)),this.accBeta2.assign(st(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Ci(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Ci(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),bn(()=>{this.accBeta1.assign(td(this.beta1,this.iterations_+1)),this.accBeta2.assign(td(this.beta2,this.iterations_+1))});const t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map(i=>({originalName:i.name,variable:i.tensor.variable(n)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(i=>({originalName:i.name,variable:i.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pw extends Nu{static get className(){return"Adamax"}constructor(e,t,n,i=null,s=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=i,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],bn(()=>{this.iteration=dn(0).variable(),this.accBeta1=dn(t).variable()}),i==null&&(this.epsilon=ie.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);bn(()=>{const n=sn(1,this.accBeta1),i=Vn(-this.learningRate,Vt(st(this.iteration,this.decay),1));t.forEach((s,a)=>{const o=ie.registeredVariables[s],u=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${s}/m`,variable:ps(o).variable(u)}),this.accumulatedWeightedInfNorm[a]==null&&(this.accumulatedWeightedInfNorm[a]={originalName:`${s}/v`,variable:ps(o).variable(u)});const h=Array.isArray(e)?e[a].tensor:e[s];if(h==null)return;const p=this.accumulatedFirstMoment[a].variable,m=this.accumulatedWeightedInfNorm[a].variable,y=Vt(st(p,this.beta1),st(h,1-this.beta1)),v=st(m,this.beta2),S=cs(h),T=j1(v,S);p.assign(y),m.assign(T);const E=Vt(st(Vn(i,n),Vn(y,Vt(T,this.epsilon))),o);o.assign(E)}),this.iteration.assign(Vt(this.iteration,1)),this.accBeta1.assign(st(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Ci(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Ci(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hv extends Nu{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,i)=>{const s=Array.isArray(e)?e[i].tensor:e[n];if(s==null)return;const a=ie.registeredVariables[n];bn(()=>{const o=Vt(st(this.c,s),a);a.assign(o)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Ma(dn(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mw extends hv{static get className(){return"Momentum"}constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=dn(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,i)=>{const s=ie.registeredVariables[n];this.accumulations[i]==null&&(this.accumulations[i]={originalName:`${n}/momentum`,variable:bn(()=>ps(s).variable(!1))});const a=this.accumulations[i].variable,o=Array.isArray(e)?e[i].tensor:e[n];o!=null&&bn(()=>{let u;const h=Vt(st(this.m,a),o);this.useNesterov?u=Vt(st(this.c,Vt(o,st(h,this.m))),s):u=Vt(st(this.c,h),s),a.assign(h),s.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Ci(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gw extends Nu{static get className(){return"RMSProp"}constructor(e,t=.9,n=0,i=null,s=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=i,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,i==null&&(this.epsilon=ie.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,i)=>{const s=ie.registeredVariables[n],a=!1;this.accumulatedMeanSquares[i]==null&&(this.accumulatedMeanSquares[i]={originalName:`${n}/rms`,variable:bn(()=>ps(s).variable(a))}),this.accumulatedMoments[i]==null&&(this.accumulatedMoments[i]={originalName:`${n}/momentum`,variable:bn(()=>ps(s).variable(a))}),this.accumulatedMeanGrads[i]==null&&this.centered&&(this.accumulatedMeanGrads[i]={originalName:`${n}/mg`,variable:bn(()=>ps(s).variable(a))});const o=Array.isArray(e)?e[i].tensor:e[n];if(o==null)return;const u=this.accumulatedMeanSquares[i].variable,h=this.accumulatedMoments[i].variable;bn(()=>{const p=Vt(st(u,this.decay),st(js(o),1-this.decay));if(this.centered){const m=this.accumulatedMeanGrads[i].variable,y=Vt(st(m,this.decay),st(o,1-this.decay)),v=Vn(st(o,this.learningRate),oo(sn(p,Vt(js(y),this.epsilon)))),S=Vt(st(h,this.momentum),v);u.assign(p),m.assign(y),h.assign(S);const T=sn(s,S);s.assign(T)}else{const m=Vt(st(u,this.decay),st(js(o),1-this.decay)),y=Vt(st(h,this.momentum),Vn(st(o,this.learningRate),oo(Vt(m,this.epsilon))));u.assign(m),h.assign(y);const v=sn(s,y);s.assign(v)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Ci(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Ci(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Ci(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map(i=>({originalName:i.name,variable:i.tensor.variable(n)})),this.accumulatedMoments=e.slice(t,t*2).map(i=>({originalName:i.name,variable:i.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(i=>({originalName:i.name,variable:i.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y7=[fw,hw,dw,pw,mw,gw,hv];function Z7(){for(const r of Y7)E3(r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J7="model",Q7=".json",ej=".weights.bin";function MT(r){return new Promise(e=>setTimeout(e)).then(r)}class nf{constructor(e){if(!Ht().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(nf.URL_SCHEME)&&(e=e.slice(nf.URL_SCHEME.length)),(e==null||e.length===0)&&(e=J7),this.modelJsonFileName=e+Q7,this.weightDataFileName=e+ej}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=ka.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const i=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],s=BR(e,i),a=window.URL.createObjectURL(new Blob([JSON.stringify(s)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=a,await MT(()=>o.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const u=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;u.download=this.weightDataFileName,u.href=n,await MT(()=>u.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:km(e)}}}}nf.URL_SCHEME="downloads://";class tj{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const n=new FileReader;n.onload=i=>{const s=JSON.parse(i.target.result),a=s.modelTopology;if(a==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(s.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:a});return}const u=b1(s,h=>this.loadWeights(h));e(u)},n.onerror=i=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(e){const t=[],n=[];for(const a of e)t.push(...a.weights),n.push(...a.paths);const i=this.checkManifestAndWeightFiles(e),s=n.map(a=>this.loadWeightsFile(a,i[a]));return Promise.all(s).then(a=>[t,a])}loadWeightsFile(e,t){return new Promise((n,i)=>{const s=new FileReader;s.onload=a=>{const o=a.target.result;n(o)},s.onerror=a=>i(`Failed to weights data from file of path '${e}'.`),s.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],n=this.weightsFiles.map(s=>mT(s.name)),i={};for(const s of e)s.paths.forEach(a=>{const o=mT(a);if(t.indexOf(o)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${o}'`);if(t.push(o),n.indexOf(o)===-1)throw new Error(`Weight file with basename '${o}' is not provided.`);i[a]=this.weightsFiles[n.indexOf(o)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return i}}const nj=r=>Ht().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(nf.URL_SCHEME)?rj(r.slice(nf.URL_SCHEME.length)):null;rr.registerSaveRouter(nj);function rj(r="model"){return new nf(r)}function ij(r){return new tj(r)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AT(r,e,t,n){a(r),t=t??0,n=n??1,o(t,n);let i=0;const s=u=>(u.then(h=>{const p=t+ ++i/r.length*(n-t);return e(p),h}),u);function a(u){j(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function o(u,h){j(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),j(h>=0&&h<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${h}`),j(h>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${h}`)}return Promise.all(r.map(s))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function b3(r,e){e==null&&(e={});const t=e.fetchFunc==null?Ht().platform.fetch:e.fetchFunc,n=r.map(m=>t(m,e.requestInit,{isBinary:!0})),o=(e.onProgress==null?await Promise.all(n):await AT(n,e.onProgress,0,.5)).map(m=>m.arrayBuffer());return e.onProgress==null?await Promise.all(o):await AT(o,e.onProgress,.5,1)}function sj(r,e){var t;const n=e.fetchFunc==null?Ht().platform.fetch:e.fetchFunc;let i=0,s;return(t=e.onProgress)===null||t===void 0||t.call(e,0),new ReadableStream({pull:async a=>{for(var o;i<r.length;){s||(s=(await n(r[i],e.requestInit,{isBinary:!0})).body.getReader());const{done:u,value:h}=await s.read();if(u){i++,s=void 0,(o=e.onProgress)===null||o===void 0||o.call(e,i/r.length);continue}a.enqueue(h);return}a.close()}})}async function aj(r,e="",t,n){return T3(a=>b3(a,{requestInit:n}))(r,e,t)}function T3(r){return async(e,t="",n)=>{const i=e.map(()=>!1),s={},a=n!=null?n.map(()=>!1):[],o=[];if(e.forEach((v,S)=>{let T=0;v.weights.forEach(E=>{const w="quantization"in E?E.quantization.dtype:E.dtype,C=Zc[w]*Rn(E.shape),A=()=>{i[S]=!0,s[S]==null&&(s[S]=[]),s[S].push({manifestEntry:E,groupOffset:T,sizeBytes:C})};n!=null?n.forEach((I,F)=>{I===E.name&&(A(),a[F]=!0)}):A(),o.push(E.name),T+=C})}),!a.every(v=>v)){const v=n.filter((S,T)=>!a[T]);throw new Error(`Could not find weights in manifest with names: ${v.join(", ")}. 
Manifest JSON has weights with names: ${o.join(", ")}.`)}const u=i.reduce((v,S,T)=>(S&&v.push(T),v),[]),h=[];u.forEach(v=>{e[v].paths.forEach(S=>{const T=t+(t.endsWith("/")?"":"/")+S;h.push(T)})});const p=await r(h),m={};let y=0;return u.forEach(v=>{const S=e[v].paths.length,T=new ka(p.slice(y,y+S));s[v].forEach(w=>{const C=T.slice(w.groupOffset,w.groupOffset+w.sizeBytes),A=FR(C,[w.manifestEntry]);for(const I in A)m[I]=A[I]}),y+=S}),m}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oj="application/octet-stream",lj="application/json";class yw{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(j(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=Ht().platform.fetch,j(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&j(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],i=BR(e,n);if(t.body.append("model.json",new Blob([JSON.stringify(i)],{type:lj}),"model.json"),e.weightData!=null){const a=ka.join(e.weightData);t.body.append("model.weights.bin",new Blob([a],{type:oj}),"model.weights.bin")}const s=await this.fetch(this.path,t);if(s.ok)return{modelArtifactsInfo:km(e),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}const n=t.modelTopology,i=t.weightsManifest;if(n==null&&i==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const e=await this.loadModelJSON();return b1(e,t=>this.loadWeights(t))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=c0(e.weightsManifest),i=()=>sj(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:i})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,i]=uj(t),s=this.weightPathPrefix||n,a=[],o=[];for(const u of e)for(const h of u.paths)this.weightUrlConverter!=null?o.push(this.weightUrlConverter(h)):a.push(s+h+i);return this.weightUrlConverter&&a.push(...await Promise.all(o)),a}async loadWeights(e){const t=await this.getWeightUrls(e),n=c0(e),i=await b3(t,this.loadOptions);return[n,i]}}yw.URL_SCHEME_REGEX=/^https?:\/\//;function uj(r){const e=r.lastIndexOf("/"),t=r.lastIndexOf("?"),n=r.substring(0,e),i=t>e?r.substring(t):"";return[n+"/",i]}function lS(r){return r.match(yw.URL_SCHEME_REGEX)!=null}const M3=(r,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(r)?t=r.every(n=>lS(n)):t=lS(r),t)return vw(r,e)}return null};rr.registerSaveRouter(M3);rr.registerLoadRouter(M3);function vw(r,e){return new yw(r,e)}function cj(r,e){return vw(r,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class X_{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class A3{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class fj{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function hj(r,e,t,n){const i=arguments;return new fj(m0(...i))}function m0(r,e,t,n){return arguments.length===1?r.modelTopology!=null||r.weightSpecs!=null?new X_(r):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new X_({modelTopology:r})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new X_({modelTopology:r,weightSpecs:e,weightData:t,trainingConfig:n}))}function dj(r){return new A3(r)}function pj(r){return new A3(r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _w=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:ka,browserFiles:ij,browserHTTPRequest:cj,concatenateArrayBuffers:o5,copyModel:C5,decodeWeights:FR,decodeWeightsStream:zR,encodeWeights:t5,fromMemory:hj,fromMemorySync:m0,getLoadHandlers:m5,getModelArtifactsForJSON:b1,getModelArtifactsForJSONSync:E1,getModelArtifactsInfoForJSON:km,getSaveHandlers:p5,getWeightSpecs:c0,http:vw,isHTTPScheme:lS,listModels:A5,loadWeights:aj,moveModel:R5,registerLoadRouter:d5,registerSaveRouter:h5,removeModel:N5,weightsLoaderFactory:T3,withSaveHandler:dj,withSaveHandlerSync:pj},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mj(r,e,t){const n=H(r,"labels","confusionMatrix"),i=H(e,"predictions","confusionMatrix");j(t==null||t>0&&Number.isInteger(t),()=>`If provided, numClasses must be a positive integer, but got ${t}`),j(n.rank===1,()=>`Expected the rank of labels to be 1, but got ${n.rank}`),j(i.rank===1,()=>`Expected the rank of predictions to be 1, but got ${i.rank}`),j(n.shape[0]===i.shape[0],()=>`Mismatch in the number of examples: ${n.shape[0]} vs. ${i.shape[0]}. Labels and predictions should have the same number of elements.`),j(t>0&&Number.isInteger(t),()=>`numClasses is required to be a positive integer, but got ${t}`);const s=p0($n(n,"int32"),t),a=p0($n(i,"int32"),t),o=vm(s),u=En(o,a);return $n(u,"int32")}const gj=ne({confusionMatrix_:mj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yj=Object.freeze(Object.defineProperty({__proto__:null,confusionMatrix:gj},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Tc,NT=!1;function N3(r,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(r==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,n=!1,i=!1,s=!1,a=!1,o=!1;if(r.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&r instanceof ImageData)n=!0;else if(typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement)i=!0;else if(typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement)s=!0;else if(r.getContext!=null)a=!0;else if(typeof ImageBitmap<"u"&&r instanceof ImageBitmap)o=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${r.constructor.name}`);if(om(Gx,ie.backendName)!=null){const S={pixels:r},T={numChannels:e};return ie.runKernel(Gx,S,T)}const[h,p]=i?[r.videoWidth,r.videoHeight]:[r.width,r.height];let m;if(a)m=r.getContext("2d").getImageData(0,0,h,p).data;else if(n||t)m=r.data;else if(s||i||o){if(Tc==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")Tc=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Tc=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Tc.canvas.width=h,Tc.canvas.height=p,Tc.drawImage(r,0,0,h,p),m=Tc.getImageData(0,0,h,p).data}let y;if(e===4)y=new Int32Array(m);else{const S=h*p;y=new Int32Array(S*e);for(let T=0;T<S;T++)for(let E=0;E<e;++E)y[T*e+E]=m[T*4+E]}return aw(y,[p,h,e],"int32")}function vj(r){return r!=null&&r.data instanceof Uint8Array}function _j(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function xj(r){return r!=null&&r.width!==0&&r.height!==0}function Sj(r){return _j()&&!(r instanceof ImageBitmap)&&xj(r)&&!vj(r)}async function wj(r,e=3){let t=null;if(Ht().getBool("WRAP_TO_IMAGEBITMAP")&&Sj(r)){let n;try{n=await createImageBitmap(r,{premultiplyAlpha:"none"})}catch{n=null}n!=null&&n.width===r.width&&n.height===r.height?t=n:t=r}else t=r;return N3(t,e)}function C3(r){if(r.rank!==2&&r.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${r.rank}.`);const e=r.rank===2?1:r.shape[2];if(e>4||e===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${e}`);if(r.dtype!=="float32"&&r.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${r.dtype}. Please use float32 or int32 tensors.`)}function Ej(r){const e=(r==null?void 0:r.alpha)||1;if(e>1||e<0)throw new Error(`Alpha value ${e} is suppoed to be in range [0 - 1].`)}async function bj(r,e){let t=H(r,"img","toPixels");if(!(r instanceof ur)){const h=t;t=$n(h,"int32"),h.dispose()}C3(t);const[n,i]=t.shape.slice(0,2),s=t.rank===2?1:t.shape[2],a=await t.data(),o=t.dtype==="float32"?255:1,u=new Uint8ClampedArray(i*n*4);for(let h=0;h<n*i;++h){const p=[0,0,0,255];for(let y=0;y<s;y++){const v=a[h*s+y];if(t.dtype==="float32"){if(v<0||v>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${v}.`)}else if(t.dtype==="int32"&&(v<0||v>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${v}.`);s===1?(p[0]=v*o,p[1]=v*o,p[2]=v*o):p[y]=v*o}const m=h*4;u[m+0]=Math.round(p[0]),u[m+1]=Math.round(p[1]),u[m+2]=Math.round(p[2]),u[m+3]=Math.round(p[3])}if(e!=null){NT||om(g1,ie.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),NT=!0),e.width=i,e.height=n;const h=e.getContext("2d"),p=new ImageData(u,i,n);h.putImageData(p,0,0)}return t!==r&&t.dispose(),u}function Tj(r,e,t){let n=H(r,"img","draw");if(!(r instanceof ur)){const a=n;n=$n(a,"int32"),a.dispose()}C3(n),Ej(t==null?void 0:t.imageOptions);const i={image:n},s={canvas:e,options:t};ie.runKernel(g1,i,s)}const Mj=ne({fromPixels_:N3}),Aj=Object.freeze(Object.defineProperty({__proto__:null,draw:Tj,fromPixels:Mj,fromPixelsAsync:wj,toPixels:bj},Symbol.toStringTag,{value:"Module"}));function R3(r,e){const t=r.shape.length,n=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(n<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${n}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[n-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[n-1]} vs. ${t}`);if(Rn(r.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${r.shape}.`);const i=e.shape,s=i[i.length-1];let a=1;for(let m=0;m<i.length-1;++m)a*=i[m];const o=r.shape,u=i.slice();u.pop();let h=1;for(let m=s;m<t;++m)h*=o[m],u.push(o[m]);const p=[...cd(r.shape).map(m=>m/h),1].slice(0,s);return[u,a,h,p]}const Nj=Object.freeze(Object.defineProperty({__proto__:null,prepareAndValidate:R3},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uS=-2,Cj=-1;function Rj(r,e,t){const n=r.shape.length;j(n===e.length,()=>`Error in slice${n}D: Length of begin ${e} must match the rank of the array (${n}).`),j(n===t.length,()=>`Error in slice${n}D: Length of size ${t} must match the rank of the array (${n}).`);for(let i=0;i<n;++i)j(e[i]+t[i]<=r.shape[i],()=>`Error in slice${n}D: begin[${i}] + size[${i}] (${e[i]+t[i]}) would overflow input.shape[${i}] (${r.shape[i]})`)}function Ij(r){const e=[];let t=0;for(;r>0;)r&1&&e.push(t),r/=2,t++;return e}function Pj(r,e,t){const n=[];for(let i=0;i<r.length;i++)n[i]=Math.ceil((e[i]-r[i])/t[i]);return n}function I3(r,e,t,n){const i=[...r];for(let s=i.length;s<n.length;s++)i.push(1);for(let s=0;s<t;s++)s===0?i[e]=1:(i.splice(e,0,1),i.pop());return i}function P3(r,e,t){return t<=r?t:t-(e-1)}function L3(r,e){const t=[];for(let n=0;n<r;n++)t.push(e+n);return t}function Lj(r,e,t,n,i,s,a,o,u){const h=r.length;let p=new Array(h),m=new Array(h),y=new Array(h);if(e.length&&t>0){const v=e[0],S=t+1;p=k3(a,v,S,n,r),m=D3(o,v,S,i,r),y=I3(s,v,S,r)}else for(let v=0;v<h;v++)p[v]=F3(a,n,s,r,v,u),m[v]=U3(o,i,s,r,v,u),y[v]=O3(s,v,u);return{begin:p,end:m,strides:y}}function k3(r,e,t,n,i){const s=[...i],a=L3(t,e);for(let o=0;o<s.length;o++)if(a.indexOf(o)>-1)s[o]=0;else{const u=P3(e,t,o);let h=n[u];r&1<<u&&(h=0),s[o]=h}return s}function D3(r,e,t,n,i){const s=[...i],a=L3(t,e);for(let o=0;o<s.length;o++)if(a.indexOf(o)>-1)s[o]=Number.MAX_SAFE_INTEGER;else{const u=P3(e,t,o);let h=n[u];r&1<<u&&(h=Number.MAX_SAFE_INTEGER),s[o]=h}for(let o=0;o<s.length;o++){const u=i[o];s[o]<0&&(s[o]+=u),s[o]=sm(0,s[o],i[o])}return s}function O3(r,e,t){let n=r[e];return(t&1<<e||n==null)&&(n=1),n}function F3(r,e,t,n,i,s){let a=e[i];const o=t[i]||1;(r&1<<i||s&1<<i||a==null)&&(o>0?a=Number.MIN_SAFE_INTEGER:a=Number.MAX_SAFE_INTEGER);const u=n[i];return a<0&&(a+=u),a=sm(0,a,u-1),a}function U3(r,e,t,n,i,s){let a=e[i];const o=t[i]||1;(r&1<<i||s&1<<i||a==null)&&(o>0?a=Number.MAX_SAFE_INTEGER:a=Number.MIN_SAFE_INTEGER);const u=n[i];return a<0&&(a+=u),o>0?a=sm(0,a,u):a=sm(-1,a,u-1),a}function kj(r,e,t){let n=t.length;for(let i=0;i<t.length;i++)if(t[i]>1){n=i;break}for(let i=n+1;i<t.length;i++)if(e[i]>0||t[i]!==r[i])return!1;return!0}function Dj(r,e){let t=r.length>0?r[r.length-1]:1;for(let n=0;n<r.length-1;n++)t+=r[n]*e[n];return t}function Oj(r,e,t){let n;const i=r.shape.length;typeof e=="number"?n=[e,...new Array(i-1).fill(0)]:e.length<i?n=e.concat(new Array(i-e.length).fill(0)):n=e.slice(),n.forEach(a=>{j(a!==-1,()=>"slice() does not support negative begin indexing.")});let s;return t==null?s=new Array(i).fill(-1):typeof t=="number"?s=[t,...new Array(i-1).fill(-1)]:t.length<i?s=t.concat(new Array(i-t.length).fill(-1)):s=t,s=s.map((a,o)=>a>=0?a:(j(a===-1,()=>`Negative size values should be exactly -1 but got ${a} for the slice() size at index ${o}.`),r.shape[o]-n[o])),[n,s]}function Fj(r,e,t,n,i,s,a,o,u){let h;if(n==null?(h=new Array(e.length),h.fill(1)):h=n,a!=null&&(a&a-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let p=!1;const m={dims:h.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:h.slice(),beginMask:i,endMask:s,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:u};for(let A=0;A<m.dims;A++)p&&(1<<A&o)!==0&&m.numAddAxisAfterEllipsis++,1<<A&a&&(p=!0);p||(m.ellipsisMask|=1<<m.dims,m.dims++);const y={dims:r.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};Uj(m,y);let v=!0,S=!0,T=!0;const E=[],w=[];for(let A=0;A<r.length;++A){if(y.strides[A]===0)throw Error(`strides[${A}] must be non-zero`);const I=!!(y.shrinkAxisMask&1<<A),F=r[A];if(F===-1){E.push(I?1:-1);continue}const U=[y.beginMask&1<<A,y.endMask&1<<A],V=[y.strides[A]>0?0:-1,y.strides[A]>0?F:F-1];if(I&&y.strides[A]<=0)throw Error("only stride 1 allowed on non-range indexing.");T=T&&y.strides[A]===1;const G=!!(y.beginMask&1<<A&&y.endMask&1<<A);if(y.beginValid&&y.endValid){if(I){const Q=y.begin[A]<0?F+y.begin[A]:y.begin[A];if(y.begin[A]=Q,y.end[A]=y.begin[A]+1,Q<0||Q>=F)throw Error(`slice index ${y.begin[A]} of dimension ${A} out of bounds.`)}else y.begin[A]=CT(y.begin[A],0,y.strides[A],F,U,V),y.end[A]=CT(y.end[A],1,y.strides[A],F,U,V);const O=y.strides[A]===1&&y.begin[A]===0&&y.end[A]===F;v=v&&O,S=S&&(A===0&&y.strides[A]===1||O)}else v=v&&y.strides[A]===1&&G,S=S&&(A===0&&y.strides[A]===1||G);let L,k=!1;if(y.beginValid&&y.endValid?(L=y.end[A]-y.begin[A],k=!0):I?(L=1,k=!0):G&&F>=0&&(y.strides[A]<0?L=-F:L=F,k=!0),k){let O;L===0||L<0!=y.strides[A]<0?O=0:O=Math.trunc(L/y.strides[A])+(L%y.strides[A]!==0?1:0),E.push(O)}else E.push(-1)}for(let A=0;A<y.finalShapeGatherIndices.length;++A){const I=y.finalShapeGatherIndices[A];I>=0?w.push(E[I]):I===uS&&w.push(1)}return{finalShapeSparse:w.filter((A,I)=>y.finalShapeGatherIndices[I]!==uS),finalShape:w,isIdentity:v,sliceDim0:S,isSimpleSlice:T,begin:y.begin,end:y.end,strides:y.strides}}function Uj(r,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=r.begin!=null,e.endValid=r.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let n=0;n<r.dims;n++)if(1<<n&r.ellipsisMask){const i=Math.min(e.dims-(r.dims-n)+1+r.numAddAxisAfterEllipsis,e.dims);for(;t<i;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=n}else if(1<<n&r.newAxisMask)e.finalShapeGatherIndices.push(uS),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);r.begin!=null&&(e.begin[t]=r.begin[n]),r.end!=null&&(e.end[t]=r.end[n]),e.strides[t]=r.strides[n],r.beginMask&1<<n&&(e.beginMask|=1<<t),r.endMask&1<<n&&(e.endMask|=1<<t),r.shrinkAxisMask&1<<n?(e.finalShapeGatherIndices.push(Cj),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(n)),e.inputShapeGatherIndicesSparse[t]=n,t++}}function CT(r,e,t,n,i,s){if(i[e])return t>0?s[e]:s[e+1&1];{const a=r<0?n+r:r;return a<s[0]?s[0]:a>s[1]?s[1]:a}}const z3=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:Rj,computeFlatOffset:Dj,computeOutShape:Pj,getNormalizedAxes:Lj,isSliceContinous:kj,maskToAxes:Ij,parseSliceParams:Oj,sliceInfo:Fj,startForAxis:F3,startIndicesWithElidedDims:k3,stopForAxis:U3,stopIndicesWithElidedDims:D3,stridesForAxis:O3,stridesWithElidedDims:I3},Symbol.toStringTag,{value:"Module"}));/** @license See the LICENSE file. */const zj="4.22.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class B3{static sgd(e){return new hv(e)}static momentum(e,t,n=!1){return new mw(e,t,n)}static rmsprop(e,t=.9,n=0,i=null,s=!1){return new gw(e,t,n,i,s)}static adam(e=.001,t=.9,n=.999,i=null){return new dw(e,t,n,i)}static adadelta(e=.001,t=.95,n=null){return new fw(e,t,n)}static adamax(e=.002,t=.9,n=.999,i=null,s=0){return new pw(e,t,n,i,s)}static adagrad(e,t=.1){return new hw(e,t)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bj=B3;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vj=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:r=>r();function Hj(){return new Promise(r=>Vj(()=>r()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $j(r,e){const t=r[0].length;r.forEach((i,s)=>{j(i.length===t,()=>`Error in concat${t}D: rank of tensors[${s}] must be the same as the rank of the rest (${t})`)}),j(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const n=r[0];r.forEach((i,s)=>{for(let a=0;a<t;a++)j(a===e||i[a]===n[a],()=>`Error in concat${t}D: Shape of tensors[${s}] (${i}) does not match the shape of the rest (${n}) along the non-concatenated axis ${s}.`)})}function Gj(r,e){const t=r[0].slice();for(let n=1;n<r.length;n++)t[e]+=r[n][e];return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ya;(function(r){r[r.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",r[r.VALUE_ROWIDS=1]="VALUE_ROWIDS",r[r.ROW_LENGTHS=2]="ROW_LENGTHS",r[r.ROW_SPLITS=3]="ROW_SPLITS",r[r.ROW_LIMITS=4]="ROW_LIMITS",r[r.ROW_STARTS=5]="ROW_STARTS"})(Ya||(Ya={}));function Wj(r,e,t){let n=new Array;if(t==null&&e==null)return n;if(e==null)for(;n.length<r+t.length;)n.push(-1);else n=e.slice();if(t==null)return n;if(r+t.length!==n.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${r+t.length}, but shape.rank = ${n.length}`);for(let i=1;i<t.length;++i){const s=t[i],a=n[n.length-t.length+i],o=n[a];if(s>=0)if(o>=0){if(o!==s)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${i+r}] = ${s} but shape[${i+r}] = ${o}`)}else n[a]=s}return n}function jj(r){const e={FIRST_DIM_SIZE:Ya.FIRST_DIM_SIZE,VALUE_ROWIDS:Ya.VALUE_ROWIDS,ROW_LENGTHS:Ya.ROW_LENGTHS,ROW_SPLITS:Ya.ROW_SPLITS,ROW_LIMITS:Ya.ROW_LIMITS,ROW_STARTS:Ya.ROW_STARTS},t=[];for(const n of r)if(n in e)t.push(e[n]);else break;return t}function qj(r){return r.length===0?0:r[0]===Ya.FIRST_DIM_SIZE?r.length-1:r.length}function Xj(r,e){if(r==null||e==null)return;const t=r.length,n=e.length;if(t>=n)throw new Error(`defaultValue.shape=${r} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${n})`);for(let i=0;i<Math.min(t,n-1);++i){const s=r[i],a=e[i+1];if(s>=0&&a>=0&&s!==1&&s!==a)throw new Error(`defaultValue.shape=${r}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${i-r.length}] = ${s} but ragged tensor input.flatValues.shape[${i-r.length}] = ${a}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xw=30;function Kj(r){return r<=xw?r:a0(r,Math.floor(Math.sqrt(r)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yj(r,e,t){const n=t*(typeof r=="number"?r:r[0]),i=e*(typeof r=="number"?r:r[1]);return[n,i]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zj(r,e,t,n=!0){let i=[];if(n)i=i.concat(e.slice(0)),i.push(r[0]/t),i=i.concat(r.slice(1));else{i=i.concat(r[0]);const s=e.length;for(let a=0;a<s;++a)i=i.concat([r[a+1]/e[a],e[a]]);i=i.concat(r.slice(s+1))}return i}function Jj(r,e,t=!0){const n=[];if(t){n.push(e);for(let i=e+1;i<r;++i)i<=2*e?(n.push(i),n.push(i-(e+1))):n.push(i)}else{const i=[],s=[];for(let a=1;a<r;++a)a>=e*2+1||a%2===1?s.push(a):i.push(a);n.push(...i),n.push(0),n.push(...s)}return n}function Qj(r,e,t,n=!0){const i=[];n?i.push(r[0]/t):i.push(r[0]*t);for(let s=1;s<r.length;++s)s<=e.length?n?i.push(e[s-1]*r[s]):i.push(r[s]/e[s-1]):i.push(r[s]);return i}function e9(r,e){const t=[0];for(let n=0;n<e;++n)t.push(r[n][0]);return t}function t9(r,e,t){const n=r.slice(0,1);for(let i=0;i<t;++i)n.push(r[i+1]-e[i][0]-e[i][1]);return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n9=1.7580993408473768,r9=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i9=.3275911,s9=.254829592,a9=-.284496736,o9=1.421413741,l9=-1.453152027,u9=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c9(r,e){if(r.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${r.length}, imag: ${e.length}.`);const t=new Float32Array(r.length*2);for(let n=0;n<t.length;n+=2)t[n]=r[n/2],t[n+1]=e[n/2];return t}function f9(r){const e=new Float32Array(r.length/2),t=new Float32Array(r.length/2);for(let n=0;n<r.length;n+=2)e[n/2]=r[n],t[n/2]=r[n+1];return{real:e,imag:t}}function h9(r){const e=Math.ceil(r.length/4),t=new Float32Array(e),n=new Float32Array(e);for(let i=0;i<r.length;i+=4)t[Math.floor(i/4)]=r[i],n[Math.floor(i/4)]=r[i+1];return{real:t,imag:n}}function d9(r){const e=Math.floor(r.length/4),t=new Float32Array(e),n=new Float32Array(e);for(let i=2;i<r.length;i+=4)t[Math.floor(i/4)]=r[i],n[Math.floor(i/4)]=r[i+1];return{real:t,imag:n}}function p9(r,e){const t=r[e*2],n=r[e*2+1];return{real:t,imag:n}}function m9(r,e,t,n){r[n*2]=e,r[n*2+1]=t}function g9(r,e){const t=new Float32Array(r/2),n=new Float32Array(r/2);for(let i=0;i<Math.ceil(r/2);i++){const s=(e?2:-2)*Math.PI*(i/r);t[i]=Math.cos(s),n[i]=Math.sin(s)}return{real:t,imag:n}}function y9(r,e,t){const n=(t?2:-2)*Math.PI*(r/e),i=Math.cos(n),s=Math.sin(n);return{real:i,imag:s}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K_="->",v9=/->/g,RT=",",IT="...";function _9(r,e){r=r.replace(/\s/g,"");const t=(r.length-r.replace(v9,"").length)/K_.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${K_}").`);const[n,i]=r.split(K_);j(n.indexOf(IT)===-1,()=>`The ellipsis notation ("${IT}") is not supported yet.`);const s=n.split(RT),a=s.length;if(e!==a)throw new Error(`Expected ${a} input tensors, received ${e}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let y=0;y<i.length;++y){const v=i[y];if(!s.some(S=>S.indexOf(v)!==-1))throw new Error(`Output subscripts contain the label ${v} not present in the input subscripts.`);o.indexOf(v)===-1&&o.push(v)}for(let y=0;y<n.length;++y){const v=n[y];o.indexOf(v)===-1&&v!==RT&&o.push(v)}const u=new Array(s.length);for(let y=0;y<a;++y){if(new Set(s[y].split("")).size!==s[y].length)throw new Error(`Found duplicate axes in input component ${s[y]}. Support for duplicate axes in input is not implemented yet.`);u[y]=[];for(let v=0;v<s[y].length;++v)u[y].push(o.indexOf(s[y][v]))}const h=o.length,p=i.length,m=[];for(let y=p;y<h;++y)m.push(y);return{allDims:o,summedDims:m,idDims:u}}function x9(r,e){let t=new Array(r);t.fill(-1);for(let i=0;i<e.length;++i)t[e[i]]=i;const n=[];for(let i=0;i<r;++i)t[i]===-1&&n.push(i);return t=t.filter(i=>i!==-1),{permutationIndices:t,expandDims:n}}function S9(r,e,t){const n=new Array(r);for(let i=0;i<t.length;++i){const s=t[i].shape;for(let a=0;a<e[i].length;++a)n[e[i][a]]===void 0?n[e[i][a]]=s[a]:j(n[e[i][a]]===s[a],()=>`Expected dimension ${n[e[i][a]]} at axis ${a} of input shaped ${JSON.stringify(s)}, but got dimension ${s[a]}`)}}function w9(r,e){const t=r,n=[];let i=0;r.length===0&&t.push(-1),i=r.length+1;for(let a=0;a<i;++a)n.push([]);const s=[];for(let a=0;a<t.length;++a){const o=t[a],u=b9(e,o);for(const h of u)s.indexOf(h)===-1&&(n[a].push(h),s.push(h))}return{path:t,steps:n}}function E9(r){return r.every((e,t)=>e===t)}function b9(r,e){const t=[];for(let n=0;n<r.length;++n)(r[n].length===0||r[n].indexOf(e)!==-1||e===-1)&&t.push(n);return t}function T9(r,e,t=0){let n=[];if(typeof e=="number")j(r.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),n=new Array(e).fill(r.shape[t]/e);else{const i=e.reduce((a,o)=>(o===-1&&(a+=1),a),0);j(i<=1,()=>"There should be only one negative value in split array.");const s=e.indexOf(-1);if(s!==-1){const a=e.reduce((o,u)=>u>0?o+u:o);e[s]=r.shape[t]-a}j(r.shape[t]===e.reduce((a,o)=>a+o),()=>"The sum of sizes must match the size of the axis dimension."),n=e}return n}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M9(r){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${r}`}function A9(r,e){return`indices(${r}, 0) is invalid: ${e} < 0`}function N9(r,e,t){return`indices(${r}, 0) is invalid: ${e} >= ${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C9(r,e){return`only one output dimension may be -1, not both ${r} and ${e}`}function R9(r,e){return`size ${r} must be non-negative, not ${e}`}function I9(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function P9(r,e){const t=Rn(r),n=Rn(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${n}. inputShape=${r} outputShape= ${e}`}function L9(r,e){const t=Rn(r),n=Rn(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${n}. inputShape=${r} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k9(){return"segment ids must be >= 0"}function D9(){return"segment ids are not increasing"}function O9(r,e){return`Segment id ${r} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function F9(r,e,t){return`Bad: indices[${r}] == ${e} out of range [0, ${t})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U9(r,e){let t=!1,n;for(r<=xw?(n=r,t=!0):n=a0(r,Math.floor(Math.sqrt(r)));!t;)n>e||n===r?t=!0:n=a0(r,n+1);return n}function z9(r,e,t){const n=[],i=r.length;for(let s=0;s<i;s++)s!==e?n.push(r[s]):n.push(t);return n}function B9(r,e,t,n){const i=e.shape.length,s=r.shape.length;if(n!==0&&(n<-i||n>i))throw new Error(`Expect batchDims in the range of [-${i}, ${i}], but got ${n}`);if(n<0&&(n+=i),n>s)throw new Error(`batchDims (${n}) must be less than rank(x) (
    ${s}).`);if(t<n)throw new Error(`batchDims (${n}) must be less than or equal to axis (${t}).`);for(let m=0;m<n;++m)if(r.shape[m]!==e.shape[m])throw new Error(`x.shape[${m}]: ${r.shape[m]} should be equal to indices.shape[${m}]: ${e.shape[m]}.`);const a=r.shape[t],o=[];let u=1,h=1,p=1;for(let m=0;m<n;++m)o.push(r.shape[m]),u*=r.shape[m];for(let m=n;m<t;m++)o.push(r.shape[m]),h*=r.shape[m];for(let m=n;m<i;m++)o.push(e.shape[m]);for(let m=t+1;m<s;m++)o.push(r.shape[m]),p*=r.shape[m];return{batchSize:u,sliceSize:p,outerSize:h,dimSize:a,outputShape:o}}const V9=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:B9,computeOutShape:z9,segOpComputeOptimalWindowSize:U9},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H9(r){try{return r.map(e=>l0(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function $9(r){return r.map(e=>Lm(e))}const G9=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:s9,ERF_A2:a9,ERF_A3:o9,ERF_A4:l9,ERF_A5:u9,ERF_P:i9,PARALLELIZE_THRESHOLD:xw,get RowPartitionType(){return Ya},SELU_SCALE:r9,SELU_SCALEALPHA:n9,applyActivation:cv,assertAndGetBroadcastShape:Tr,assertAxesAreInnerMostDims:sG,assertParamsConsistent:$j,assignToTypedArray:m9,axesAreInnerMostDims:k1,calculateShapes:qP,checkEinsumDimSizes:S9,checkPadOnDimRoundingMode:qs,combineLocations:BI,combineRaggedTensorToTensorShapes:Wj,complexWithEvenIndex:h9,complexWithOddIndex:d9,computeConv2DInfo:Dm,computeConv3DInfo:oI,computeDefaultPad:A1,computeDilation2DInfo:e$,computeOptimalWindowSize:Kj,computeOutAndReduceShapes:iG,computeOutShape:Gj,computePool2DInfo:aI,computePool3DInfo:t$,convertConv2DDataFormat:lI,decodeEinsumEquation:_9,eitherStridesOrDilationsAreOne:dl,expandShapeToKeepDim:Um,exponent:y9,exponents:g9,fromStringArrayToUint8:$9,fromUint8ToStringArray:H9,getAxesPermutation:aG,getBroadcastDims:DI,getComplexWithIndex:p9,getEinsumComputePath:w9,getEinsumPermutation:x9,getFusedBiasGradient:uv,getFusedDyActivation:lv,getImageCenter:Yj,getInnerMostAxes:lG,getPermuted:Jj,getRaggedRank:qj,getReductionAxes:I1,getReshaped:Zj,getReshapedPermuted:Qj,getRowPartitionTypesHelper:jj,getSliceBeginCoords:e9,getSliceSize:t9,getSparseFillEmptyRowsIndicesDenseShapeMismatch:M9,getSparseFillEmptyRowsNegativeIndexErrorMessage:A9,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:N9,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:I9,getSparseReshapeInputOutputMismatchErrorMessage:L9,getSparseReshapeInputOutputMultipleErrorMessage:P9,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:C9,getSparseReshapeNegativeOutputDimErrorMessage:R9,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:F9,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:k9,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:D9,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:O9,getUndoAxesPermutation:oG,isIdentityPermutation:E9,log:tH,mergeRealAndImagArrays:c9,prepareAndValidate:R3,prepareSplitSize:T9,segment_util:V9,shouldFuse:fv,slice_util:z3,splitRealAndImagArrays:f9,stridesOrDilationsArePositive:ef,tupleValuesAreOne:dm,upcastType:Z0,validateDefaultValueShape:Xj,validateInput:av,validateUpdateShape:ow,warn:ru},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W9=Object.freeze(Object.defineProperty({__proto__:null,nonMaxSuppressionV3Impl:h3,nonMaxSuppressionV4Impl:d3,nonMaxSuppressionV5Impl:p3,whereImpl:t3},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Z7();const j9=Object.freeze(Object.defineProperty({__proto__:null,Abs:I2,Acos:P2,Acosh:L2,AdadeltaOptimizer:fw,AdagradOptimizer:hw,AdamOptimizer:dw,AdamaxOptimizer:pw,Add:p1,AddN:k2,All:D2,Any:O2,ArgMax:F2,ArgMin:U2,Asin:z2,Asinh:B2,Atan:V2,Atan2:$2,Atanh:H2,AvgPool:G2,AvgPool3D:W2,AvgPool3DGrad:FV,AvgPoolGrad:OV,BatchMatMul:j2,BatchToSpaceND:q2,Bincount:X2,BitwiseAnd:K2,BroadcastArgs:Y2,BroadcastTo:UV,Cast:m1,Ceil:Z2,ClipByValue:J2,Complex:Q2,ComplexAbs:eN,Concat:tN,Conv2D:nN,Conv2DBackpropFilter:rN,Conv2DBackpropInput:iN,Conv3D:sN,Conv3DBackpropFilterV2:zV,Conv3DBackpropInputV2:aN,Cos:oN,Cosh:lN,CropAndResize:fN,Cumprod:uN,Cumsum:cN,DataStorage:pV,DenseBincount:hN,DepthToSpace:dN,DepthwiseConv2dNative:pN,DepthwiseConv2dNativeBackpropFilter:mN,DepthwiseConv2dNativeBackpropInput:gN,Diag:yN,Dilation2D:vN,Dilation2DBackpropFilter:VV,Dilation2DBackpropInput:BV,Draw:g1,get ENV(){return h1},Einsum:xN,Elu:SN,EluGrad:HV,Environment:C2,Equal:EN,Erf:wN,Exp:bN,ExpandDims:TN,Expm1:MN,FFT:AN,Fill:NN,FlipLeftRight:CN,Floor:RN,FloorDiv:IN,FromPixels:Gx,FusedBatchNorm:PN,FusedConv2D:jx,FusedDepthwiseConv2D:qx,GatherNd:kN,GatherV2:LN,Greater:DN,GreaterEqual:ON,IFFT:FN,Identity:y1,Imag:UN,IsFinite:zN,IsInf:BN,IsNan:VN,KernelBackend:v2,LRN:ZN,LRNGrad:jV,LeakyRelu:HN,Less:$N,LessEqual:GN,LinSpace:WN,Log:jN,Log1p:qN,LogSoftmax:GV,LogicalAnd:XN,LogicalNot:KN,LogicalOr:YN,LogicalXor:$V,LowerBound:WV,MatrixBandPart:qV,Max:JN,MaxPool:eC,MaxPool3D:tC,MaxPool3DGrad:KV,MaxPoolGrad:XV,MaxPoolWithArgmax:nC,Maximum:QN,Mean:rC,Min:iC,Minimum:sC,MirrorPad:aC,Mod:oC,MomentumOptimizer:mw,Multinomial:lC,Multiply:uC,Neg:cC,NonMaxSuppressionV3:hC,NonMaxSuppressionV4:dC,NonMaxSuppressionV5:pC,NotEqual:fC,OP_SCOPE_SUFFIX:S1,OneHot:gC,OnesLike:mC,Optimizer:Nu,OptimizerConstructors:B3,Pack:yC,PadV2:vC,Pool:YV,Pow:_C,Prelu:xC,Prod:SC,RMSPropOptimizer:gw,RaggedGather:wC,RaggedRange:EC,RaggedTensorToTensor:bC,Range:TC,get Rank(){return Yx},Real:MC,RealDiv:_N,Reciprocal:AC,get Reduction(){return Ai},Relu:NC,Relu6:PC,Reshape:CC,ResizeBilinear:IC,ResizeBilinearGrad:JV,ResizeNearestNeighbor:RC,ResizeNearestNeighborGrad:ZV,Reverse:LC,RotateWithOffset:_R,Round:kC,Rsqrt:DC,SGDOptimizer:hv,ScatterNd:OC,SearchSorted:UC,Select:zC,Selu:BC,Sigmoid:WC,Sign:GC,Sin:HC,Sinh:$C,Slice:VC,Softmax:ZC,Softplus:jC,SpaceToBatchND:KC,SparseFillEmptyRows:JC,SparseReshape:QC,SparseSegmentMean:eR,SparseSegmentSum:tR,SparseToDense:nR,SplitV:YC,Sqrt:qC,Square:QV,SquaredDifference:rR,StaticRegexReplace:iR,Step:vR,StridedSlice:sR,StringNGrams:aR,StringSplit:oR,StringToHashBucketFast:lR,Sub:uR,Sum:XC,Tan:cR,Tanh:fR,Tensor:ur,TensorBuffer:u0,TensorScatterUpdate:FC,Tile:v1,TopK:hR,Transform:dR,Transpose:By,Unique:pR,Unpack:mR,UnsortedSegmentSum:gR,UpperBound:eH,Variable:um,ZerosLike:yR,_FusedMatMul:Wx,abs:cs,acos:XR,acosh:KR,add:Vt,addN:YR,all:ZR,any:JR,argMax:QR,argMin:eI,asin:tI,asinh:nI,atan:rI,atan2:iI,atanh:sI,avgPool:N1,avgPool3d:uI,backend:OR,backend_util:G9,basicLSTMCell:cI,batchNorm:Om,batchNorm2d:fI,batchNorm3d:hI,batchNorm4d:dI,batchToSpaceND:C1,bincount:R1,bitwiseAnd:pI,booleanMaskAsync:n3,broadcastArgs:mI,broadcastTo:Op,broadcast_util:X$,browser:Aj,buffer:ao,cast:$n,ceil:gI,clipByValue:yI,clone:al,complex:fl,concat:di,concat1d:vI,concat2d:_I,concat3d:xI,concat4d:SI,conv1d:wI,conv2d:Fm,conv2dTranspose:bI,conv3d:TI,conv3dTranspose:MI,copyRegisteredKernels:sH,cos:AI,cosh:NI,cosineWindow:ov,cumprod:CI,cumsum:RI,customGrad:lo,denseBincount:II,deprecationWarn:HH,depthToSpace:PI,depthwiseConv2d:J0,device_util:OH,diag:LI,dilation2d:kI,disableDeprecationWarnings:VH,dispose:Ci,disposeVariables:$H,div:Vn,divNoNan:OI,dot:FI,dropout:o3,einsum:Lc,elu:L1,enableDebugMode:BH,enableProdMode:zH,enclosingPowerOfTwo:uw,engine:GH,ensureShape:UI,env:Ht,equal:P1,erf:zI,euclideanNorm:HI,exp:xu,expandDims:Qo,expm1:$I,eye:D1,fft:rv,fill:fd,findBackend:ZH,findBackendFactory:JH,floor:O1,floorDiv:M1,fused:u3,gather:F1,gatherND:a3,gather_util:Nj,getBackend:DR,getGradient:Xx,getKernel:om,getKernelsForBackend:o0,grad:OG,grads:FG,greater:Bm,greaterEqual:U1,ifft:ym,imag:Vm,image:y3,inTopKAsync:l3,io:_w,irfft:rw,isFinite:GI,isInf:WI,isNaN:jI,keep:Ma,kernel_impls:W9,leakyRelu:z1,less:d0,lessEqual:Q0,linalg:v3,linspace:qI,localResponseNormalization:XI,log:nd,log1p:B1,logSigmoid:YI,logSoftmax:ZI,logSumExp:H1,logicalAnd:pm,logicalNot:$1,logicalOr:G1,logicalXor:JI,losses:_3,lowerBound:QI,matMul:En,math:yj,max:jc,maxPool:W1,maxPool3d:eP,maxPoolWithArgmax:tP,maximum:j1,mean:mm,memory:WH,meshgrid:nP,min:h0,minimum:gm,mirrorPad:rP,mod:iP,moments:sP,movingAverage:r3,mul:st,multiRNNCell:aP,multinomial:oP,neg:Na,nextFrame:Hj,norm:zm,notEqual:q1,oneHot:p0,ones:ou,onesLike:lP,op:ne,outerProduct:uP,pad:hd,pad1d:cP,pad2d:fP,pad3d:hP,pad4d:dP,pool:pP,pow:td,prelu:K1,print:T1,prod:mP,profile:jH,raggedGather:gP,raggedRange:yP,raggedTensorToTensor:vP,rand:_P,randomGamma:wP,randomNormal:ew,randomStandardNormal:EP,randomUniform:nv,randomUniformInt:bP,range:rd,ready:KH,real:id,reciprocal:TP,registerBackend:QH,registerGradient:nH,registerKernel:xR,relu:Hm,relu6:tw,removeBackend:YH,reshape:Le,reverse:Su,reverse1d:MP,reverse2d:AP,reverse3d:NP,reverse4d:CP,rfft:iv,round:nw,rsqrt:RP,scalar:dn,scatterND:i3,scatter_util:V6,searchSorted:tv,selu:IP,separableConv2d:PP,serialization:K7,setBackend:XH,setPlatform:e5,setdiff1dAsync:LP,sigmoid:Wc,sign:kP,signal:g3,sin:DP,sinh:OP,slice:On,slice1d:FP,slice2d:UP,slice3d:zP,slice4d:BP,slice_util:z3,softmax:VP,softplus:V1,spaceToBatchND:X1,sparse:x3,sparseToDense:s3,spectral:m3,split:sd,sqrt:oo,square:js,squaredDifference:iw,squeeze:sv,stack:uo,step:sw,stridedSlice:HP,string:S3,sub:sn,sum:Bn,sumOutType:AH,tan:$P,tanh:f0,tensor:Aa,tensor1d:Is,tensor2d:jh,tensor3d:aw,tensor4d:GP,tensor5d:WP,tensor6d:jP,tensorScatterUpdate:XP,tensor_util:RH,test_util:e6,tidy:bn,tile:Wh,time:qH,topk:KP,train:Bj,transpose:vm,truncatedNormal:YP,unique:ZP,unregisterGradient:iH,unregisterKernel:rH,unsortedSegmentSum:JP,unstack:Au,upcastType:Z0,upperBound:QP,util:gH,valueAndGrad:UG,valueAndGrads:zG,variable:e3,variableGrads:KI,version_core:zj,where:ol,whereAsync:lw,zeros:tf,zerosLike:ps},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q9=Ht();q9.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,r=>{r&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var ls;(function(r){r[r.DT_INVALID=0]="DT_INVALID",r[r.DT_FLOAT=1]="DT_FLOAT",r[r.DT_DOUBLE=2]="DT_DOUBLE",r[r.DT_INT32=3]="DT_INT32",r[r.DT_UINT8=4]="DT_UINT8",r[r.DT_INT16=5]="DT_INT16",r[r.DT_INT8=6]="DT_INT8",r[r.DT_STRING=7]="DT_STRING",r[r.DT_COMPLEX64=8]="DT_COMPLEX64",r[r.DT_INT64=9]="DT_INT64",r[r.DT_BOOL=10]="DT_BOOL",r[r.DT_QINT8=11]="DT_QINT8",r[r.DT_QUINT8=12]="DT_QUINT8",r[r.DT_QINT32=13]="DT_QINT32",r[r.DT_BFLOAT16=14]="DT_BFLOAT16",r[r.DT_QINT16=15]="DT_QINT16",r[r.DT_QUINT16=16]="DT_QUINT16",r[r.DT_UINT16=17]="DT_UINT16",r[r.DT_COMPLEX128=18]="DT_COMPLEX128",r[r.DT_HALF=19]="DT_HALF",r[r.DT_RESOURCE=20]="DT_RESOURCE",r[r.DT_VARIANT=21]="DT_VARIANT",r[r.DT_UINT32=22]="DT_UINT32",r[r.DT_UINT64=23]="DT_UINT64",r[r.DT_FLOAT_REF=101]="DT_FLOAT_REF",r[r.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",r[r.DT_INT32_REF=103]="DT_INT32_REF",r[r.DT_UINT8_REF=104]="DT_UINT8_REF",r[r.DT_INT16_REF=105]="DT_INT16_REF",r[r.DT_INT8_REF=106]="DT_INT8_REF",r[r.DT_STRING_REF=107]="DT_STRING_REF",r[r.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",r[r.DT_INT64_REF=109]="DT_INT64_REF",r[r.DT_BOOL_REF=110]="DT_BOOL_REF",r[r.DT_QINT8_REF=111]="DT_QINT8_REF",r[r.DT_QUINT8_REF=112]="DT_QUINT8_REF",r[r.DT_QINT32_REF=113]="DT_QINT32_REF",r[r.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",r[r.DT_QINT16_REF=115]="DT_QINT16_REF",r[r.DT_QUINT16_REF=116]="DT_QUINT16_REF",r[r.DT_UINT16_REF=117]="DT_UINT16_REF",r[r.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",r[r.DT_HALF_REF=119]="DT_HALF_REF",r[r.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",r[r.DT_VARIANT_REF=121]="DT_VARIANT_REF",r[r.DT_UINT32_REF=122]="DT_UINT32_REF",r[r.DT_UINT64_REF=123]="DT_UINT64_REF"})(ls||(ls={}));var PT;(function(r){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(r.CheckpointFormatVersion||(r.CheckpointFormatVersion={}))})(PT||(PT={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sw={};function X9(r,e){const t={tfOpName:r,category:"custom",inputs:[],attrs:[],customExecutor:e};Sw[r]=t}function V3(r){return Sw[r]}function K9(r){delete Sw[r]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P(r,e,t,n,i){const s=e.inputParams[r];if(s&&s.inputIndexStart!==void 0){const o=s.inputIndexStart,u=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?o+1:s.inputIndexEnd,h=o<0?e.inputNames.length+o:o;if(s.type==="tensor")return ei(e.inputNames[h],t,n,i);if(s.type==="tensors"){const y=e.inputs.slice(o,u);return e.inputNames.slice(o,u).filter((S,T)=>{var E;return((E=y[T])===null||E===void 0?void 0:E.op)!=="NoOp"}).map(S=>ei(S,t,n,i))}const p=ei(e.inputNames[h],t,n,i),m=p.dataSync();return s.type==="number"?m[0]:Gc(p.shape,m)}const a=e.attrParams[r];return a&&a.value}function ei(r,e,t,n){const[i,s]=us(r,t);if(n!=null){const o=n.getHashTableHandleByName(i);if(o!=null)return o}const a=t.currentContextIds.find(o=>!!e[g0(i,o)]);return a!==void 0?e[g0(i,a)][s]:void 0}function LT(r,e,t){return e[g0(r,t.currentContextId)]}function el(r,e){const[t,n,i]=us(r,e);return[g0(t,e&&e.currentContextId),n,i]}function g0(r,e){return e?`${r}-${e}`:r}function us(r,e){if(r==="")return["",0,void 0];const t=e!=null&&e.parseNodeNameCache!=null;if(t){const s=e.parseNodeNameCache.get(r);if(s!=null)return s}const n=r.split(":");let i;if(n.length===1)i=[r,0,void 0];else{const s=n[0],a=n.length===3?n[1]:void 0,o=Number(n[n.length-1]);i=[s,o,a]}return t&&e.parseNodeNameCache.set(r,i),i}function Yy(r,e,t){let n=P("pad",r,e,t);if(n==="explicit"){n=P("explicitPaddings",r,e,t);const i=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)i[s][0]=n[s*2],i[s][1]=n[s*2+1];return i}return n}function tl(r){return r.kept?r:al(r)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y9=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Z9=Object.freeze(Object.defineProperty({__proto__:null,json:Y9},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J9=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Q9=Object.freeze(Object.defineProperty({__proto__:null,json:J9},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eq=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],tq=Object.freeze(Object.defineProperty({__proto__:null,json:eq},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nq=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],rq=Object.freeze(Object.defineProperty({__proto__:null,json:nq},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iq=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],sq=Object.freeze(Object.defineProperty({__proto__:null,json:iq},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aq=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],oq=Object.freeze(Object.defineProperty({__proto__:null,json:aq},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lq=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],uq=Object.freeze(Object.defineProperty({__proto__:null,json:lq},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cq=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],fq=Object.freeze(Object.defineProperty({__proto__:null,json:cq},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hq=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],dq=Object.freeze(Object.defineProperty({__proto__:null,json:hq},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pq=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],mq=Object.freeze(Object.defineProperty({__proto__:null,json:pq},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gq=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],yq=Object.freeze(Object.defineProperty({__proto__:null,json:gq},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vq=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],_q=Object.freeze(Object.defineProperty({__proto__:null,json:vq},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xq=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],Sq=Object.freeze(Object.defineProperty({__proto__:null,json:xq},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wq=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Eq=Object.freeze(Object.defineProperty({__proto__:null,json:wq},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bq=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Tq=Object.freeze(Object.defineProperty({__proto__:null,json:bq},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mq=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Aq=Object.freeze(Object.defineProperty({__proto__:null,json:Mq},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nq=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Cq=Object.freeze(Object.defineProperty({__proto__:null,json:Nq},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rq=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Iq=Object.freeze(Object.defineProperty({__proto__:null,json:Rq},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pq=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],Lq=Object.freeze(Object.defineProperty({__proto__:null,json:Pq},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kT{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[Z9,Q9,tq,rq,sq,oq,uq,fq,dq,mq,yq,_q,Sq,Eq,Tq,Aq,Cq,Iq,Lq],t=[].concat(...e.map(n=>n.json));this.opMappers=t.reduce((n,i)=>(n[i.tfOpName]=i,n),{})}transformGraph(e,t={}){const n=e.node,i=[],s=[],a=[],o=n.reduce((T,E)=>(T[E.name]=this.mapNode(E),E.op.startsWith("Placeholder")?i.push(T[E.name]):E.op==="Const"?s.push(T[E.name]):(E.input==null||E.input.length===0)&&a.push(T[E.name]),T),{});let u=[];const h=[];let p={},m={};t!=null&&(p=this.mapSignatureEntries(t.inputs),m=this.mapSignatureEntries(t.outputs));const y=Object.keys(o);y.forEach(T=>{const E=o[T];E.inputNames.forEach((w,C)=>{const[A,,I]=el(w),F=o[A];if(F.outputs!=null){const U=F.outputs.indexOf(I);if(U!==-1){const V=`${A}:${U}`;E.inputNames[C]=V}}E.inputs.push(F),F.children.push(E)})}),Object.keys(m).length===0?y.forEach(T=>{const E=o[T];E.children.length===0&&h.push(E)}):Object.keys(m).forEach(T=>{const[E]=el(T),w=o[E];w!=null&&(w.signatureKey=m[T],h.push(w))}),Object.keys(p).length>0?Object.keys(p).forEach(T=>{const[E]=el(T),w=o[E];w&&(w.signatureKey=p[T],u.push(w))}):u=i;let v={};e.library!=null&&e.library.function!=null&&(v=e.library.function.reduce((T,E)=>(T[E.signature.name]=this.mapFunction(E),T),{}));const S={nodes:o,inputs:u,outputs:h,weights:s,placeholders:i,signature:t,functions:v};return a.length>0&&(S.initNodes=a),S}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){const t=V3(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(i=>i.startsWith("^")?i.slice(1):i),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(n.inputParams=t.inputs.reduce((i,s)=>(i[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},i),{})),t.attrs!=null&&(n.attrParams=t.attrs.reduce((i,s)=>{const a=s.type;let o;switch(s.type){case"string":o=cS(e.attr,s.tfName,s.defaultValue),o===void 0&&s.tfDeprecatedName&&(o=cS(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":o=yS(e.attr,s.tfName,s.defaultValue),o===void 0&&s.tfDeprecatedName&&(o=yS(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":o=hS(e.attr,s.tfName,s.defaultValue||0),o===void 0&&s.tfDeprecatedName&&(o=hS(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":o=gS(e.attr,s.tfName,s.defaultValue),o===void 0&&s.tfDeprecatedName&&(o=gS(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":o=fS(e.attr,s.tfName,s.defaultValue),o===void 0&&s.tfDeprecatedName&&(o=fS(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":o=_S(e.attr,s.tfName,s.defaultValue),o===void 0&&s.tfDeprecatedName&&(o=_S(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":o=mS(e.attr,s.tfName,s.defaultValue),o===void 0&&s.tfDeprecatedName&&(o=mS(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":o=vS(e.attr,s.tfName,s.defaultValue),o===void 0&&s.tfDeprecatedName&&(o=vS(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":o=dS(e.attr,s.tfName,s.defaultValue),o===void 0&&s.tfDeprecatedName&&(o=dS(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":o=pS(e.attr,s.tfName,s.defaultValue),o===void 0&&s.tfDeprecatedName&&(o=pS(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":o=DT(e.attr,s.tfName,s.defaultValue),o===void 0&&s.tfDeprecatedName&&(o=DT(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${e.op}`)}return i[s.name]={value:o,type:a},i},{})),n}mapFunction(e){const t=e.nodeDef,n=[],i=[];let s={};t!=null&&(s=t.reduce((m,y)=>(m[y.name]=this.mapNode(y),y.op==="Const"&&i.push(m[y.name]),m),{}));const a=[],o=[];e.signature.inputArg.forEach(m=>{const[y]=el(m.name),v={name:y,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:ww(m.type),type:"dtype"}},children:[]};v.signatureKey=m.name,a.push(v),s[y]=v}),Object.keys(s).forEach(m=>{const y=s[m];y.inputNames.forEach((v,S)=>{const[T,,E]=el(v),w=s[T];if(w.outputs!=null){const C=w.outputs.indexOf(E);if(C!==-1){const A=`${T}:${C}`;y.inputNames[S]=A}}y.inputs.push(w),w.children.push(y)})});const h=e.ret;e.signature.outputArg.forEach(m=>{const[y,v]=el(h[m.name]),S=s[y];S!=null&&(S.defaultOutput=v,o.push(S))});const p=this.mapArgsToSignature(e);return{nodes:s,inputs:a,outputs:o,weights:i,placeholders:n,signature:p}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n),t),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return t!=null&&(n=t[n]),{name:n,dtype:e.type}}}function kq(r){const e=Ht().global;if(typeof e.atob<"u")return e.atob(r);if(typeof Buffer<"u")return new Buffer(r,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function H3(r,e){const t=Array.isArray(r)?String.fromCharCode.apply(null,r):kq(r);return e?t:t.toLowerCase()}function cS(r,e,t,n=!1){const i=r[e];return i!=null?H3(i.s,n):t}function fS(r,e,t){const n=r[e];return n?n.b:t}function hS(r,e,t){const n=r[e]||{},i=n.i!=null?n.i:n.f!=null?n.f:t;return typeof i=="number"?i:parseInt(i,10)}function ww(r){switch(typeof r=="string"&&(r=ls[r]),r){case ls.DT_FLOAT:case ls.DT_HALF:return"float32";case ls.DT_INT32:case ls.DT_INT64:case ls.DT_INT8:case ls.DT_UINT8:return"int32";case ls.DT_BOOL:return"bool";case ls.DT_DOUBLE:return"float32";case ls.DT_STRING:return"string";case ls.DT_COMPLEX64:case ls.DT_COMPLEX128:return"complex64";default:return null}}function DT(r,e,t){const n=r[e];return n&&n.func?n.func.name:t}function dS(r,e,t){const n=r[e];return n&&n.type?ww(n.type):t}function pS(r,e,t){const n=r[e];return n&&n.list&&n.list.type?n.list.type.map(i=>ww(i)):t}function $3(r){if(!r.unknownRank)return r.dim!=null?r.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function mS(r,e,t){const n=r[e];return n&&n.shape?$3(n.shape):t}function gS(r,e,t){const n=r[e];return n?((n.list.f&&n.list.f.length?n.list.f:n.list.i)||[]).map(i=>typeof i=="number"?i:parseInt(i,10)):t}function yS(r,e,t,n=!1){const i=r[e];return i&&i.list&&i.list.s?i.list.s.map(s=>H3(s,n)):t}function vS(r,e,t){const n=r[e];return n&&n.list&&n.list.shape?n.list.shape.map(i=>$3(i)):t}function _S(r,e,t){const n=r[e];return n&&n.list&&n.list.b?n.list.b:t}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dq{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(i=>this.getInput(i)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((i,s)=>(i[s]=this.getAttr(s),i),{}))}getInput(e){return ei(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(n.tensor!=null)return ei(e,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return hS(this.node.rawAttrs,e,t);if(n.s!=null)return cS(this.node.rawAttrs,e,t);if(n.b!=null)return fS(this.node.rawAttrs,e,t);if(n.shape!=null)return mS(this.node.rawAttrs,e,t);if(n.type!=null)return dS(this.node.rawAttrs,e,t);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return gS(this.node.rawAttrs,e,t);if(n.list.s!=null)return yS(this.node.rawAttrs,e,t);if(n.list.shape!=null)return vS(this.node.rawAttrs,e,t);if(n.list.b!=null)return _S(this.node.rawAttrs,e,t);if(n.list.type!=null)return pS(this.node.rawAttrs,e,t)}return t}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ti=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:S1,abs:cs,acos:XR,acosh:KR,add:Vt,addN:YR,all:ZR,any:JR,argMax:QR,argMin:eI,asin:tI,asinh:nI,atan:rI,atan2:iI,atanh:sI,avgPool:N1,avgPool3d:uI,basicLSTMCell:cI,batchNorm:Om,batchNorm2d:fI,batchNorm3d:hI,batchNorm4d:dI,batchToSpaceND:C1,bincount:R1,bitwiseAnd:pI,booleanMaskAsync:n3,broadcastArgs:mI,broadcastTo:Op,buffer:ao,cast:$n,ceil:gI,clipByValue:yI,clone:al,complex:fl,concat:di,concat1d:vI,concat2d:_I,concat3d:xI,concat4d:SI,conv1d:wI,conv2d:Fm,conv2dTranspose:bI,conv3d:TI,conv3dTranspose:MI,cos:AI,cosh:NI,cosineWindow:ov,cumprod:CI,cumsum:RI,denseBincount:II,depthToSpace:PI,depthwiseConv2d:J0,diag:LI,dilation2d:kI,div:Vn,divNoNan:OI,dot:FI,dropout:o3,einsum:Lc,elu:L1,enclosingPowerOfTwo:uw,ensureShape:UI,equal:P1,erf:zI,euclideanNorm:HI,exp:xu,expandDims:Qo,expm1:$I,eye:D1,fft:rv,fill:fd,floor:O1,floorDiv:M1,fused:u3,gather:F1,gatherND:a3,greater:Bm,greaterEqual:U1,ifft:ym,imag:Vm,image:y3,inTopKAsync:l3,irfft:rw,isFinite:GI,isInf:WI,isNaN:jI,leakyRelu:z1,less:d0,lessEqual:Q0,linalg:v3,linspace:qI,localResponseNormalization:XI,log:nd,log1p:B1,logSigmoid:YI,logSoftmax:ZI,logSumExp:H1,logicalAnd:pm,logicalNot:$1,logicalOr:G1,logicalXor:JI,losses:_3,lowerBound:QI,matMul:En,max:jc,maxPool:W1,maxPool3d:eP,maxPoolWithArgmax:tP,maximum:j1,mean:mm,meshgrid:nP,min:h0,minimum:gm,mirrorPad:rP,mod:iP,moments:sP,movingAverage:r3,mul:st,multiRNNCell:aP,multinomial:oP,neg:Na,norm:zm,notEqual:q1,oneHot:p0,ones:ou,onesLike:lP,op:ne,outerProduct:uP,pad:hd,pad1d:cP,pad2d:fP,pad3d:hP,pad4d:dP,pool:pP,pow:td,prelu:K1,print:T1,prod:mP,raggedGather:gP,raggedRange:yP,raggedTensorToTensor:vP,rand:_P,randomGamma:wP,randomNormal:ew,randomStandardNormal:EP,randomUniform:nv,randomUniformInt:bP,range:rd,real:id,reciprocal:TP,relu:Hm,relu6:tw,reshape:Le,reverse:Su,reverse1d:MP,reverse2d:AP,reverse3d:NP,reverse4d:CP,rfft:iv,round:nw,rsqrt:RP,scalar:dn,scatterND:i3,searchSorted:tv,selu:IP,separableConv2d:PP,setdiff1dAsync:LP,sigmoid:Wc,sign:kP,signal:g3,sin:DP,sinh:OP,slice:On,slice1d:FP,slice2d:UP,slice3d:zP,slice4d:BP,softmax:VP,softplus:V1,spaceToBatchND:X1,sparse:x3,sparseToDense:s3,spectral:m3,split:sd,sqrt:oo,square:js,squaredDifference:iw,squeeze:sv,stack:uo,step:sw,stridedSlice:HP,string:S3,sub:sn,sum:Bn,tan:$P,tanh:f0,tensor:Aa,tensor1d:Is,tensor2d:jh,tensor3d:aw,tensor4d:GP,tensor5d:WP,tensor6d:jP,tensorScatterUpdate:XP,tile:Wh,topk:KP,transpose:vm,truncatedNormal:YP,unique:ZP,unsortedSegmentSum:JP,unstack:Au,upperBound:QP,variable:e3,where:ol,whereAsync:lw,zeros:tf,zerosLike:ps},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oq=(r,e,t,n=ti)=>{switch(r.op){case"BiasAdd":case"AddV2":case"Add":return[n.add(P("a",r,e,t),P("b",r,e,t))];case"AddN":return[n.addN(P("tensors",r,e,t))];case"FloorMod":case"Mod":return[n.mod(P("a",r,e,t),P("b",r,e,t))];case"Mul":return[n.mul(P("a",r,e,t),P("b",r,e,t))];case"RealDiv":case"Div":return[n.div(P("a",r,e,t),P("b",r,e,t))];case"DivNoNan":return[n.divNoNan(P("a",r,e,t),P("b",r,e,t))];case"FloorDiv":return[n.floorDiv(P("a",r,e,t),P("b",r,e,t))];case"Sub":return[n.sub(P("a",r,e,t),P("b",r,e,t))];case"Minimum":return[n.minimum(P("a",r,e,t),P("b",r,e,t))];case"Maximum":return[n.maximum(P("a",r,e,t),P("b",r,e,t))];case"Pow":return[n.pow(P("a",r,e,t),P("b",r,e,t))];case"SquaredDifference":return[n.squaredDifference(P("a",r,e,t),P("b",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fq=(r,e,t,n=ti)=>{switch(r.op){case"Abs":case"ComplexAbs":return[n.abs(P("x",r,e,t))];case"Acos":return[n.acos(P("x",r,e,t))];case"Acosh":return[n.acosh(P("x",r,e,t))];case"Asin":return[n.asin(P("x",r,e,t))];case"Asinh":return[n.asinh(P("x",r,e,t))];case"Atan":return[n.atan(P("x",r,e,t))];case"Atan2":return[n.atan2(P("x",r,e,t),P("y",r,e,t))];case"Atanh":return[n.atanh(P("x",r,e,t))];case"Ceil":return[n.ceil(P("x",r,e,t))];case"Complex":return[n.complex(P("real",r,e,t),P("imag",r,e,t))];case"Cos":return[n.cos(P("x",r,e,t))];case"Cosh":return[n.cosh(P("x",r,e,t))];case"Elu":return[n.elu(P("x",r,e,t))];case"Erf":return[n.erf(P("x",r,e,t))];case"Exp":return[n.exp(P("x",r,e,t))];case"Expm1":return[n.expm1(P("x",r,e,t))];case"Floor":return[n.floor(P("x",r,e,t))];case"Log":return[n.log(P("x",r,e,t))];case"Log1p":return[n.log1p(P("x",r,e,t))];case"Imag":return[n.imag(P("x",r,e,t))];case"Neg":return[n.neg(P("x",r,e,t))];case"Reciprocal":return[n.reciprocal(P("x",r,e,t))];case"Real":return[n.real(P("x",r,e,t))];case"Relu":return[n.relu(P("x",r,e,t))];case"Round":return[n.round(P("x",r,e,t))];case"Selu":return[n.selu(P("x",r,e,t))];case"Sigmoid":return[n.sigmoid(P("x",r,e,t))];case"Sin":return[n.sin(P("x",r,e,t))];case"Sign":return[n.sign(P("x",r,e,t))];case"Sinh":return[n.sinh(P("x",r,e,t))];case"Softplus":return[n.softplus(P("x",r,e,t))];case"Sqrt":return[n.sqrt(P("x",r,e,t))];case"Square":return[n.square(P("x",r,e,t))];case"Tanh":return[n.tanh(P("x",r,e,t))];case"Tan":return[n.tan(P("x",r,e,t))];case"ClipByValue":return[n.clipByValue(P("x",r,e,t),P("clipValueMin",r,e,t),P("clipValueMax",r,e,t))];case"Relu6":return[n.relu6(P("x",r,e,t))];case"Rsqrt":return[n.rsqrt(ei(r.inputNames[0],e,t))];case"LeakyRelu":return[n.leakyRelu(P("x",r,e,t),P("alpha",r,e,t))];case"Prelu":return[n.prelu(P("x",r,e,t),P("alpha",r,e,t))];case"IsNan":return[n.isNaN(ei(r.inputNames[0],e,t))];case"IsInf":return[n.isInf(ei(r.inputNames[0],e,t))];case"IsFinite":return[n.isFinite(ei(r.inputNames[0],e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ws(r,e,t=""){if(!(typeof r=="number"||typeof e=="number")){j(r.length===e.length,()=>t+` Shapes ${r} and ${e} must match`);for(let n=0;n<r.length;n++){const i=r[n],s=e[n];j(i<0||s<0||i===s,()=>t+` Shapes ${r} and ${e} must match`)}}}function OT(r){return!(typeof r=="number"||r.some(e=>e<0))}function Ep(r,e,t){let n=xS(r,t);const i=!OT(n);if(i&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${n}`);if(i&&e.forEach(s=>{n=xS(s.shape,n)}),!OT(n))throw new Error(`Non-fully-defined elementShape: ${n}`);return n}function xS(r,e){if(typeof r=="number")return e;if(typeof e=="number")return r;if(r.length!==e.length)throw new Error(`Incompatible ranks during merge: ${r} vs. ${e}`);const t=[];for(let n=0;n<r.length;++n){const i=r[n],s=e[n];if(i>=0&&s>=0&&i!==s)throw new Error(`Incompatible shape during merge: ${r} vs. ${e}`);t[n]=i>=0?i:s}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Uq{constructor(e,t,n,i,s,a,o){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=i,this.identicalElementShapes=s,this.dynamicSize=a,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=dn(0),Ma(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),Ws(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,Ma(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((n,i)=>this.write(n,t[i]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let i=0;i<this.size();i++)e.push(i)}if(e.length===0)return Aa([],[0].concat(this.elementShape));const n=this.readMany(e);return Ws(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),uo(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Aa([],[0].concat(this.elementShape));const t=[];for(let i=0;i<this.size();i++)t.push(i);const n=this.readMany(t);return Ws(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),di(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,Au(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0;const i=e.map(u=>(n+=u,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const s=n===0?0:t.size/n,a=[];bn(()=>{t=Le(t,[1,n,s]);for(let u=0;u<e.length;++u){const p=[0,u===0?0:i[u-1],0],m=[1,e[u],s];a[u]=Le(On(t,p,m),this.elementShape)}return a});const o=[];for(let u=0;u<e.length;u++)o[u]=u;this.writeMany(o,a)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rf{get id(){return this.idTensor.id}constructor(e,t,n,i=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,e!=null&&e.forEach(s=>{if(n!==s.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${s.dtype}`);Ws(t,s.shape,"TensorList shape mismatch: "),Ma(s)}),this.idTensor=dn(0),this.maxNumElements=i,Ma(this.idTensor)}copy(){return new rf([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(n!==-1&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);Ws(e,this.elementShape,"TensorList shape mismatch: ");const i=Ep(this.elementShape,this.tensors,e);return bn(()=>{const s=this.tensors.map(a=>Le(a,i));return uo(s,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const n=Ep(this.elementShape,this.tensors,e),i=this.tensors.pop();return i.kept=!1,Ws(i.shape,e,"TensorList shape mismatch: "),Le(i,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Ws(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Ma(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new rf([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);Ws(this.tensors[e].shape,t,"TensorList shape mismatch: ");const i=Ep(this.elementShape,this.tensors,t);return Le(this.tensors[e],i)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Ws(this.elementShape,t.shape,"TensorList shape mismatch: "),Ma(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Ws(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const i=Ep(this.elementShape,this.tensors,n);return e.length===0?Aa([],[0].concat(i)):bn(()=>{const s=e.map(a=>Le(this.tensors[a],i));return uo(s,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Ws(this.elementShape,t,"TensorList shape mismatch: ");const n=Ep(this.elementShape,this.tensors,t);return this.size()===0?Aa([],[0].concat(n)):bn(()=>{const i=this.tensors.map(s=>Le(s,n));return di(i,0)})}}function zq(r,e,t){const n=r.dtype;if(r.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${r.shape}`);if(r.dtype!==t)throw new Error(`Invalid data types; op elements ${r.dtype}, but list elements ${t}`);const i=r.shape.slice(1);Ws(i,e,"TensorList shape mismatch: ");const s=Au(r);return new rf(s,e,n)}function Bq(r,e,t,n){return new rf([],r,e,n)}function Vq(r,e,t,n){if(e.length!==r.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${r.shape[0]}`);const i=Math.max(...e);if(n!=null&&n!==-1&&i>=n)throw new Error(`Max index must be < array size (${i}  vs. ${n})`);const s=new rf([],t,r.dtype,n),a=Au(r,0);return e.forEach((o,u)=>{s.setItem(o,a[u])}),s}function Hq(r,e,t){let n=0;const i=e.map(p=>(n+=p,n));if(n!==r.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${r.shape}`);const s=r.shape.slice(1),a=xS(s,t),o=n===0?0:r.size/n,u=bn(()=>{const p=[];r=Le(r,[1,n,o]);for(let m=0;m<e.length;++m){const v=[0,m===0?0:i[m-1],0],S=[1,e[m],o];p[m]=Le(On(r,v,S),a)}return r.dispose(),p}),h=new rf([],t,r.dtype,e.length);for(let p=0;p<u.length;p++)h.setItem(p,u[p]);return h}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $q=async(r,e,t)=>{switch(r.op){case"If":case"StatelessIf":{const n=P("thenBranch",r,e,t),i=P("elseBranch",r,e,t),s=P("cond",r,e,t),a=P("args",r,e,t);return(await s.data())[0]?t.functionMap[n].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap):t.functionMap[i].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const n=P("body",r,e,t),i=P("cond",r,e,t),s=P("args",r,e,t),a=await t.functionMap[i].executeFunctionAsync(s,t.tensorArrayMap,t.tensorListMap),o=s.map(p=>p.id);let u=await a[0].data();a.forEach(p=>{!p.kept&&o.indexOf(p.id)===-1&&p.dispose()});let h=s;for(;u[0];){const p=h;h=await t.functionMap[n].executeFunctionAsync(h,t.tensorArrayMap,t.tensorListMap);const m=h.map(v=>v.id);p.forEach(v=>{!v.kept&&o.indexOf(v.id)===-1&&m.indexOf(v.id)===-1&&v.dispose()});const y=await t.functionMap[i].executeFunctionAsync(h,t.tensorArrayMap,t.tensorListMap);u=await y[0].data(),y.forEach(v=>{!v.kept&&o.indexOf(v.id)===-1&&m.indexOf(v.id)===-1&&v.dispose()})}return h}case"LoopCond":{const n=P("pred",r,e,t);return[tl(n)]}case"Switch":{const n=P("pred",r,e,t);let i=P("data",r,e,t);return i.kept||(i=tl(i)),(await n.data())[0]?[void 0,i]:[i,void 0]}case"Merge":{const n=r.inputNames.find(i=>ei(i,e,t)!==void 0);if(n){const i=ei(n,e,t);return[tl(i)]}return}case"Enter":{const n=P("frameName",r,e,t),i=P("tensor",r,e,t);return t.enterFrame(n),[tl(i)]}case"Exit":{const n=P("tensor",r,e,t);return t.exitFrame(),[tl(n)]}case"NextIteration":{const n=P("tensor",r,e,t);return t.nextIteration(),[tl(n)]}case"TensorArrayV3":{const n=P("size",r,e,t),i=P("dtype",r,e,t),s=P("elementShape",r,e,t),a=P("dynamicSize",r,e,t),o=P("clearAfterRead",r,e,t),u=P("identicalElementShapes",r,e,t),h=P("name",r,e,t),p=new Uq(h,i,n,s,u,a,o);return t.addTensorArray(p),[p.idTensor,dn(1)]}case"TensorArrayWriteV3":{const n=P("tensorArrayId",r,e,t),i=P("index",r,e,t),s=P("tensor",r,e,t),a=t.getTensorArray(n.id);return a.write(i,s),[a.idTensor]}case"TensorArrayReadV3":{const n=P("tensorArrayId",r,e,t),i=P("index",r,e,t);return[t.getTensorArray(n.id).read(i)]}case"TensorArrayGatherV3":{const n=P("tensorArrayId",r,e,t),i=P("indices",r,e,t),s=P("dtype",r,e,t);return[t.getTensorArray(n.id).gather(i,s)]}case"TensorArrayScatterV3":{const n=P("tensorArrayId",r,e,t),i=P("indices",r,e,t),s=P("tensor",r,e,t),a=t.getTensorArray(n.id);return a.scatter(i,s),[a.idTensor]}case"TensorArrayConcatV3":{const n=P("tensorArrayId",r,e,t),i=t.getTensorArray(n.id),s=P("dtype",r,e,t);return[i.concat(s)]}case"TensorArraySplitV3":{const n=P("tensorArrayId",r,e,t),i=P("tensor",r,e,t),s=P("lengths",r,e,t),a=t.getTensorArray(n.id);return a.split(s,i),[a.idTensor]}case"TensorArraySizeV3":{const n=P("tensorArrayId",r,e,t),i=t.getTensorArray(n.id);return[dn(i.size(),"int32")]}case"TensorArrayCloseV3":{const n=P("tensorArrayId",r,e,t),i=t.getTensorArray(n.id);return i.clearAndClose(),[i.idTensor]}case"TensorListSetItem":{const n=P("tensorListId",r,e,t),i=P("index",r,e,t),s=P("tensor",r,e,t),a=t.getTensorList(n.id);return a.setItem(i,s),[a.idTensor]}case"TensorListGetItem":{const n=P("tensorListId",r,e,t),i=P("index",r,e,t),s=P("elementShape",r,e,t),a=P("elementDType",r,e,t);return[t.getTensorList(n.id).getItem(i,s,a)]}case"TensorListScatterV2":case"TensorListScatter":{const n=P("indices",r,e,t),i=P("tensor",r,e,t),s=P("elementShape",r,e,t),a=P("numElements",r,e,t),o=Vq(i,n,s,a);return t.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const n=P("elementShape",r,e,t),i=P("elementDType",r,e,t);let s;r.op==="TensorListReserve"?s="numElements":s="maxNumElements";const a=P(s,r,e,t),o=r.op==="TensorListReserve"?-1:a,u=Bq(n,i,a,o);return t.addTensorList(u),[u.idTensor]}case"TensorListGather":{const n=P("tensorListId",r,e,t),i=P("indices",r,e,t),s=P("elementShape",r,e,t),a=P("elementDType",r,e,t);return[t.getTensorList(n.id).gather(i,a,s)]}case"TensorListStack":{const n=P("tensorListId",r,e,t),i=P("elementShape",r,e,t),s=P("elementDType",r,e,t),a=P("numElements",r,e,t);return[t.getTensorList(n.id).stack(i,s,a)]}case"TensorListFromTensor":{const n=P("tensor",r,e,t),i=P("elementShape",r,e,t),s=P("elementDType",r,e,t),a=zq(n,i,s);return t.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const n=P("tensorListId",r,e,t),i=t.getTensorList(n.id),s=P("dtype",r,e,t),a=P("elementShape",r,e,t);return[i.concat(s,a)]}case"TensorListPushBack":{const n=P("tensorListId",r,e,t),i=P("tensor",r,e,t),s=t.getTensorList(n.id);return s.pushBack(i),[s.idTensor]}case"TensorListPopBack":{const n=P("tensorListId",r,e,t),i=P("elementShape",r,e,t),s=P("elementDType",r,e,t);return[t.getTensorList(n.id).popBack(i,s)]}case"TensorListSplit":{const n=P("tensor",r,e,t),i=P("elementShape",r,e,t),s=P("lengths",r,e,t),a=Hq(n,s,i);return t.addTensorList(a),[a.idTensor]}case"TensorListLength":{const n=P("tensorListId",r,e,t),i=t.getTensorList(n.id);return[dn(i.size(),"int32")]}case"TensorListResize":{const n=P("tensorListId",r,e,t),i=P("size",r,e,t),a=t.getTensorList(n.id).resize(i);return t.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FT(r,e,t){const[n,i]=P("fusedOps",r,e,t),s=n==="biasadd",a=!s,o=i==="prelu",u=n==="fusedbatchnorm",h=P("numArgs",r,e,t);if(s){if(o&&h!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&s&&h!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const p=P("strides",r,e,t),m=Yy(r,e,t),y=P("dataFormat",r,e,t).toUpperCase(),v=P("dilations",r,e,t);let[S,T]=P("args",r,e,t);a&&(T=S,S=void 0);const E=P("leakyreluAlpha",r,e,t);return{stride:p,pad:m,dataFormat:y,dilations:v,biasArg:S,preluArg:T,activationFunc:i,leakyreluAlpha:E}}const Gq=(r,e,t,n=ti)=>{switch(r.op){case"Conv1D":{const i=P("stride",r,e,t),s=P("pad",r,e,t),a=P("dataFormat",r,e,t).toUpperCase(),o=P("dilation",r,e,t);return[n.conv1d(P("x",r,e,t),P("filter",r,e,t),i,s,a,o)]}case"Conv2D":{const i=P("strides",r,e,t),s=Yy(r,e,t),a=P("dataFormat",r,e,t).toUpperCase(),o=P("dilations",r,e,t);return[n.conv2d(P("x",r,e,t),P("filter",r,e,t),[i[1],i[2]],s,a,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:i,pad:s,dataFormat:a,dilations:o,biasArg:u,preluArg:h,activationFunc:p,leakyreluAlpha:m}=FT(r,e,t);return[n.fused.conv2d({x:P("x",r,e,t),filter:P("filter",r,e,t),strides:[i[1],i[2]],pad:s,dataFormat:a,dilations:[o[1],o[2]],bias:u,activation:p,preluActivationWeights:h,leakyreluAlpha:m})]}case"FusedDepthwiseConv2dNative":{const{stride:i,pad:s,dataFormat:a,dilations:o,biasArg:u,preluArg:h,activationFunc:p,leakyreluAlpha:m}=FT(r,e,t);return[n.fused.depthwiseConv2d({x:P("x",r,e,t),filter:P("filter",r,e,t),strides:[i[1],i[2]],pad:s,dataFormat:a,dilations:[o[1],o[2]],bias:u,activation:p,preluActivationWeights:h,leakyreluAlpha:m})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const i=P("outputShape",r,e,t),s=P("strides",r,e,t),a=Yy(r,e,t);return[n.conv2dTranspose(P("x",r,e,t),P("filter",r,e,t),i,[s[1],s[2]],a)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const i=P("strides",r,e,t),s=Yy(r,e,t),a=P("dilations",r,e,t),o=P("dataFormat",r,e,t).toUpperCase();return[n.depthwiseConv2d(P("input",r,e,t),P("filter",r,e,t),[i[1],i[2]],s,o,[a[1],a[2]])]}case"Conv3D":{const i=P("strides",r,e,t),s=P("pad",r,e,t),a=P("dataFormat",r,e,t).toUpperCase(),o=P("dilations",r,e,t);return[n.conv3d(P("x",r,e,t),P("filter",r,e,t),[i[1],i[2],i[3]],s,a,[o[1],o[2],o[3]])]}case"AvgPool":{const i=P("strides",r,e,t),s=P("pad",r,e,t),a=P("kernelSize",r,e,t);return[n.avgPool(P("x",r,e,t),[a[1],a[2]],[i[1],i[2]],s)]}case"MaxPool":{const i=P("strides",r,e,t),s=P("pad",r,e,t),a=P("kernelSize",r,e,t);return[n.maxPool(P("x",r,e,t),[a[1],a[2]],[i[1],i[2]],s)]}case"MaxPoolWithArgmax":{const i=P("strides",r,e,t),s=P("pad",r,e,t),a=P("kernelSize",r,e,t),o=P("includeBatchInIndex",r,e,t),{result:u,indexes:h}=n.maxPoolWithArgmax(P("x",r,e,t),[a[1],a[2]],[i[1],i[2]],s,o);return[u,h]}case"AvgPool3D":{const i=P("strides",r,e,t),s=P("pad",r,e,t),a=P("kernelSize",r,e,t);return[n.avgPool3d(P("x",r,e,t),[a[1],a[2],a[3]],[i[1],i[2],i[3]],s)]}case"MaxPool3D":{const i=P("strides",r,e,t),s=P("pad",r,e,t),a=P("kernelSize",r,e,t);return[n.maxPool3d(P("x",r,e,t),[a[1],a[2],a[3]],[i[1],i[2],i[3]],s)]}case"Dilation2D":{const i=P("strides",r,e,t),s=P("pad",r,e,t),a=P("dilations",r,e,t),o=i[1],u=i[2],h=a[1],p=a[2];return[n.dilation2d(P("x",r,e,t),P("filter",r,e,t),[o,u],s,[h,p],"NHWC")]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wq=(r,e,t,n=ti)=>{switch(r.op){case"Fill":{const i=P("shape",r,e,t),s=P("dtype",r,e,t),a=P("value",r,e,t);return[n.fill(i,a,s)]}case"LinSpace":{const i=P("start",r,e,t),s=P("stop",r,e,t),a=P("num",r,e,t);return[n.linspace(i,s,a)]}case"Multinomial":{const i=P("logits",r,e,t),s=P("numSamples",r,e,t),a=P("seed",r,e,t);return[n.multinomial(i,s,a)]}case"OneHot":{const i=P("indices",r,e,t),s=P("depth",r,e,t),a=P("onValue",r,e,t),o=P("offValue",r,e,t),u=P("dtype",r,e,t);return[n.oneHot(i,s,a,o,u)]}case"Ones":return[n.ones(P("shape",r,e,t),P("dtype",r,e,t))];case"OnesLike":return[n.onesLike(P("x",r,e,t))];case"RandomStandardNormal":return[n.randomStandardNormal(P("shape",r,e,t),P("dtype",r,e,t),P("seed",r,e,t))];case"RandomUniform":return[n.randomUniform(P("shape",r,e,t),P("minval",r,e,t),P("maxval",r,e,t),P("dtype",r,e,t))];case"RandomUniformInt":return[n.randomUniformInt(P("shape",r,e,t),P("minval",r,e,t),P("maxval",r,e,t),P("seed",r,e,t))];case"Range":{const i=P("start",r,e,t),s=P("stop",r,e,t),a=P("step",r,e,t);return[n.range(i,s,a,P("dtype",r,e,t))]}case"TruncatedNormal":{const i=P("shape",r,e,t),s=P("mean",r,e,t),a=P("stdDev",r,e,t),o=P("seed",r,e,t);return[n.truncatedNormal(i,s,a,P("dtype",r,e,t),o)]}case"Zeros":return[n.zeros(P("shape",r,e,t),P("dtype",r,e,t))];case"ZerosLike":return[n.zerosLike(P("x",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y_(r,e,t){const n=P("boxes",r,e,t),i=P("scores",r,e,t),s=P("maxOutputSize",r,e,t),a=P("iouThreshold",r,e,t),o=P("scoreThreshold",r,e,t),u=P("softNmsSigma",r,e,t);return{boxes:n,scores:i,maxOutputSize:s,iouThreshold:a,scoreThreshold:o,softNmsSigma:u}}const jq=async(r,e,t,n,i=ti)=>{switch(r.op){case"NonMaxSuppressionV5":{const{boxes:s,scores:a,maxOutputSize:o,iouThreshold:u,scoreThreshold:h,softNmsSigma:p}=Y_(r,e,t),m=await i.image.nonMaxSuppressionWithScoreAsync(s,a,o,u,h,p);return[m.selectedIndices,m.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:s,scores:a,maxOutputSize:o,iouThreshold:u,scoreThreshold:h}=Y_(r,e,t),p=P("padToMaxOutputSize",r,e,t),m=await i.image.nonMaxSuppressionPaddedAsync(s,a,o,u,h,p);return[m.selectedIndices,m.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:s,scores:a,maxOutputSize:o,iouThreshold:u,scoreThreshold:h}=Y_(r,e,t);return[await i.image.nonMaxSuppressionAsync(s,a,o,u,h)]}case"Where":{const s=i.cast(P("condition",r,e,t),"bool"),a=[await i.whereAsync(s)];return s.dispose(),a}case"ListDiff":return i.setdiff1dAsync(P("x",r,e,t),P("y",r,e,t));default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qq=(r,e,t,n=ti)=>{switch(r.op){case"LowerBound":{const i=P("sortedSequence",r,e,t),s=P("values",r,e,t);return[n.lowerBound(i,s)]}case"TopKV2":{const i=P("x",r,e,t),s=P("k",r,e,t),a=P("sorted",r,e,t),o=n.topk(i,s,a);return[o.values,o.indices]}case"UpperBound":{const i=P("sortedSequence",r,e,t),s=P("values",r,e,t);return[n.upperBound(i,s)]}case"Unique":{const i=P("x",r,e,t),s=n.unique(i);return[s.values,s.indices]}case"UniqueV2":{const i=P("x",r,e,t),s=P("axis",r,e,t),a=n.unique(i,s);return[a.values,a.indices]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xq=(r,e,t,n=ti)=>{switch(r.op){case"Const":return e[r.name];case"PlaceholderWithDefault":const i=P("default",r,e,t);return[ei(r.name,e,t)||i];case"Placeholder":return[ei(r.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const p=P("x",r,e,t);return[tl(p)]}case"IdentityN":return P("x",r,e,t).map(p=>tl(p));case"Snapshot":const s=P("x",r,e,t);return[tl(s)];case"Shape":return[n.tensor1d(P("x",r,e,t).shape,"int32")];case"ShapeN":return P("x",r,e,t).map(p=>n.tensor1d(p.shape));case"Size":return[n.scalar(P("x",r,e,t).size,"int32")];case"Rank":return[n.scalar(P("x",r,e,t).rank,"int32")];case"NoOp":return[n.scalar(1)];case"Print":const a=P("x",r,e,t),o=P("data",r,e,t),u=P("message",r,e,t),h=P("summarize",r,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let p=0;p<o.length;p++)console.log(Array.prototype.slice.call(o[p].dataSync()).slice(0,h));return[a];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kq{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=dn(0),this.tensorMap=new Map,Ma(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return dn(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return this.tensorMap.forEach(i=>i.dispose()),this.tensorMap.clear(),bn(()=>{const i=Au(t),s=n.length,a=i.length;j(s===a,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${a} elements.`);for(let o=0;o<s;o++){const u=n[o],h=i[o];Ma(h),this.tensorMap.set(u,h)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return bn(()=>{const i=[];for(let s=0;s<n.length;s++){const a=n[s],o=this.findWithDefault(a,t);i.push(o)}return uo(i)})}findWithDefault(e,t){const n=this.tensorMap.get(e);return n??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yq=async(r,e,t,n)=>{switch(r.op){case"HashTable":case"HashTableV2":{const i=n.getHashTableHandleByName(r.name);if(i!=null)return[i];{const s=P("keyDType",r,e,t),a=P("valueDType",r,e,t),o=new Kq(s,a);return n.addHashTable(r.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const i=P("tableHandle",r,e,t,n),s=P("keys",r,e,t),a=P("values",r,e,t);return[await n.getHashTableById(i.id).import(s,a)]}case"LookupTableFind":case"LookupTableFindV2":{const i=P("tableHandle",r,e,t,n),s=P("keys",r,e,t),a=P("defaultValue",r,e,t);return[await n.getHashTableById(i.id).find(s,a)]}case"LookupTableSize":case"LookupTableSizeV2":{const i=P("tableHandle",r,e,t,n);return[n.getHashTableById(i.id).tensorSize()]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zq=(r,e,t,n=ti)=>{switch(r.op){case"ResizeBilinear":{const i=P("images",r,e,t),s=P("size",r,e,t),a=P("alignCorners",r,e,t),o=P("halfPixelCenters",r,e,t);return[n.image.resizeBilinear(i,[s[0],s[1]],a,o)]}case"ResizeNearestNeighbor":{const i=P("images",r,e,t),s=P("size",r,e,t),a=P("alignCorners",r,e,t),o=P("halfPixelCenters",r,e,t);return[n.image.resizeNearestNeighbor(i,[s[0],s[1]],a,o)]}case"CropAndResize":{const i=P("image",r,e,t),s=P("boxes",r,e,t),a=P("boxInd",r,e,t),o=P("cropSize",r,e,t),u=P("method",r,e,t),h=P("extrapolationValue",r,e,t);return[n.image.cropAndResize(i,s,a,o,u,h)]}case"ImageProjectiveTransformV3":{const i=P("images",r,e,t),s=P("transforms",r,e,t),a=P("outputShape",r,e,t),o=P("fillValue",r,e,t),u=P("interpolation",r,e,t),h=P("fillMode",r,e,t);return[n.image.transform(i,s,u.toLowerCase(),h.toLowerCase(),o,a)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jq=(r,e,t,n=ti)=>{switch(r.op){case"Equal":return[n.equal(P("a",r,e,t),P("b",r,e,t))];case"NotEqual":return[n.notEqual(P("a",r,e,t),P("b",r,e,t))];case"Greater":return[n.greater(P("a",r,e,t),P("b",r,e,t))];case"GreaterEqual":return[n.greaterEqual(P("a",r,e,t),P("b",r,e,t))];case"Less":return[n.less(P("a",r,e,t),P("b",r,e,t))];case"LessEqual":return[n.lessEqual(P("a",r,e,t),P("b",r,e,t))];case"LogicalAnd":return[n.logicalAnd(P("a",r,e,t),P("b",r,e,t))];case"LogicalNot":return[n.logicalNot(P("a",r,e,t))];case"LogicalOr":return[n.logicalOr(P("a",r,e,t),P("b",r,e,t))];case"Select":case"SelectV2":return[n.where(P("condition",r,e,t),P("a",r,e,t),P("b",r,e,t))];case"BitwiseAnd":return[n.bitwiseAnd(P("a",r,e,t),P("b",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qq=(r,e,t,n=ti)=>{switch(r.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[n.matMul(P("a",r,e,t),P("b",r,e,t),P("transposeA",r,e,t),P("transposeB",r,e,t))];case"Einsum":return[n.einsum(P("equation",r,e,t),...P("tensors",r,e,t))];case"Transpose":return[n.transpose(P("x",r,e,t),P("perm",r,e,t))];case"_FusedMatMul":const[i,s]=P("fusedOps",r,e,t),a=i==="biasadd",o=s==="prelu",u=P("numArgs",r,e,t),h=P("leakyreluAlpha",r,e,t);if(a){if(o&&u!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&u!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[p,m]=P("args",r,e,t);return[n.fused.matMul({a:P("a",r,e,t),b:P("b",r,e,t),transposeA:P("transposeA",r,e,t),transposeB:P("transposeB",r,e,t),bias:p,activation:s,preluActivationWeights:m,leakyreluAlpha:h})];case"MatrixBandPart":return[n.linalg.bandPart(P("a",r,e,t),P("numLower",r,e,t),P("numUpper",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eX=(r,e,t,n=ti)=>{switch(r.op){case"EuclideanNorm":return[n.euclideanNorm(P("x",r,e,t),P("axis",r,e,t),P("keepDims",r,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[n.batchNorm(P("x",r,e,t),P("mean",r,e,t),P("variance",r,e,t),P("offset",r,e,t),P("scale",r,e,t),P("epsilon",r,e,t))];case"FusedBatchNormV3":return[n.batchNorm(P("x",r,e,t),P("mean",r,e,t),P("variance",r,e,t),P("offset",r,e,t),P("scale",r,e,t),P("epsilon",r,e,t))];case"LRN":return[n.localResponseNormalization(P("x",r,e,t),P("radius",r,e,t),P("bias",r,e,t),P("alpha",r,e,t),P("beta",r,e,t))];case"Softmax":return[n.softmax(P("x",r,e,t))];case"LogSoftmax":return[n.logSoftmax(P("x",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tX=(r,e,t,n=ti)=>{switch(r.op){case"RaggedGather":{const{outputNestedSplits:i,outputDenseValues:s}=n.raggedGather(P("paramsNestedSplits",r,e,t),P("paramsDenseValues",r,e,t),P("indices",r,e,t),P("outputRaggedRank",r,e,t));return i.concat(s)}case"RaggedRange":{const{rtNestedSplits:i,rtDenseValues:s}=n.raggedRange(P("starts",r,e,t),P("limits",r,e,t),P("splits",r,e,t));return[i,s]}case"RaggedTensorToTensor":return[n.raggedTensorToTensor(P("shape",r,e,t),P("values",r,e,t),P("defaultValue",r,e,t),P("rowPartitionTensors",r,e,t),P("rowPartitionTypes",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nX=(r,e,t,n=ti)=>{switch(r.op){case"Max":{const o=P("axis",r,e,t),u=P("keepDims",r,e,t);return[n.max(P("x",r,e,t),o,u)]}case"Mean":{const o=P("axis",r,e,t),u=P("keepDims",r,e,t);return[n.mean(P("x",r,e,t),o,u)]}case"Min":{const o=P("axis",r,e,t),u=P("keepDims",r,e,t);return[n.min(P("x",r,e,t),o,u)]}case"Sum":{const o=P("axis",r,e,t),u=P("keepDims",r,e,t);return[n.sum(P("x",r,e,t),o,u)]}case"All":{const o=P("axis",r,e,t),u=P("keepDims",r,e,t);return[n.all(P("x",r,e,t),o,u)]}case"Any":{const o=P("axis",r,e,t),u=P("keepDims",r,e,t);return[n.any(P("x",r,e,t),o,u)]}case"ArgMax":{const o=P("axis",r,e,t);return[n.argMax(P("x",r,e,t),o)]}case"ArgMin":{const o=P("axis",r,e,t);return[n.argMin(P("x",r,e,t),o)]}case"Prod":{const o=P("axis",r,e,t),u=P("keepDims",r,e,t);return[n.prod(P("x",r,e,t),o,u)]}case"Cumprod":{const o=P("axis",r,e,t),u=P("exclusive",r,e,t),h=P("reverse",r,e,t);return[n.cumprod(P("x",r,e,t),o,u,h)]}case"Cumsum":{const o=P("axis",r,e,t),u=P("exclusive",r,e,t),h=P("reverse",r,e,t);return[n.cumsum(P("x",r,e,t),o,u,h)]}case"Bincount":const i=P("x",r,e,t),s=P("weights",r,e,t),a=P("size",r,e,t);return[n.bincount(i,s,a)];case"DenseBincount":{const o=P("x",r,e,t),u=P("weights",r,e,t),h=P("size",r,e,t),p=P("binaryOutput",r,e,t);return[n.denseBincount(o,u,h,p)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rX=(r,e,t,n=ti)=>{switch(r.op){case"ConcatV2":case"Concat":{const i=P("n",r,e,t),s=P("axis",r,e,t);let a=P("tensors",r,e,t);return a=a.slice(0,i),[n.concat(a,s)]}case"Gather":{const i=P("x",r,e,t),s=P("indices",r,e,t);return[n.gather(i,n.cast(s,"int32"),0)]}case"GatherV2":{const i=P("axis",r,e,t),s=P("batchDims",r,e,t),a=P("x",r,e,t),o=P("indices",r,e,t);return[n.gather(a,n.cast(o,"int32"),i,s)]}case"Reverse":{const i=P("dims",r,e,t),s=[];for(let o=0;o<i.length;o++)i[o]&&s.push(o);const a=P("x",r,e,t);return[n.reverse(a,s)]}case"ReverseV2":{const i=P("axis",r,e,t),s=P("x",r,e,t);return[n.reverse(s,i)]}case"Slice":{const i=P("begin",r,e,t),s=P("size",r,e,t);return[n.slice(P("x",r,e,t),i,s)]}case"StridedSlice":{const i=P("begin",r,e,t),s=P("end",r,e,t),a=P("strides",r,e,t),o=P("beginMask",r,e,t),u=P("endMask",r,e,t),h=P("ellipsisMask",r,e,t),p=P("newAxisMask",r,e,t),m=P("shrinkAxisMask",r,e,t),y=P("x",r,e,t);return[n.stridedSlice(y,i,s,a,o,u,h,p,m)]}case"Pack":return bn(()=>{const i=P("axis",r,e,t),s=P("tensors",r,e,t),a=s[0].shape,o=n.squeeze(s[0]).shape,u=s.map(h=>{const p=Ra(h.shape,a);if(!p&&!Ra(n.squeeze(h).shape,o))throw new Error("the input tensors shape does not match");return p?h:n.reshape(h,a)});return[n.stack(u,i)]});case"Unpack":{const i=P("axis",r,e,t),s=P("tensor",r,e,t);return n.unstack(s,i)}case"Tile":{const i=P("reps",r,e,t);return[n.tile(P("x",r,e,t),i)]}case"Split":case"SplitV":{const i=P("axis",r,e,t),s=P("numOrSizeSplits",r,e,t),a=P("x",r,e,t);return n.split(a,s,i)}case"ScatterNd":{const i=P("indices",r,e,t),s=P("values",r,e,t),a=P("shape",r,e,t);return[n.scatterND(i,s,a)]}case"GatherNd":{const i=P("x",r,e,t),s=P("indices",r,e,t);return[n.gatherND(i,s)]}case"SparseToDense":{const i=P("sparseIndices",r,e,t),s=P("outputShape",r,e,t),a=P("sparseValues",r,e,t),o=P("defaultValue",r,e,t);return[n.sparseToDense(i,a,s,a.dtype===o.dtype?o:n.cast(o,a.dtype))]}case"TensorScatterUpdate":{const i=P("indices",r,e,t),s=P("values",r,e,t),a=P("tensor",r,e,t);return[n.tensorScatterUpdate(a,i,s)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iX=(r,e,t,n=ti)=>{switch(r.op){case"SparseFillEmptyRows":{const{outputIndices:i,outputValues:s,emptyRowIndicator:a,reverseIndexMap:o}=n.sparse.sparseFillEmptyRows(P("indices",r,e,t),P("values",r,e,t),P("denseShape",r,e,t),P("defaultValue",r,e,t));return[i,s,a,o]}case"SparseReshape":{const{outputIndices:i,outputShape:s}=n.sparse.sparseReshape(P("inputIndices",r,e,t),P("inputShape",r,e,t),P("newShape",r,e,t));return[i,s]}case"SparseSegmentMean":return[n.sparse.sparseSegmentMean(P("data",r,e,t),P("indices",r,e,t),P("segmentIds",r,e,t))];case"SparseSegmentSum":return[n.sparse.sparseSegmentSum(P("data",r,e,t),P("indices",r,e,t),P("segmentIds",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sX=(r,e,t,n=ti)=>{switch(r.op){case"FFT":return[n.fft(P("x",r,e,t))];case"IFFT":return[n.ifft(P("x",r,e,t))];case"RFFT":return[n.rfft(P("x",r,e,t))];case"IRFFT":return[n.irfft(P("x",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aX=(r,e,t,n=ti)=>{switch(r.op){case"StaticRegexReplace":return[n.string.staticRegexReplace(P("input",r,e,t),P("pattern",r,e,t),P("rewrite",r,e,t),P("replaceGlobal",r,e,t))];case"StringNGrams":{const{nGrams:i,nGramsSplits:s}=n.string.stringNGrams(P("data",r,e,t),P("dataSplits",r,e,t),P("separator",r,e,t),P("nGramWidths",r,e,t),P("leftPad",r,e,t),P("rightPad",r,e,t),P("padWidth",r,e,t),P("preserveShortSequences",r,e,t));return[i,s]}case"StringSplit":{const{indices:i,values:s,shape:a}=n.string.stringSplit(P("input",r,e,t),P("delimiter",r,e,t),P("skipEmpty",r,e,t));return[i,s,a]}case"StringToHashBucketFast":return[n.string.stringToHashBucketFast(P("input",r,e,t),P("numBuckets",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oX=(r,e,t,n=ti)=>{switch(r.op){case"Cast":return[n.cast(P("x",r,e,t),P("dtype",r,e,t))];case"ExpandDims":{const i=P("axis",r,e,t);return[n.expandDims(P("x",r,e,t),i)]}case"Squeeze":{const i=P("axis",r,e,t);return[n.squeeze(P("x",r,e,t),i)]}case"Reshape":return[n.reshape(P("x",r,e,t),P("shape",r,e,t))];case"EnsureShape":return[n.ensureShape(P("x",r,e,t),P("shape",r,e,t))];case"MirrorPad":return[n.mirrorPad(P("x",r,e,t),P("padding",r,e,t),P("mode",r,e,t))];case"PadV2":case"Pad":return[n.pad(P("x",r,e,t),P("padding",r,e,t),P("constantValue",r,e,t))];case"SpaceToBatchND":{const i=P("blockShape",r,e,t),s=P("paddings",r,e,t);return[n.spaceToBatchND(P("x",r,e,t),i,s)]}case"BatchToSpaceND":{const i=P("blockShape",r,e,t),s=P("crops",r,e,t);return[n.batchToSpaceND(P("x",r,e,t),i,s)]}case"DepthToSpace":{const i=P("blockSize",r,e,t),s=P("dataFormat",r,e,t).toUpperCase();return[n.depthToSpace(P("x",r,e,t),i,s)]}case"BroadcastTo":return[n.broadcastTo(P("x",r,e,t),P("shape",r,e,t))];case"BroadcastArgs":return[n.broadcastArgs(P("s0",r,e,t),P("s1",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UT(r,e,t,n,i=bn){const s=((a,o,u)=>{switch(a.category){case"arithmetic":return i(()=>Oq(a,o,u));case"basic_math":return i(()=>Fq(a,o,u));case"control":return $q(a,o,u);case"convolution":return i(()=>Gq(a,o,u));case"creation":return i(()=>Wq(a,o,u));case"dynamic":return jq(a,o,u);case"evaluation":return i(()=>qq(a,o,u));case"image":return i(()=>Zq(a,o,u));case"graph":return i(()=>Xq(a,o,u));case"logical":return i(()=>Jq(a,o,u));case"matrices":return i(()=>Qq(a,o,u));case"normalization":return i(()=>eX(a,o,u));case"ragged":return i(()=>tX(a,o,u));case"reduction":return i(()=>nX(a,o,u));case"slice_join":return i(()=>rX(a,o,u));case"sparse":return i(()=>iX(a,o,u));case"spectral":return i(()=>sX(a,o,u));case"string":return i(()=>aX(a,o,u));case"transformation":return i(()=>oX(a,o,u));case"hash_table":return Yq(a,o,u,n);case"custom":const h=V3(a.op);if(h&&h.customExecutor)return h.customExecutor(new Dq(a,o,u));throw TypeError(`Custom op ${a.op} is not registered.`);default:throw TypeError(`Unknown op '${a.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(r,e,t);return yu(s)?s.then(a=>[].concat(a)):[].concat(s)}class zT{constructor(e={},t={},n={},i={},s){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=i,this.parseNodeNameCache=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BT(r,e,t,n){const i=new Set,s=[];let a=null,o=null;const u=new Set,h=new Set(Object.keys(r).map(y=>us(y)[0]));n=n||[];const p=new Set(n.map(y=>us(y.name)[0])),m=[...e];for(;m.length>0;){const y=m.pop();if((kc(y)||mX(y)||gX(y))&&a==null&&(a=y,o=a.children.map(v=>v.name).filter(v=>i.has(v))),i.add(y.name),t[y.name]==null&&!h.has(y.name)&&!p.has(y.name)){if(y.inputs.length===0){s.push(y.name);continue}y.inputs.forEach(v=>{u.has(v.name)||(u.add(v.name),m.push(v))})}}return{inputs:r,outputs:e,usedNodes:i,missingInputs:s,dynamicNode:a,syncInputs:o}}function lX(r,e){const{usedNodes:t,inputs:n}=e,i=Object.keys(n).map(E=>us(E)[0]).map(E=>r.nodes[E]),s=r.initNodes||[],a=E=>t.has(typeof E=="string"?E:E.name);function o(E){return[...new Map(E.map(w=>[w.name,w])).values()]}const u=o([...i,...r.weights,...s]).filter(a),h=o([...u,...Object.values(r.nodes)]).filter(a),p=new Map(h.map(E=>[E.name,E])),m={};for(const E of h){m[E.name]=m[E.name]||0;for(const w of E.children)a(w)||(m[w.name]=Number.POSITIVE_INFINITY),m[w.name]=(m[w.name]||0)+1}const y=Object.entries(m).filter(([,E])=>E===0).map(([E])=>E),v=[...y];for(;y.length>0;){const E=y.pop(),w=p.get(E);for(const C of w.children.filter(a))--m[C.name]===0&&(v.push(C.name),y.push(C.name))}const S=v.map(E=>p.get(E)),T=uX(S,u);return cX(T,u),T}function uX(r,e){const t=new Map(r.map(a=>[a.name,a])),n=e.map(a=>a.name),i=new Set(n);for(;n.length>0;){const a=n.pop(),o=t.get(a);for(const u of o.children)!t.has(u.name)||i.has(u.name)||(i.add(u.name),n.push(u.name))}return r.filter(a=>i.has(a.name))}class Iy extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function cX(r,e){const t=new Map(r.map((o,u)=>[o.name,u])),n=new Set(e.map(o=>o.name)),i=o=>n.has(typeof o=="string"?o:o.name),s=new Set(r.map(o=>o.name)),a=o=>s.has(typeof o=="string"?o:o.name);for(const o of r){for(const u of o.children.filter(a)){if(!t.has(u.name))throw new Iy(`Child ${u.name} of node ${o.name} is unreachable.`);if(t.get(o.name)>t.get(u.name))throw new Iy(`Node ${o.name} is scheduled to run after its child ${u.name}.`)}if(!i(o))for(const u of o.inputs){if(!t.has(u.name))throw new Iy(`Input ${u.name} of node ${o.name} is unreachable.`);if(t.get(u.name)>t.get(o.name))throw new Iy(`Node ${o.name} is scheduled to run before its input ${u.name}.`)}}}function fX(r){const e=new Map(r.map((o,u)=>[o.name,u])),t=Number.MAX_SAFE_INTEGER,n=r.map((o,u)=>kc(o)?t:u),i=o=>{const u=n[e.get(o.name)];return u??-1},s=r.map((o,u)=>o.children.map(i).reduce((h,p)=>Math.max(h,p),n[u])),a=new Map;for(let o=0;o<r.length;++o){const u=s[o];if(u===t)continue;const h=r[o],p=r[u];a.has(p.name)||a.set(p.name,[]),a.get(p.name).push(h)}return a}const hX=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),dX=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),pX=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function kc(r){return hX.has(r.op)}function mX(r){return dX.has(r.op)}function gX(r){return pX.has(r.op)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class y0{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(n=>e[n].map(i=>i.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(n=>{this._functionExecutorMap[n]=new y0(e.functions[n],this)})}getCompilationKey(e,t){const n=e.map(s=>s.name).sort(),i=t.map(s=>s.name).sort();return n.join(this.SEPARATOR)+"--"+i.join(this.SEPARATOR)}compile(e,t){const n=BT(e,t,this.weightMap,this._initNodes),{missingInputs:i,dynamicNode:s,syncInputs:a}=n;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(i.length>0){const h=t.map(m=>m.name),p=Object.keys(e);throw new Error(`Cannot compute the outputs [${h}] from the provided inputs [${p}]. Missing the following inputs: [${i}]`)}const o=lX(this.graph,n),u=fX(o);return{orderedNodes:o,nodeLiveUntilMap:u}}cloneAndKeepTensor(e){if(e==null)return null;const t=e.clone();return Ma(t),t}cloneTensorList(e){return e?e.map(n=>this.cloneAndKeepTensor(n)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,n])=>[t,this.cloneTensorList(n)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const i=n.map(y=>this.graph.nodes[us(y)[0]]),s=t.map(y=>us(y)[0]),a=new Set(s);let o=s.map(y=>this.graph.nodes[y]);o.length===0&&(o=this._outputs);const u=this.getCompilationKey(i,o);let h=this.compiledMap.get(u);h==null&&(h=this.compile(e,o),this.compiledMap.set(u,h));try{this.keepIntermediateTensors=Ht().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(y){this.keepIntermediateTensors=!1,console.warn(y.message)}const p={},m={};return bn(()=>{const y=new zT(this.weightMap,p,m,this.functionExecutorMap,this.parseNodeNameCache),v=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(w=>{const[C,A]=us(w,y),I=[];I[A]=e[w],v[C]=I,this.keepIntermediateTensors&&(this.clonedTensorsMap[C]=this.cloneTensorList(I))});const S=this.getFrozenTensorIds(v),{orderedNodes:T,nodeLiveUntilMap:E}=h;for(const w of T){if(v[w.name])continue;const C=UT(w,v,y,this._resourceManager);if(yu(C))throw new Error(`The execution of the op '${w.op}' returned a promise. Please use model.executeAsync() instead.`);v[w.name]=C,this.keepIntermediateTensors&&(this.clonedTensorsMap[w.name]=this.cloneTensorList(C)),this.checkTensorForDisposalWithNodeLiveUntilInfo(w,v,y,S,a,E.get(w.name))}return this.parent==null&&y.dispose(S),t.map(w=>ei(w,v,y))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(n=>e[n]).map(n=>n.map(i=>i.id)));return new Set(t)}checkTensorForDisposal(e,t,n,i,s,a,o){if(!(kc(t)||a.has(e))){for(const u of n[e])u!=null&&(o[u.id]=(o[u.id]||0)+t.children.length);for(const u of t.inputs){if(kc(u))continue;const h=LT(u.name,n,i);if(h!=null)for(const p of h){if(!p||p.kept||s.has(p.id))continue;const m=o[p.id];m===1?(p.dispose(),delete o[p.id]):m!=null&&o[p.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,n,i,s,a){function o(u){return kc(u)||s.has(u.name)}if(!(kc(e)||a==null))for(const u of a){if(o(u))continue;const h=LT(u.name,t,n);for(const p of h)!p||p.kept||i.has(p.id)||p.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,n=!1,i={},s={}){this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=Ht().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(y){this.keepIntermediateTensors=!1,console.warn(y.message)}const a=new zT(this.weightMap,i,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const o=await this.executeWithControlFlow(e,a,t,n),u=t.map(y=>ei(y,o,a)),h=u.map(y=>y.id),p=Object.keys(e).map(y=>e[y].id),m=new Set([...h,...p,...this.weightIds]);return Object.values(o).forEach(y=>{y.forEach(v=>{v&&!v.isDisposed&&!m.has(v.id)&&v.dispose()})}),this.parent==null&&a.dispose(m),u}async executeFunctionAsync(e,t,n){const i=e.reduce((s,a,o)=>(s[this.inputs[o].name]=a,s),{});return this._executeAsync(i,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,i){const s=Object.keys(e),a=s.map(I=>this.graph.nodes[us(I)[0]]),o=n.map(I=>us(I)[0]),u=new Set(o);let h=o.map(I=>this.graph.nodes[I]);h.length===0&&(h=this._outputs);const{usedNodes:p,missingInputs:m,dynamicNode:y,syncInputs:v}=BT(e,h,this.weightMap,this._initNodes),S=[...a,...this.graph.weights,...this._initNodes||[]].map(I=>({node:I,contexts:t.currentContext})),T=Object.assign({},this.weightMap);Object.keys(e).forEach(I=>{const[F,U]=us(I),V=[];V[U]=e[I],T[F]=V});const E={},w=this.getFrozenTensorIds(T),C={};for(;S.length>0;){const I=this.processStack(a,S,t,T,C,w,u,E,p);await Promise.all(I)}y==null&&!i&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const A=h.filter(I=>!kc(I)&&!ei(I.name,T,t)).map(I=>I.name);if(A.length>0){let I="";throw y!=null&&(I=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${v}]`),new Error(`Cannot compute the outputs [${A}] from the provided inputs [${s}]. Consider providing the following inputs: [${m}]. ${I}`)}return T}processStack(e,t,n,i,s,a,o,u,h){const p=[];for(;t.length>0;){const m=t.pop();n.currentContext=m.contexts;let y="";if(m.node.op==="Enter"&&P("isConstant",m.node,i,n)&&([y]=el(m.node.name,n)),i[m.node.name]==null){const v=UT(m.node,i,n,this._resourceManager);y||([y]=el(m.node.name,n));const S=n.currentContext;yu(v)?p.push(v.then(T=>(i[y]=T,this.keepIntermediateTensors&&(this.clonedTensorsMap[y]=this.cloneTensorList(T)),n.currentContext=S,this.checkTensorForDisposal(y,m.node,i,n,a,o,u),this.processChildNodes(m.node,t,n,i,s,h),T))):(i[y]=v,this.keepIntermediateTensors&&(this.clonedTensorsMap[y]=this.cloneTensorList(v)),this.checkTensorForDisposal(y,m.node,i,n,a,o,u),this.processChildNodes(m.node,t,n,i,s,h))}else this.processChildNodes(m.node,t,n,i,s,h)}return p}processChildNodes(e,t,n,i,s,a){e.children.forEach(o=>{const[u]=el(o.name,n);s[u]||!a.has(o.name)||(o.op==="Merge"?o.inputNames.some(h=>!!ei(h,i,n))&&(s[u]=!0,t.push({contexts:n.currentContext,node:o})):o.inputNames.every(h=>!!ei(h,i,n))&&(s[u]=!0,t.push({contexts:n.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const n=e[t],[i]=us(t),s=this.graph.nodes[i];if(s.attrParams.shape&&s.attrParams.shape.value){const a=s.attrParams.shape.value,o=a.length===n.shape.length&&n.shape.every((u,h)=>a[h]===-1||a[h]===u);j(o,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${a}], but was [${n.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&j(n.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(e){var t,n;const i={};for(const s in e){const a=(n=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||n===void 0?void 0:n[s];a!=null?i[a.name]=e[s]:i[s]=e[s]}return i}checkInputs(e){const t=Object.keys(e).filter(n=>{const[i]=us(n);return this.graph.nodes[i]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var n,i;const s=(i=(n=this._signature)===null||n===void 0?void 0:n.outputs)===null||i===void 0?void 0:i[t];return s!=null?s.name:t},{})}checkOutputs(e){e.forEach(t=>{const[n]=us(t);if(!this.graph.nodes[n])throw new Error(`The output '${t}' is not found in the graph`)})}}class yX{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vX="?tfjs-format=file",_X="model.json";class Ew{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},n=_w){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,t==null&&(this.loadOptions={}),this.resourceManager=new yX}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return yu(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const t=await zR(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const n=this.artifacts.modelTopology;let i=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const s=this.artifacts.userDefinedMetadata;s.signature!=null&&(i=s.signature),s.structuredOutputKeys!=null&&(this.structuredOutputKeys=s.structuredOutputKeys)}if(this.signature=i,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new y0(kT.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const s=kT.Instance.transformGraph(e.modelInitializer);this.initializer=new y0(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){const n=this.io.getSaveHandlers(e);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${e}'`);e=n[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof ur?[e]:e,n={};return t.forEach((i,s)=>n[this.structuredOutputKeys[s]]=i),n}return e}predict(e,t){const n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){const n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof ur)&&!Array.isArray(e)){const s=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(s!=null)for(const a in s){const o=s[a];o.resourceId!=null&&(e[a]=this.resourceIdToCapturedInput[o.resourceId])}return e}e=Array.isArray(e)?e:[e];const n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let i=0;return this.inputNodes.reduce((s,a)=>{var o,u,h;const p=(h=(u=(o=this.signature)===null||o===void 0?void 0:o.inputs)===null||u===void 0?void 0:u[a])===null||h===void 0?void 0:h.resourceId;return p!=null?s[a]=this.resourceIdToCapturedInput[p]:s[a]=e[i++],s},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,n=Object.keys(t);for(let i=0;i<n.length;i++){const s=n[i],a=t[s];this.resourceIdToCapturedInput[a.resourceId]=e[i]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Ci(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function xX(r,e={},t=_w){if(r==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof r=="string"&&(r=wX(r));const n=new Ew(r,e,t);return await n.load(),n}function SX(r){if(r==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let e;if(r instanceof Array){const[n,i]=r;if(!n)throw new Error("modelJSON must be the first element of the array");if(!i||!(i instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in n))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in n))throw new Error("Model JSON is missing 'weightsManifest'");const s=c0(n.weightsManifest),a=E1(n,s,i);e=m0(a)}else if("load"in r)e=r;else if("modelTopology"in r&&"weightSpecs"in r&&"weightData"in r)e=m0(r);else throw new Error("Unknown model format");const t=new Ew(e);return t.load(),t}function wX(r){return r.endsWith("/")||(r=r+"/"),`${r}${_X}${vX}`}/** @license See the LICENSE file. */const EX="4.22.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bX=Object.freeze(Object.defineProperty({__proto__:null,GraphModel:Ew,deregisterOp:K9,loadGraphModel:xX,loadGraphModelSync:SX,registerOp:X9,version_converter:EX},Symbol.toStringTag,{value:"Module"})),TX=SS(bX),MX=SS(j9);/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var AX=Mp.exports,VT;function NX(){return VT||(VT=1,function(r,e){(function(t,n){n(e,TX,MX)})(AX,function(t,n,i){const s={1:{name:"/m/01g317",id:1,displayName:"person"},2:{name:"/m/0199g",id:2,displayName:"bicycle"},3:{name:"/m/0k4j",id:3,displayName:"car"},4:{name:"/m/04_sv",id:4,displayName:"motorcycle"},5:{name:"/m/05czz6l",id:5,displayName:"airplane"},6:{name:"/m/01bjv",id:6,displayName:"bus"},7:{name:"/m/07jdr",id:7,displayName:"train"},8:{name:"/m/07r04",id:8,displayName:"truck"},9:{name:"/m/019jd",id:9,displayName:"boat"},10:{name:"/m/015qff",id:10,displayName:"traffic light"},11:{name:"/m/01pns0",id:11,displayName:"fire hydrant"},13:{name:"/m/02pv19",id:13,displayName:"stop sign"},14:{name:"/m/015qbp",id:14,displayName:"parking meter"},15:{name:"/m/0cvnqh",id:15,displayName:"bench"},16:{name:"/m/015p6",id:16,displayName:"bird"},17:{name:"/m/01yrx",id:17,displayName:"cat"},18:{name:"/m/0bt9lr",id:18,displayName:"dog"},19:{name:"/m/03k3r",id:19,displayName:"horse"},20:{name:"/m/07bgp",id:20,displayName:"sheep"},21:{name:"/m/01xq0k1",id:21,displayName:"cow"},22:{name:"/m/0bwd_0j",id:22,displayName:"elephant"},23:{name:"/m/01dws",id:23,displayName:"bear"},24:{name:"/m/0898b",id:24,displayName:"zebra"},25:{name:"/m/03bk1",id:25,displayName:"giraffe"},27:{name:"/m/01940j",id:27,displayName:"backpack"},28:{name:"/m/0hnnb",id:28,displayName:"umbrella"},31:{name:"/m/080hkjn",id:31,displayName:"handbag"},32:{name:"/m/01rkbr",id:32,displayName:"tie"},33:{name:"/m/01s55n",id:33,displayName:"suitcase"},34:{name:"/m/02wmf",id:34,displayName:"frisbee"},35:{name:"/m/071p9",id:35,displayName:"skis"},36:{name:"/m/06__v",id:36,displayName:"snowboard"},37:{name:"/m/018xm",id:37,displayName:"sports ball"},38:{name:"/m/02zt3",id:38,displayName:"kite"},39:{name:"/m/03g8mr",id:39,displayName:"baseball bat"},40:{name:"/m/03grzl",id:40,displayName:"baseball glove"},41:{name:"/m/06_fw",id:41,displayName:"skateboard"},42:{name:"/m/019w40",id:42,displayName:"surfboard"},43:{name:"/m/0dv9c",id:43,displayName:"tennis racket"},44:{name:"/m/04dr76w",id:44,displayName:"bottle"},46:{name:"/m/09tvcd",id:46,displayName:"wine glass"},47:{name:"/m/08gqpm",id:47,displayName:"cup"},48:{name:"/m/0dt3t",id:48,displayName:"fork"},49:{name:"/m/04ctx",id:49,displayName:"knife"},50:{name:"/m/0cmx8",id:50,displayName:"spoon"},51:{name:"/m/04kkgm",id:51,displayName:"bowl"},52:{name:"/m/09qck",id:52,displayName:"banana"},53:{name:"/m/014j1m",id:53,displayName:"apple"},54:{name:"/m/0l515",id:54,displayName:"sandwich"},55:{name:"/m/0cyhj_",id:55,displayName:"orange"},56:{name:"/m/0hkxq",id:56,displayName:"broccoli"},57:{name:"/m/0fj52s",id:57,displayName:"carrot"},58:{name:"/m/01b9xk",id:58,displayName:"hot dog"},59:{name:"/m/0663v",id:59,displayName:"pizza"},60:{name:"/m/0jy4k",id:60,displayName:"donut"},61:{name:"/m/0fszt",id:61,displayName:"cake"},62:{name:"/m/01mzpv",id:62,displayName:"chair"},63:{name:"/m/02crq1",id:63,displayName:"couch"},64:{name:"/m/03fp41",id:64,displayName:"potted plant"},65:{name:"/m/03ssj5",id:65,displayName:"bed"},67:{name:"/m/04bcr3",id:67,displayName:"dining table"},70:{name:"/m/09g1w",id:70,displayName:"toilet"},72:{name:"/m/07c52",id:72,displayName:"tv"},73:{name:"/m/01c648",id:73,displayName:"laptop"},74:{name:"/m/020lf",id:74,displayName:"mouse"},75:{name:"/m/0qjjc",id:75,displayName:"remote"},76:{name:"/m/01m2v",id:76,displayName:"keyboard"},77:{name:"/m/050k8",id:77,displayName:"cell phone"},78:{name:"/m/0fx9l",id:78,displayName:"microwave"},79:{name:"/m/029bxz",id:79,displayName:"oven"},80:{name:"/m/01k6s3",id:80,displayName:"toaster"},81:{name:"/m/0130jx",id:81,displayName:"sink"},82:{name:"/m/040b_t",id:82,displayName:"refrigerator"},84:{name:"/m/0bt_c3",id:84,displayName:"book"},85:{name:"/m/01x3z",id:85,displayName:"clock"},86:{name:"/m/02s195",id:86,displayName:"vase"},87:{name:"/m/01lsmm",id:87,displayName:"scissors"},88:{name:"/m/0kmg4",id:88,displayName:"teddy bear"},89:{name:"/m/03wvsk",id:89,displayName:"hair drier"},90:{name:"/m/012xff",id:90,displayName:"toothbrush"}};class a{constructor(u,h){this.modelPath=h||`https://storage.googleapis.com/tfjs-models/savedmodel/${this.getPrefix(u)}/model.json`}getPrefix(u){return u==="lite_mobilenet_v2"?`ssd${u}`:`ssd_${u}`}async load(){this.model=await n.loadGraphModel(this.modelPath);const u=i.zeros([1,300,300,3],"int32"),h=await this.model.executeAsync(u);await Promise.all(h.map(p=>p.data())),h.map(p=>p.dispose()),u.dispose()}async infer(u,h,p){const m=i.tidy(()=>(u instanceof i.Tensor||(u=i.browser.fromPixels(u)),i.expandDims(u))),y=m.shape[1],v=m.shape[2],S=await this.model.executeAsync(m),T=S[0].dataSync(),E=S[1].dataSync();m.dispose(),i.dispose(S);const[w,C]=this.calculateMaxScores(T,S[0].shape[1],S[0].shape[2]),A=i.getBackend();i.getBackend()==="webgl"&&i.setBackend("cpu");const I=i.tidy(()=>{const U=i.tensor2d(E,[S[1].shape[1],S[1].shape[3]]);return i.image.nonMaxSuppression(U,w,h,p,p)}),F=I.dataSync();return I.dispose(),A!==i.getBackend()&&i.setBackend(A),this.buildDetectedObjects(v,y,E,w,F,C)}buildDetectedObjects(u,h,p,m,y,v){const S=y.length,T=[];for(let E=0;E<S;E++){const w=[];for(let U=0;U<4;U++)w[U]=p[4*y[E]+U];const C=w[0]*h,A=w[1]*u,I=w[2]*h,F=w[3]*u;w[0]=A,w[1]=C,w[2]=F-A,w[3]=I-C,T.push({bbox:w,class:s[v[y[E]]+1].displayName,score:m[y[E]]})}return T}calculateMaxScores(u,h,p){const m=[],y=[];for(let v=0;v<h;v++){let S=Number.MIN_VALUE,T=-1;for(let E=0;E<p;E++)u[v*p+E]>S&&(S=u[v*p+E],T=E);m[v]=S,y[v]=T}return[m,y]}async detect(u,h=20,p=.5){return this.infer(u,h,p)}dispose(){this.model!=null&&this.model.dispose()}}t.ObjectDetection=a,t.load=async function(o={}){if(i==null)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");const u=o.base||"lite_mobilenet_v2",h=o.modelUrl;if(["mobilenet_v1","mobilenet_v2","lite_mobilenet_v2"].indexOf(u)===-1)throw new Error(`ObjectDetection constructed with invalid base model ${u}. Valid names are 'mobilenet_v1', 'mobilenet_v2' and 'lite_mobilenet_v2'.`);const p=new a(u,h);return await p.load(),p},t.version="2.2.3",Object.defineProperty(t,"__esModule",{value:!0})})}(Mp,Mp.exports)),Mp.exports}var CX=NX();const RX=({onScanComplete:r})=>{const e=gt.useRef(null),t=gt.useRef(null),[n,i]=gt.useState(null),[s,a]=gt.useState([]);gt.useEffect(()=>{(async()=>{const m=await CX.load();i(m)})()},[]);const o=async()=>{try{const p=await navigator.mediaDevices.getUserMedia({video:!0});e.current.srcObject=p}catch(p){console.error("Error accessing camera:",p)}},u=async()=>{if(!n||!e.current)return;const p=await n.detect(e.current);a(p);const m=t.current.getContext("2d");m.clearRect(0,0,t.current.width,t.current.height);const y=p.find(S=>S.class.toLowerCase()==="paper"||S.class.toLowerCase()==="book");let v=1;y&&(v=297/y.bbox[3]),p.forEach((S,T)=>{const{bbox:E,class:w,score:C}=S,[A,I,F,U]=E;m.strokeStyle="red",m.lineWidth=2,m.strokeRect(A,I,F,U);const V=Math.round(U*v),G=Math.round(F*v);m.font="16px Arial",m.fillStyle="red",m.fillText(`${w} (${C.toFixed(2)})`,A,I-10),m.fillText(`~${G}mm x ${V}mm`,A,I-25)})},h=async()=>{if(!s.length){alert("Please scan the space first!");return}const p=s.map((m,y)=>({id:y,type:m.class,position:{x:m.bbox[0],y:m.bbox[1]},size:{width:m.bbox[2],height:m.bbox[3]}}));r(p)};return lt.jsxs("div",{className:"space-scanner",children:[lt.jsx("h2",{children:"Space Scanner"}),lt.jsx("button",{onClick:o,children:"Start Camera"}),lt.jsxs("div",{className:"scanner-container",children:[lt.jsx("video",{ref:e,width:"640",height:"480",autoPlay:!0,playsInline:!0}),lt.jsx("canvas",{ref:t,width:"640",height:"480",style:{position:"absolute",top:0,left:0}})]}),lt.jsx("button",{onClick:u,children:"Detect Objects"}),lt.jsx("button",{onClick:h,children:"Generate Layout"})]})},IX=({layout:r,items:e})=>{const{camera:t}=Zo(),n=(i,s)=>{const o={book:"#2ecc71",bottle:"#3498db",cup:"#e74c3c",keyboard:"#95a5a6",mouse:"#f1c40f",default:"#9b59b6"};return lt.jsxs("mesh",{position:s,onClick:u=>{u.stopPropagation()},children:[lt.jsx("boxGeometry",{args:[.5,.5,.5]}),lt.jsx("meshStandardMaterial",{color:o[i.toLowerCase()]||o.default})]})};return lt.jsxs(lt.Fragment,{children:[r==null?void 0:r.map((i,s)=>lt.jsx("group",{children:n(i.type,[i.position.x,i.position.y,0])},s)),r&&lt.jsxs("group",{position:[0,0,-2],children:[lt.jsxs("mesh",{position:[0,-1,0],children:[lt.jsx("boxGeometry",{args:[5,.1,3]}),lt.jsx("meshStandardMaterial",{color:"#34495e"})]}),lt.jsxs("mesh",{position:[0,.5,0],children:[lt.jsx("boxGeometry",{args:[5,.1,3]}),lt.jsx("meshStandardMaterial",{color:"#34495e"})]})]})]})},PX=({suggestions:r})=>lt.jsxs("div",{className:"product-suggestions",children:[lt.jsx("h2",{children:"Product Suggestions"}),lt.jsx("div",{className:"suggestions-grid",children:r.map((e,t)=>lt.jsxs("div",{className:"suggestion-card",children:[lt.jsx("img",{src:e.image,alt:e.name}),lt.jsx("h3",{children:e.name}),lt.jsx("p",{children:e.description}),lt.jsx("p",{className:"price",children:e.price}),lt.jsx("a",{href:e.link,className:"buy-button",children:"View Product"})]},t))})]});function LX(){const[r,e]=gt.useState([]),[t,n]=gt.useState(null),[i,s]=gt.useState([]);return lt.jsxs("div",{className:"app-container",children:[lt.jsx("header",{children:lt.jsx("h1",{children:"Home Organization Assistant"})}),lt.jsxs("main",{className:"main-content",children:[lt.jsx("div",{className:"inventory-section",children:lt.jsx(fV,{items:r,onAddItem:a=>e([...r,a])})}),lt.jsx("div",{className:"scanner-section",children:lt.jsx(RX,{onScanComplete:a=>n(a)})}),lt.jsx("div",{className:"organization-section",children:lt.jsxs(tV,{children:[lt.jsx("ambientLight",{intensity:.5}),lt.jsx("pointLight",{position:[10,10,10]}),lt.jsx(IX,{layout:t,items:r}),lt.jsx(cV,{})]})}),lt.jsx("div",{className:"suggestions-section",children:lt.jsx(PX,{suggestions:i})})]}),lt.jsx("footer",{children:lt.jsx("p",{children:"AI Home Organization Assistant  2025"})})]})}TL.createRoot(document.getElementById("root")).render(lt.jsx(vL.StrictMode,{children:lt.jsx(LX,{})}));
